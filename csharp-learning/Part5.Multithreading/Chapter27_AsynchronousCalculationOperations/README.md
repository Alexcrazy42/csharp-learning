# Глава 27. Асинхронные вычислительные операции

В этой главе рассказывается о различных способах асинхронного выполнения 
операций, вынесенных в отдельные потоки. К вычислительным операциям, в частности, 
относятся компиляция кода, проверка орфографии, проверка грамматики, 
пересчет электронных таблиц, перекодирование аудио- и видеоданных, создание 
миниатюр изображений. Как видите, такие операции встречаются в финансовых 
и технических приложениях повсеместно.

Так как потоки у нас не работают на 100%, это значит, что некоторые (если не все) потоки в 
процессах вообще не исполняются. Они ждут операции ввода или вывода, например срабатывания 
таймера, чтения данных из базы или записи данных в нее, нажатия клавиши на клавиатуре, 
перемещения указателя или нажатия кнопки мыши.

При операциях ввода-вывода драйверы Microsoft Windows инициируют работу устройств, а сам 
процессор в это время не исполняет потоки, запущенные в системе. Именно поэтому диспетчер 
задач показывает низкую загрузку процессора.

Однако даже приложения, предназначенные для операций ввода-вывода, обрабатывают 
получаемые данные, поэтому распараллеливание вычислений может 
значительно повысить их пропускную способность. В этой главе рассказывается 
о пуле потоков общеязыковой исполняющей среды и основных приемах его использования. 
Это крайне важная информация, так как пул потоков является ключевой технологией, 
обеспечивающей разработку и реализацию масштабируемых, 
быстрореагирующих и надежных приложений и компонентов. Также в этой главе 
рассказывается о механизмах, позволяющих выполнять вычислительные операции 
посредством пула потоков. Эти операции происходят в асинхронном режиме, что 
позволяет, во-первых, обеспечить быструю реакцию на действия пользователей 
приложений с графическим интерфейсом, во-вторых, распределить занимающие 
много времени вычисления между различными процессорами.

## Пул потоков CLR

Создание потока - дорогостоящая операция. Кроме того, при наличии множества потоков впустую
расходуется память и снижается производительность, ведь ОС приходится планировать выполнение 
потоков и выполнять переключение контекста.

Среда CLR спопосбна управлять собственным пулом потоков, то есть наборов готовых потоков,
доступных для использования приложениями. Для каждого экземпляра CLR существует свой пул,
используемый всеми доменами приложений, находяющимися под управлением экземпляра CLR. 

При инициализации CLR пул пуст. В его внутренней реализации поддерживается очередь запросов
на выполнение операций. Для выполнения приложением асинхронной операции вызывается метод,
размещающий соответствующий запрос в очереди пула потоков. Код пула извлекает записи из очереди
и распределяет их среди потоков из пула. Если пул пуст, создается новый поток. Как уже 
отмечалось, создание потока отрицательно сказывается на производительности. Однако по завершению 
исполнения своего задания поток не уничтожается, а возвращается в пул и ожидает следующего 
запроса. Поскольку поток не уничтожается, производительности не страдает.

Когда приложение отправляет пулу много запросов, он пытается обслужить их 
все с помощью одного потока. Однако если приложение создает очередь запросов 
быстрее, чем поток из пула их обслуживает, создаются дополнительные потоки. 
Такой подход позволяет обойтись при обработке запросов небольшим количеством 
потоков.

Когда приложение прекращает отправлять запросы в пул, появляются незанятые 
потоки, впустую занимающие память. Поэтому через некоторое время бездействия 
(различное для разных версий CLR) поток пробуждается и самоуничтожается, освобождая ресурсы. 
Это опять отрицательно сказывается на производительности, но в 
данном случае это уже не столь важно, поскольку уничтожаемый поток все равно простаивал, 
а значит, приложение в данный момент не было особо загружено работой.

Пул потоков позволяет найти компромисс в ситуации, когда малое количество 
потоков экономит ресурсы, а большое позволяет воспользоваться преимуществами 
многопроцессорных систем, а также многоядерных и гиперпотоковых процессоров. 
Пул потоков действует по эвристическому алгоритму. Если приложение должно 
выполнить множество заданий и при этом имеются доступные процессоры, пул 
создает больше потоков. При снижении загрузки приложения потоки из пула 
самоуничтожаются

## Простые вычислительные операции