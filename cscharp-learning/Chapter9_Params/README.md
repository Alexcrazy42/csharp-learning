# Глава 9. Параметры

Различные способы передачи параметров в метод. Как определить необязательный параметры, задать параметр по имени и передать его по ссылке. 
Таже рассмотрена процедура определения методов, принимающих различное количество аргументов

1) Необязательные и именованные параметры
	1.1) Значения по умолчания
	1.2) Именованные параметры
	1.3) Передаваемые в метод параметры компилятор рассматривает слева направо. 

2) Правила работы с параметрами:
	2.1) Значения по умолчанию могут быть для методов, конструкторов методов и параметрических свойств (индексаторов), также их можно указывать для параметров, являющихся частью определения делегатов
	2.2) Параметры по умолчанию должны следовать за всеми остальными
	2.3) Значения по умолчанию должны оставаться неизменными. То есть их можно создавать только для примитивных типов. Или для ссылочного типа, которые допускают значения null
	2.4) Запрещается переименовывать параметрические переменные, так как это влечет за собой необходимость редактирования вызывающего кода, который передает аргументы по имени параметра
	2.5) Для параметров помеченных ref и out, значения по умолчанию не задаются

3) Правила вызова метода с параметрами по умолчанию:
	3.1) Именованные аргументы в конце

4) Неявно типизированные локальные переменные
	4.1) Ключевое слово var 
	4.2) Нельзя присваивать null
	4.3) Самая большая польза от того, что мы можем сократить большие выражения с двух сторон
	4.4) Также можно использовать с ключевыми словами foreach, using и for
	4.5) Функцию неявного задания типа локальных переменных следует задействовать при работе с методами, испольщими анонимные типы
	4.6) Параметр метода нельзя определить словом var
	4.7) Является просто синтаксическим сахаром, поэтому не стоит путать с dynamic, который может использоваться
		как локальная переменная, поле и параметр метода. Невозможно привести выражение к типу var, но к dynamic можно

5) Передача параметров в метод по ссылке
	5.1) CLR по дефолту предполагает, что все параметры передаются по значению. При передачи объекта ссылочного типа передается указатель на этот объект. То есть метод может поменять объект, который в heap
		Если параметр значимый тип - передается его копия, исходный не изменяется объект
	5.2) CLR позволяет передавать параметры по ссылке, а не по значению. 
	5.3) Ключевые слова out и ref. Заставляют csc генерировать метаданные, описывающие параметр как переданный по ссылке. csc использует эти метаданные для генерации кода, передающего вместо самого параметра его адрес
	5.4) Если параметр помечен ключевым словом out, вызывающий код может не инициализировать его, пока не вызван сам метод. 
		В этом случае вызванный метод не может прочитать значение параметра и должен записать его, прежде чем вернуть управление
	5.5) Если параметр помечен как ref, вызывающий код должен инициализировать его перед вызовом метода, а вызванный метод может как читать, 
		так и записывать значение параметра.
	5.6) Поведение value и reference type значительно отличается при использование ref и out
	5.7) С точки зрения IL и CLR ключевые слова out и ref ничем не различаются: оба заставляют передавать
		указатель на экземпляр объекта. Разница в том, что они помогают компилятору гарантировать корректность кода.
	5.8) Можно создать перегрузку метода: один метод будет принимать просто значимый тип, второй - ref либо out. Но одновременно и ref и out нельзя сделать,
		так как результатом их JIT-компиляции становится идентичный код метаданных, представляющий сигнатуру методов.
	5.9) Для значимых типов эта возможность возволяет имитировать поведение ссылочных типов: они позволяют методу управлять единственным экземпляром значимого типа
		Вызывающий код должен выделить память для этого экземпляра, а вызванный метод управляет выделенной памятью.
	5.10) В случае ссылочных типов вызывающий код выделяет память для указателя на передаваемый объект, в вызванный метод управляет этим указателем
		В силу этих особенностей использование ключевых слов ref и out со ссылочными типами полезно, лишь когда метод собирается "вернуть" ссылку на известный ему объект.
	5.11) Если параметр ref или out имеет тип object, то мы не можем передать другой тип, это необходимо для обеспечения безопасности типов
	
6) Передача в метод переменного количества аргументов
	6.1) ключевое слово params
	6.2) ключевым словом params может быть помечен только последний параметр метода (ParamsArrayAttrubute). Он должен указывать на одномерный массив произвольного типа
	6.3) вызов метода, принимающего переменное число аргументов, снижает производительность, если, конечно, нпе передавать в явном виде значение null. Всем объектам выделяется место в куче и инициализировать элементы массива
		А по завершении метода, она не очистится самостоятельно, ее потом очистил сборщик мусора. Чтобы улучшить производительность можно определить несколько перегруженных методов, в которых 
		не используется ключевое слово params. 

7) Типы параметров и возвращаемых значений
	7.1) Объявляя тип параметров метода, нужно по возможности указывать наиболее общие типы, предпочитая интерфейсы базовым классам
		Например, лучше всего объявить параметр IEnumerable<T>, чем List<T>, или еще более сторогого интерфейсного типа ICollection<T> или IList<T>
		Это позволяет создавать гибкие методы, которые можно использовать в разнообразных ситуациях. 
		Лучше всего использовать интерфейсные типы для параметров
	7.2) Лучше использовать более общие классы, чем более строгие
	7.3) Для возвращаемого типа: как можно строже тип из досутпных (пытаясь не ограничиваться конкретным типов)
		Например, лучше объявить метод, возвращаюший FileStream, а не Stream
	7.4) Иногда требуется сохранить возможность изменять внутреннюю реализацию метода, не влияя на вызывающий код. 
		Например, раньше метод мог возвращать List<string>, а после захочем мы возвращать String[]. В подобных случаях 
		следует выбирать более мягкий тип возвращаемого объекта, например IList<string>, который является самым "строгим" из самых "мягких" типов
		возможных для возвращаемого типа. Например мы можем на захотеть по каким то причинам использовать IEnumerable<String> или ICollection<String>,
		по причине того, например, что когда мы можем захотеть получить длину коллекции в вызывающем коде

8) Константность
	8.1) Можно объявлять методы и параметры как константы в некоторых языках. Этим мы запрещаем  коду в экземплярном методе менять поля объекта
		или объекты, передаваемые в метод. 
		В первую очередь отметим, что в неуправляемом коде C++ пометка экземплярного метода или параметра ключевым словом const
		гарантировала неизменность этого метода или параметра стандартными средствами кода. При этом кода, меняющий объект или параметр путем игнорирования их 
		"константной" природы или же путем получения адреса объекта или параметра и записи по этому адресу, можно было бы поместить внутрь метода
		В определенном смысла такое поведение врет программистам, утверждая, что константные объекты или константные параметры вообще нельзя менять
	8.2) Создавая реализацию типа, разработчик может просто избегать написания кода, меняющего объекты и параметры.
		Кроме того, специалисты Microsoft не предусмотрели в CLR возможность проверки неизменности константных объектов или константных параметров. 
		CLR пришлось бы при каждой операции записи проверять, не выполняется ли запись в константный обхекта, что снизило бы эффективность
		Естественно, обнаружение нарушения должно проивзодить вброс исключения. 
		Более того, поддержка констант создает дополнительные сложности для разработчиков. В частности, при наследовании неизменяемого типа производные типы 
		должны соблюдать это ограничение. Кроме того, неизменяемый тип, скорее всего, должен состоять из полей, которые тоже представляют собой неизменяемые типы. 
		Это лишь несколько причин почему CLR не поддерживает константные объекты/аргументы
