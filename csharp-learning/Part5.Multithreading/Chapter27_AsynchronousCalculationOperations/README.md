# Глава 27. Асинхронные вычислительные операции

В этой главе рассказывается о различных способах асинхронного выполнения 
операций, вынесенных в отдельные потоки. К вычислительным операциям, в частности, 
относятся компиляция кода, проверка орфографии, проверка грамматики, 
пересчет электронных таблиц, перекодирование аудио- и видеоданных, создание 
миниатюр изображений. Как видите, такие операции встречаются в финансовых 
и технических приложениях повсеместно.

Так как потоки у нас не работают на 100%, это значит, что некоторые (если не все) потоки в 
процессах вообще не исполняются. Они ждут операции ввода или вывода, например срабатывания 
таймера, чтения данных из базы или записи данных в нее, нажатия клавиши на клавиатуре, 
перемещения указателя или нажатия кнопки мыши.

При операциях ввода-вывода драйверы Microsoft Windows инициируют работу устройств, а сам 
процессор в это время не исполняет потоки, запущенные в системе. Именно поэтому диспетчер 
задач показывает низкую загрузку процессора.

Однако даже приложения, предназначенные для операций ввода-вывода, обрабатывают 
получаемые данные, поэтому распараллеливание вычислений может 
значительно повысить их пропускную способность. В этой главе рассказывается 
о пуле потоков общеязыковой исполняющей среды и основных приемах его использования. 
Это крайне важная информация, так как пул потоков является ключевой технологией, 
обеспечивающей разработку и реализацию масштабируемых, 
быстрореагирующих и надежных приложений и компонентов. Также в этой главе 
рассказывается о механизмах, позволяющих выполнять вычислительные операции 
посредством пула потоков. Эти операции происходят в асинхронном режиме, что 
позволяет, во-первых, обеспечить быструю реакцию на действия пользователей 
приложений с графическим интерфейсом, во-вторых, распределить занимающие 
много времени вычисления между различными процессорами.

## Пул потоков CLR

Создание потока - дорогостоящая операция. Кроме того, при наличии множества потоков впустую
расходуется память и снижается производительность, ведь ОС приходится планировать выполнение 
потоков и выполнять переключение контекста.

Среда CLR спопосбна управлять собственным пулом потоков, то есть наборов готовых потоков,
доступных для использования приложениями. Для каждого экземпляра CLR существует свой пул,
используемый всеми доменами приложений, находяющимися под управлением экземпляра CLR. 

При инициализации CLR пул пуст. В его внутренней реализации поддерживается очередь запросов
на выполнение операций. Для выполнения приложением асинхронной операции вызывается метод,
размещающий соответствующий запрос в очереди пула потоков. Код пула извлекает записи из очереди
и распределяет их среди потоков из пула. Если пул пуст, создается новый поток. Как уже 
отмечалось, создание потока отрицательно сказывается на производительности. Однако по завершению 
исполнения своего задания поток не уничтожается, а возвращается в пул и ожидает следующего 
запроса. Поскольку поток не уничтожается, производительности не страдает.

Когда приложение отправляет пулу много запросов, он пытается обслужить их 
все с помощью одного потока. Однако если приложение создает очередь запросов 
быстрее, чем поток из пула их обслуживает, создаются дополнительные потоки. 
Такой подход позволяет обойтись при обработке запросов небольшим количеством 
потоков.

Когда приложение прекращает отправлять запросы в пул, появляются незанятые 
потоки, впустую занимающие память. Поэтому через некоторое время бездействия 
(различное для разных версий CLR) поток пробуждается и самоуничтожается, освобождая ресурсы. 
Это опять отрицательно сказывается на производительности, но в 
данном случае это уже не столь важно, поскольку уничтожаемый поток все равно простаивал, 
а значит, приложение в данный момент не было особо загружено работой.

Пул потоков позволяет найти компромисс в ситуации, когда малое количество 
потоков экономит ресурсы, а большое позволяет воспользоваться преимуществами 
многопроцессорных систем, а также многоядерных и гиперпотоковых процессоров. 
Пул потоков действует по эвристическому алгоритму. Если приложение должно 
выполнить множество заданий и при этом имеются доступные процессоры, пул 
создает больше потоков. При снижении загрузки приложения потоки из пула 
самоуничтожаются

## Простые вычислительные операции

Для добавления в очередь пула потоков асинхронных вычислительных операций 
обычно вызывают один из следующих методов класса ThreadPool:

```
static Boolean QueueUserWorkItem(WaitCallback callBack);
static Boolean QueueUserWorkItem(WaitCallback callBack, Object state);
```

Эти методы ставят «рабочий элемент» вместе с дополнительными данными 
состояния в очередь пула потоков и сразу возвращают управление приложению. 
Рабочим элементом называется указанный в параметре callback метод, который 
будет вызван потоком из пула. Этому методу можно передать один параметр 
через аргумент state (данные состояния). Без этого параметра версия метода 
QueueUserWorkItem передает методу обратного вызова значение null. Все заканчивается тем, 
что один из потоков пула обработает рабочий элемент, приводя к вызову 
указанного метода. Создаваемый метод обратного вызова должен соответствовать 
делегату System.Threading.WaitCallback, который определяется так:

```
delegate void WaitCallback(Object state);
```

### ПРИМЕЧАНИЕ

Если метод обратного вызова генерирует необработанное исключение, CLR завершает процесс 
(если это не противоречит политике хоста). Необработанные исключения
обсуждались в главе 20.

В приложениях Windows Store класс System.Threading.ThreadPool недоступен для
открытого использования. Впрочем, он косвенно используется при использовании
типов из пространства имен System.Threading.Tasks (см. раздел «Задания» далее
в этой главе).

## Контексты исполнения

С каждым потоком связан определенный контекст исполнения. Он включает в себя параметры 
безопасности (сжатый стек, свойство Principal объекта 
Thread и идентификационные данные Windows), параметры хоста (System.
Threading.HostExecutionContextManager) и контекстные данные логического 
вызова (см. методы LogicalSetData и LogicalGetData класса System.Runtime.
Remoting.Messaging.CallContext).

Когда поток исполняет код, значения параметров контекста исполнения оказывают влияние на 
некоторые операции. В идеале всякий раз при использовании для выполнения заданий
вспомогательного потока в этот вспомогальный поток должен копироваться контекст исполнения
первого потока. Это гарантирует использование одинаковых параметров безопасности и хоста
в обоих потоках, а также доступ вспомогательного потока к данным, сохраненным в контексте
логического вызова исходного потока.

По умолчанию CLR автоматически копирует контекст исполнения самого первого потока во все
вспомогальные потоки. Это гарантирует безопасность, но в ущерб производительности, потому что 
в контексте исполнения содержится много информации. Сбор всей информации и ее копирование 
во вспомогательные потоки занимает немало времени. Вспомогательный поток может, в свою очередь,
использовать вспомогательные потоки, при этом создаются и инициализируются дополнительные 
структуры данных.

Класс ExecutionContext в пространстве имен System.Threading позволяет 
управлять копированием контекста исполнения потока. Вот как он выглядит:

```
public sealed class ExecutionContext : IDisposable, ISerializable {
	[SecurityCritical] public static AsyncFlowControl SuppressFlow();
	public static void RestoreFlow();
	public static Boolean IsFlowSuppressed();
	// Не показаны редко применяемые методы
}
```

С помощью этого класса можно запретить копирование контекста исполнения, 
повысив производительность приложения. Для серверных приложений рост производительности 
в этом случае оказывается весьма значительным. Для клиентских приложений особой выгоды нет, 
кроме того, метод SuppressFlow помечается атрибутом [SecurityCritical], в результате 
становится невозможным вызов некоторых клиентских приложений.

Разумеется, запрещать копирование контекста исполнения можно, только если вспомогательному 
потоку не требуется содержащаяся там информация. Когда инициирующий контекст 
исполнения не переходит во вспомогательный поток, тот использует последний 
связанный с ним контекст исполнения. Поэтому при отключенном копировании 
контекста поток не должен исполнять код, зависящий от состояния текущего контекста 
исполнения (например, идентификационных данных пользователя Windows).

Пока мы обсуждаем только запрет копирования контекста исполнения при вызове метода 
ThreadPool.QueueUserWorkItem, но этот прием используется как при 
работе с объектами Task (см. раздел «Задания» данной главы), так и при инициировании 
асинхронных операций ввода-вывода (о них речь идет в главе 28).

## Скоординированная отмена

Платформа .NET предлагает стандартный паттерн операций отмены. Этот паттерн 
является скоординированным, то есть требует явной поддержки отмена операций. Другими словами,
как код, выполняющий отменяемую операцию, так и код, пытающийся реализовать отмену, должны
относиться к типам, о которых рассказывается в этом разделе. Так как необходимость отмены
занимающих много времени вычислительный операций не вызывается сомнения, к вашим вычислительным
операциям имеет смысл добавить возможность отмена. О том, как это сделать и идет речь в этом разделе.

Начнем с описания двух основных типов из библиотеки FCL, входящих в состав стандартного
паттерна скоординированной отмены.

Для начала потребуется объект System.Threading.CancellationTokenSource. Вот как выглядит 
данный класс:

```
public sealed class CancellationTokenSource : IDisposable { // Ссылочный тип
	public CancellationTokenSource();
	public Boolean IsCancellationRequested { get; }
	public CancellationToken Token { get; }
	public void Cancel(); // Вызывает Cancel с аргументом false
	public void Cancel(Boolean throwOnFirstException);
	...
}
```

Этот объект содержит все состояния, необходимые для управляемой отмены. После создания 
объекта CancellationTokenSource (ссылочный тип) получить один или несколько экземпляров 
CancellationToken (значимый тип) можно из свойства Token. Затем они передаются операциям, 
поддерживающим отмену. Вот наиболее полезные члены значимого типа CancellationToken:

```
public struct CancellationToken { // Значимый тип
	public static CancellationToken None { get; } // Очень удобно

	Boolean IsCancellationRequested { get; } // Вызывается операциями,
											// не связанными с Task

	public void ThrowIfCancellationRequested(); // Вызван операциями,
												// связанными с Task
	
	// WaitHandle устанавливается при отмене CancellationTokenSource
	public WaitHandle WaitHandle { get; }
	// Члены GetHashCode, Equals, == и != не показаны

	public Boolean CanBeCanceled { get; } // Редко используется

	public CancellationTokenRegistration Register(
		Action<Object> callback, Object state,
		Boolean useSynchronizationContext); // Более простые варианты
											// перегрузки не показаны
}
```

Экземпляр CancellationToken относится к упрощенному значимому типу, так как содержит всего одно
закрытое поле: ссылку на свой объект CancellationTokenSource. Цикл вычислительной операции может 
периодически обращаться к свойству IsCancellationRequested объекта CancellationToken, чтобы узнать,
не требуется ли раннее завершение его работы, то есть прерывание операции. Процессор перестает
совершать операции, в результате которых вы не заинтересованы.

### ПРИМЕЧАНИЕ

Чтобы предотвратить отмену операции, ей можно передать экземпляр
CancellationToken, возвращенный статическим свойством None структуры
CancellationToken. Это очень удобное свойство возвращает специальный экземпляр
CancellationToken, не связанный с каким-либо объектом CancellationTokenSource (его
закрытое поле имеет значение null). При отсутствии объекта CancellationTokenSource
отсутствует и код, который может вызвать метод Cancel. А значит, запрос к свойству
IsCancellationRequested упомянутого экземпляра CancellationToken всегда будет получать в 
ответ значение false. Аналогичная ситуация с запросом к свойству CanBeCanceled. 
Значение true возвращается только для экземпляров CancellationToken, полученных
через свойство Token перечисления CancellationTokenSource.

При желании можно зарегистрировать один или несколько методов таким 
образом, чтобы они вызывались при отмене объекта CancellationTokenSource. 

Для регистрации метода обратного вызова следует передать методу Register структуры 
CancellationToken делегата Action<Object> состояние, которое вы предполагаете передать через 
делегат в метод обратного вызова, и значение типа Boolean, указывающее, должен ли вызываться
делегат с использованием контекста SynchronizationContext вызывающего потока. Если передать 
в параметре useSynchronizationContext значение false, поток, вызывающий метод Cancel, последовательно
запустит все зарегистрированные методы. При передаче же значения true обратные вызовы отсылаются
фиксированному объекту SynchronizationContext, который выбирает, какой из потоков активизирует
тот или иной обратный вызов.

### ПРИМЕЧАНИЕ

Если вы регистрируете метод обратного вызова, используя уже отмененный объект
CancellationTokenSource, поток, вызывающий метод Register, активизирует обратный
вызов (вероятно, черезSynchronizationContext вызывающего потока, если в параметре
useSynchronizationContext передано значение true).

Многократный вызов метода Register приводит к многократной же активизации 
методов обратного вызова, причем последние могут генерировать необработанное
исключение. Если вызвать метод Cancel объекта CancellationTokenSource с параметром true, 
первый же метод обратного вызова, ставший источником необработанного исключения, остановит
выполнение остальных методов обратного вызова, 
а исключение будет также сгенерировано методом Cancel. Если же передать этому 
методу значение false, будут вызваны все зарегистрированные методы обратного 
вызова. Все появляющиеся при этом необработанные исключения добавляются 
в коллекцию. Если после завершения всех методов обратного вызова обнаруживается наличие 
необработанных исключений, метод Cancel генерирует исключение 
AggregateException, свойству InnerExceptions которого присваивается коллекция 
сгенерированных объектов исключений. При отсутствии необработанных исключений метод Cancel 
просто возвращает управление.

### ВНИМАНИЕ

евозможно определить, с какой операцией связан тот или иной объект из коллекции
InnerExceptions исключения AggregateException. То есть вы фактически получаете
только информацию о том, что некоторые операции выполнены не были, и по типу
исключения можете определить, в чем была причина такого поведения. Чтобы выяснить 
местоположение ошибки, нужно исследовать свойство StackTrace объекта
исключения и вручную проверить исходный код.

Метод Register объекта CancellationToken возвращает структуру CancellationTokenRegistration, 
которая выглядит следующим образом:

```
public struct CancellationTokenRegistration 
	: IEquatable<CancellationTokenRegistration>, IDisposable 
{
	public void Dispose();
	// Не показаны GetHashCode, Equals, операторы == и !=
	}
```

Метод Dispose позволяет удалить из объекта CancellationTokenSource зарегистрированный 
обратный вызов, с которым связан данный объект. В результате при вызове метода Cancel 
этот обратный вызов игнорируется. Вот код, демонстрирующий регистрацию двух обратных 
вызовов с одним объектом CancellationTokenSource:

```
varcts = new CancellationTokenSource();
cts.Token.Register(() => Console.WriteLine("Canceled 1"));
cts.Token.Register(() => Console.WriteLine("Canceled 2"));
```

При вызове ```cts.Cancel()``` будут выполнены оба обратных вызова.

Наконец, можно создать новый объект CancellationTokenSource, связав друг с другом другие 
объекты CancellationTokenSource. Отмена этого нового объекта произойдет при отмене любого
из входящих в его состав объектов. 

```
var cts1 = new CancellationTokenSource();
var cts2 = new CancellationTokenSource();

// тип CancellationTokenSource
var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cts1.Token, cts2.Token);
```

Часто возникают ситцации, когда наужно отменить операцию по истечении какого-то периода
времени. Например, серверное приложение начало выполнять вычисления по запросу от клиента. При 
этом серверное приложеное должно гарантировать, что ответит клиенту не позже чем через 2 секунды.
В некоторых случаях лучше получить ответ с ошибкой или неполным результатом, чем дожидаться
полного результата в течении долгого времени. К счастью, класс CancellationTokenSource умеет
инициализировать собственную отмену по истечении заданного интервала. Для этого следует 
либо создать объект CancellationTokenSource одним из конструкторов, получающих величину задержки,
либо вызвать метод CancelAfter класса CancellationTokenSource.

```
public sealed class CancellationTokenSource : IDisposable { // Ссылочный тип
	public CancellationTokenSource(Int32 millisecondsDelay); 
	public CancellationTokenSource(TimeSpan delay); 
	public void CancelAfter(Int32 millisecondsDelay); 
	public void CancelAfter(TimeSpan delay); 
	... 
}
```

## Задания

