# Глава 14. Символы, строки и обработка текста


1) Символы
	1) System.Char - Значимый тип
	2) Категория символа - управляющий символ, символ валюты, буква в нижнем или верхнем регистре, знак 
		пунктуации, математический символ и т.д. System.Globalization.UnicodeCategory
	3) I sDigit, Isletter, IsWhiteSpace, IsUpper, Islower, IsPunctuation, 
		IsletterOrDigit, IsContro1 , IsNumber, IsSeparator, IsSurrogate, IsLowSurrogate, 
		IsHighSurrogate и IsSymbo1

	4) Региональные стандарты - culture, для преобразования символа с учетом culture, относящихся к вызывающему
		потоку (статическое свойство CurrentCulture класса Thread), служат ToLower и ToUpper
		Чтобы задать определенный набор региональных стандартов, передайте этим методам экземпляр класса 
		CultureInfo
	5) Equals - возвращает true, если два экземпляра представляют один и тот же 16-разрядный Unicode символ
		CompareTo - сравнивает два кодовых значения без учета региональных стандартов
		ToString - возвращает строку, состоящую из одного символа
		Parse и TryParse - получают односимвольную строку и возвращают соответствующую кодовую позицию UTF-16
		GetNumericValue - возвращает числовой эквивалент символа

	6) Три способа преобразования различных числовых типов в экземпляры типа Char и наоборот:
		- Приведение типа. Самый эффективный способ, тк компилятор генерирует IL-команды преобразования без
		вызовов каких-либо методов. ДЛя преобразования типа Char в числовое значение, такое как Int32,
		приведение подходит лучше всего. Кроме того, в C# допускается указывать, какой код выполняет 
		преобразование: проверяемый или непроверяемый
		- Использование типа Convert. У типа System.Convert есть несколько статических методов, корректно
		преобразующих Char в числовой тип и обратно. Все эти методы выполняют преобразование как проверяемую
		операцию, чтобы в случае потери данных при преобразовании вбрасывалось исключение OverflowException
		- Использование интерфейса IConvertible. В типе Char и во всех числовых типах библиотеки FCL 
		реализован интерфейс IConvertible, в котором определены такие методы, как ToUInt16 и ToChar. Этот
		способ наименее эффективен, так как вызов интерфейсных методов для числовых типов приводит к упаковке
		экземпляра: Char и все числовые типы являются значимыми. Методы IConvertible выбрасывают исключение
		InvalidCastException, если преобразование невозможно или грозит потерей данных. Все методы IConvertible
		за исключением GetTypeCode принимают ссылку на объект, реализующий интерфейс IFormatProvider. Этот 
		параметр полезен, когда по какой-либо причине при преобразовании требуется учитывать региональные 
		стандарты. В большинстве операций в этом параметре передается null, потому что он все равно 
		игнорируется.

2) Тип System.String
	1) Неизменяемый упорядоченный набор символом
	2) В C# String считают элементарным типом, то есть csc разрешает вставлять литеральные строки 
		непостредственно в исходный код. Компилятор помещает эти литеральные строки в метаданные модуля, где
		они часто загружаются и на них ссылаются во время выполнения.
		в C# с помощью оператора new нельзя создавать объекты типа String
	3) За создание нового экземпляра объекта отвечает IL-команда newobj. Однако для создание строки нет
		такой команды, вместо нее используется специальная команда ldstr (загрузка строки), которая создает
		объект String на основе литеральной строки, полученной из метаданных. 
	3) В C# имеется специальный синтаксис для ввода литеральных строк в исходный код. Для вставки специальных
		символов, таких как конец строки, возврат каретки, забой
		Задавать в коде последовательность символов конца строки и перевода каретки напрямую не рекомендуется
		Лучше использовать System.Enviroment.NewLine, которая зависит от платформы
	4) оператор + выполняется на этапе компиляции и не создается отдельных строк из литералов
		Конкатенация нелитеральных строк с помощью оператора + происходит на этапе выполнения. Для
		конкатенации нескольких строк на этапе выполнения оператор + применять нежелательно, тк он создает 
		в куче несколько строковых объектов. Вместо него использовать надо тип System.Text.StringBuilder
	5) В C# есть особый вариант объявления строки, в которой все символы между кавычками трактуются как часть
		строки. Это специальные объявления - буквальные строки (verbatim strings) - обычно используют при
		задании пути к файлу или каталогу и при работе с регулярными выражениями

3) Неизменяемые строки
	1) объект String - неизменяемым, то есть созданную однажды строку нельзя сделать длиннее или короче, 
		в ней нельзя изменить ни одного символа. Неизменяемость строк дает определенные преимущества. 
		```
		if(s.ToUpperInvariant().Substring(10, 21).EndWith("EXE")) { }
		```
		В приведенном коде ToUpperInvariant возвращает новую строку, символы в строке s не изменяются.
		Substring обрабатывает стркоу, возвращенную ToUpperInvariant, и тоже возаращает новую строку, которая
		затем передается методу EndsWith. По итогу в куче помимо строки s создается еще 2 строки, на которые
		нет ссылки. Это приведет потом к сборке мусора. Если требуется эффективно выполнять много операций со
		строками лучше использовать класс StringBuilder
	2) Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками. 
		Кроме того, в CLR несколько ссылок String могут указывать на один, а не на несколько разных строковых
		объектов, если строки идентичны. А значит, можно сократить количество строк в системе и уменьшить 
		расход памяти - это именно то, что непосредственно относится к интернированию строк (string interning)
		По соображениям производительности тип String тесно интегрирован с CLR. В частности CLR "знает" о 
		размещении полей в этом типе и обращается к ним напрямую. За повышение производительности и прямой доступ
		приходится платить небольшую цену: класс String является изолированным. Иначе, имея возможность
		описать собственный тип, производный от String, можно было бы добавлять свои поля, противоречащие
		структуре String и нарушающие работу CLR. Кроме того, ваши действия могли бы нарушить представляения
		CLR об объекте String, которые вытекают из его неизменности

4) Сравнение строк
	1) Сравнение - одно из наиболее часто выполняемых со строками операций. Мы сравниваем их для выяснения, 
		равны ли они, и для сортировки
	2) Для сравнения строк Рихтер настоятельно рекомендует использовать один из этих методов, реализованных
		в классе String:
		![](images/string_comparison.png)
		При сортировке всегда нужно учитывать регистр
		А аргументе comparisonType передается одно из значений, определенных в перечислимом типе
		StringComparison, где есть: CurrentCulture, CuurentCultureIgnoreCase, InvariantCulture,
		InvariantCultureIgnoreCase, Ordinal, OrdinalIgnoreCase
		Аргумент CompareOptions является одним из значений, определенным перечислимым типом CompareOptions
	3) Во многих программах строки применяют для решения таких задач, как поддержка имен путей и файлов, 
		URL-адресов, параметров и разделов реестра, переменных окружения, отражения, XML-тегов. Для сравнения
		строк внутри программы следует всегда использовать флаг StringComparison.Ordinal или
		StringComparison.OrdinalIgnoreCase. Это дает самый быстрый инструмент сравнения так как он игнорирует
		лингвистические особенности и региональные стандарты.
		В то же время, если требуется корректно сравнивать строки с точки зрения лингвистических особенностей
		(обычно перед выводом их на экран для пользователя), следует использовать флаг
		SystemComparison.CurrrentCulture или SystemComparison.CurrrentCultureIgnoreCase 
	4) Обычно следует избегать использования флагов StriпgComparison.InvariantCulture и 
		StringComparison.InvariantCultureIgnoreCase. Хотя эти значения и позволяют выполнить лингвистически 
		корректное сравнение, применение их для сравнения строк в программе занимает больше времени, чем флага 
		StringComparisoп.Ordinal или StringComparison.OrdinalIgnoreCase. Кроме того, игнорирование региональных 
		стандартов - совсем неудачный выбор для сортировки строк, которые планируется показывать пользователю
	5) Если вы хотите изменить регистр символов строки перед выполнением п ростого срав нения, следует 
		использовать предоставляемый String  метод ToUpperInvariant или ToLowerInvariant. При нормализации строк 
		настоятельно рекомендуется использовать метод ToUpperInvariant, а не 
		TolowerInvariant из-за того, что в Microsoft сравнение строк в верхнем 
		регистре оптимизировано. На самом деле, в FCL перед не зависящим от 
		регистра сравнением строки нормализуют путем приведения их к верхнему 
		регистру.




Вопросы:
1) Зачем строки сделали неизменяемыми (Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками?)

Дальше посмотреть:
1) System.Enviroment
2) класс является изолированным
