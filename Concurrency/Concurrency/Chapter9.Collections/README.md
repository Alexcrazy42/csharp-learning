# Коллекции


Неизменяемые коллекции:

Операции, доступные только чтения выполняются с неизменяемым экземпляром напрямую

Операции записи возвращают новый неизменяемый экземпляр вместо изменения существующего.

Потокобезопасные коллекции: перечисление производится со "снимком", применяется сочтения
детализированных блокировок и приемов, не использующих блокировки, потоки блокируются на 
минимальное время либо же не блокируются вовсе. 
Ключевое преимущество: возможность обращаться к коллекциям безопасно из нескольких потоков
при том, что операции будут блокировать код на минимальное время.

Коллекции "производитель/потребитель"

![](images/9.1_table.png)

Библиотека Channels находится в пакете System.Threading.Channels, 
BufferBlock<T> — в пакете System.Threading.Tasks.Dataflow, 
а AsyncProducerConsumerQueue<T> и AsyncCollection<T> — в пакете 
Nito.AsyncEx

# 9.1. Неизменяемые стеки и очереди

## Задача

Вам нужна коллекция — стек или очередь, которая изменяется не очень 
часто и к которой можно безопасно обращаться из нескольких потоков.

Например, очередь может использоваться для представления последовательности 
выполняемых операций, а стек — для представления последовательности операций отмены.

## Решение

Используем ImmutableStack из примера.

Неизменяемые коллекции строятся на основе паттерна, в соответствии с которым они возвращают
обновленную коллекцию; ссылка на исходную коллекцию остается без изменений. Это означает,
что если имеется ссылка на конкретный экземпляр неизменяемой коллекции, она никогда не 
изменится.

## Пояснение

Экземпляр никогда не изменяется

Так как экземпляр никогда не изменяется, он потокобезопасен по своей природе

При вызове изменяющего метода для неизменяемой коллекции возвращается новая измененная версия

Неизменяемые коллекции являются потокобезопасными, но ссылки на них потокобезопасными не являются


# 9.2. Неизменяемые списки

## Задача

Нужна структура данных с возможностью индексирования, которая изменяется не слишком часто
и допускает безопасные обращения из нескольких потоков

## Решение

ImuttableList

Во внутренней реализации неизменяемого списка используется двоичное дерево, чтобы
экземпляры неизменямого списка могли максимизировать объем памяти, используемый совместно
с другими экземплярами. В результате для некоторых распространненых операций существуют
различия в быстродействии между ImmutableList и List

![](images/9.2_table.png)

## Пояснение

ImmutableList<T> — хорошая структура данных общего назначения, но из-за 
различий в быстродействии вы не сможете бездумно заменить ей все 
List<T>. List<T> часто используется по умолчанию — именно эту структуру 
данных следует использовать, если только у вас нет веских причин для 
выбора другой коллекции

# 9.3. Неизменяемые множества

## Задача

Нужна структура данных, не расчитанная на хранение дубликатов, которая не слишком часто 
изменяется и допускает безопасные обращения из нескольких потоков.

Например, индекс слов из файла может быть хорошим кандидатом для применения множества.

## Решение

ImmutableHashSet, ImmutableSortedSet

Только отсортированное множество допускает индексирование по аналогии со списком.

Несортированные и отсортированные множества обладают сходным быстродействием.


![](images/9.3_table.png)

Одно важное примечание по поводу отсортированных множеств: индексирование 
для них выполняется за время O(log N), а не O(1), как у 
ImmutableList<T> (см. рецепт 9.2). Это означает, что в данной ситуации 
действует та же рекомендация: используйте foreach вместо for там, где 
это возможно, с ImmutableSortedSet<T>.

## Пояснение

Неизменяемые множества полезны, но заполнение большого неизменяемого 
множества может быть медленной операцией.

# 9.4. Неизменяемые словари

## Задача

Нужна коллекция "ключ/значение", которая не слишком часто изменяется и допускает безопасные
обращения из нескольких потоков.

Например, в этой коллекции могут храниться данные ссылок в подстановочной таблице; данные
ссылок редко изменяются, но они должны быть доступны для разных потоков.

## Решение

ImmutableDictionary, ImmutableSortedDictionary


Вот такая конструкция юзается:
```
sortedDictionary = sortedDictionary.SetItem(10, "Diez");
```

Несортированные и отсортированные словари обладают сходным быстродействием, 
но я рекомендую использовать неупорядоченные словари, если только не требуется, 
чтобы элементы были отсортированы.

![](images/9.4_tables.png)

Несортированные словари могут работать в целом немного 
быстрее. Кроме того, несортированные словари могут использоваться 
с любыми типами ключей, тогда как отсортированные словари требуют 
полной совместимости типов их ключей

## Пояснение

Если исходные ссылочные данные загружаются в начале работы программы, вы сможете 
воспользоваться механизмом построителей для конструирования исходного неизменяемого 
словаря. С другой стороны, если ссылочные данные строятся 
постепенно во время выполнения, вероятно, можно будет воспользоваться 
обычным методом Add неизменяемых словарей.

# 9.5. Потокобезопасные словари

## Задача

Имеется коллекция ключ-значение (например, кэш в памяти), которая должна поддерживаться
в синхронизированном состоянии, даже если несколько потоков выполняют с ней операции
чтения и записи

## Решение

ConcurrentDictionary

## Пояснение

# 9.6. Блокирующие очереди

## Задача

## Решение

## Пояснение

# 9.7. Блокирующие стеки и мультимножества

## Задача

## Решение

## Пояснение


# 9.8. Асинхронные очереди

## Задача

## Решение

## Пояснение

# 9.9. Регулировка очередей

## Задача

## Решение

## Пояснение

# 9.10. Выборка в очередях

## Задача

## Решение

## Пояснение

# 9.11. Асинхронные стеки и мультимножества

## Задача

## Решение

## Пояснение

# 9.12. Блокирующие/асинхронные очереди

## Задача

## Решение

## Пояснение