# Глава 10. Свойства

Свойства позволяют обратиться к методу в исходном тексте программы посредством упрощенного синтаксиса. 
CLR поддерживает два типа свойств: без параметров (свойства), и с параметрами - у них в разных языках разное название
Например, в C# свойства с параметрами называют индексаторами, а в VB - свойствами по умолчанию
Инициализация свойств при помощи инициализаторов объектов и коллекций, а также о механизме объединения свойств посредством анонимных типов и типа System.Tuple

1) Свойства без параметров
	1.1) Можно создать тип, которые будет хранить сведения о состоянии в виде полей. Но это плохо с точки зрения инкапсуляции. 
		Инкапсуляция данных означает, что поля типа ни в коем случае не следует открывать для общего доступа, так как в этом случае слишком просто написать код, 
		способный испортить сведения о состояния объекта путем ненадлежачего применения полей. 
		Есть и другие причины для инкапсуляции доступа к полям данных типа. Допустим, нам нужен доступ к полю, чтобы что-то сделать, 
		разместить в кэше некоторое значение или создать какой-то внутренний объект, создание которого было отложено, причем обращение к полю 
		не должно нарушать безопасность потоков. Или скажем поле является логическим и его значение предоставлено не байтами в памяти, а вычисляется по некоторому алгоритму.
	1.2) Эти причины заставляют при разработке типов, помечать поля как приватные  давать пользователю вашего типа возможность получения и задания сведений о состоянии через специальные методы, 
		предназначенные исключетельно для этого. Метода выполняющие функции оболочки для доступа к полю, обычно называются аксессорами (accessor). 
		Аксессоры могут выполнять дополнительную "зачистку", гарантируя, что сведения о состоянии объекта никогда на будут искажены. 
	1.3) Можно написать доп методы GetXxx, SetXxx. Но это длинный код + вместо простой ссылки на имя поля пользователям типа приходится вызывать соответствующие методы
		По мнению Рихтера эти недостатки незначительны, я с ним несогласен, потому что код станет просто огромным. 
		CLR поддерживает механизм свойств, частично компенсирующий недостаток длинного кода и полностью устраняющий недостаток получения полей с помощью методов

	1.4) Можно считать свойства умными полями, то есть полями с дополнительной логикой. CLR поддерживает статические, экземплярные, абстрактные и виртуальные свойства. 
		Кроме того, свойства могут помечаться модификатором доступа и определяться в интерфейсах
		У каждого свойства есть имя и тип (но не void). Нельзя перегружать свойства (то есть определять несколько свойств с одинавыми именами, но различным типом)
		Определяя свойство, обычно описывают пару методов: get и set. 
		Однако опустив методв set, можно определить совйство, доступное только для чтения, а оставив только метод get, мы получим свойство, доступное только для записи
		Методы get и set свойства довольно часто манипулируют закрытым полем, определенным в типе. Это поле обычно называется вспомогательным (backing field)
		Однако методами get и set не приходится обращаться к вспомогатоельному полю. Например, тип System.Threading.Thread поддерживает свойство Priority, взаимодействующее непосредетсвенно с ОС, 
		а объект Thread не поддерживает поле, хранящее приоритете потока. Другой пример свойств, не имеющих вспомогательных полей - это неизменяемые свойства, вычисляемые при выполнении: длина массива, 
		заканчивающегося нулем, или область прямоугольника, заданного шириной и высотой и т.д.

	1.5) При определении свойства компилятор генерирует и помещает в результирующий управляемый модуль следующее:
		1) метод get свойства генирируется, только если для свойства определен аксессор get;
		2) метод set свойства генерируется, только если для свойства определен аксессор set;
		3) определение свойства в метаданных управляемого модуля генерируется всегда

	1.6) Обнаружив код, пытающийся получить или задать свойство, компилятор генерирует вызов соответствующего метода. 
		Если используемый язык не поддерживает свойства напрямую, к ним все равно можно обратиться посредством вызова нужного аксессора. Эффект тот же, только исходный текст выглядит менее изящно.
		Помимо аксессоров, для каждого из свойств, компиляторы генерят в метаданных управляемого модуля запись с определением свойства. Такая запись содержит несколько флагов и тип свойства,
		а также ссылки на аксессоры get и set. Эта информация существует лишь затем, чтобы провести связь между абстрактным понятием свойства и его методами доступа. 
		Компиляторы и другие инструменты могут использовать эти метаданные через класс System.Reflection.PropertyInfo.
		И все же CLR не использует эти метаданные, требуя при выполнении только методы-аксессоры

2) Автоматически реализуемые свойства (Automatically Implemented Properties, AIP)
	2.1) Если необходимо создать свойства при инкапсуляции резервных полей, то в C# есть упрощенный синтаксис, называемый автоматически реализуемыми свойствами (Automatically Implemented Properties, AIP)
	2.2) если создать свойства без реализация методов get и set, то компилятор C# автоматически объявит их закрытыми полями. 
	2.3) Джеффри Рихтер считает, что стоит избегать автоматических свойств в силу нескольких причин:
		1) Синтаксис объявления поля может включать инициализацию, таким образом вы объявляете и инициализируете поле в одной строке кода. Однако нет подходящего синтаусиа для установки при помощи
			при помощи AIP начального значения. Следовательно, необходимо неявно инициализировать все автоматически реализуемые свойства по всех конструкторах 
		2) Механизм сериализации на этапе выполнения сохраняет имя поля в сериализованном потоке. Имя возвращаемого поля для AIP определяется компилятором, и он может менять это имя каждый раз когда компилирует код, 
			сводя на нет возможность менять это имя каждый раз, когда компилирует кода, сводя на нет возможность десериализации экземпляров всех типов, содержащих автоматически реализуемые свойства.
			Не используйте этот механизм для всех типов, подлежащих сериализации и десериализации.
		3) Во время отладки нельзя указать точку останова в AIP-методах get и set, можно только узнать, когда приложение получит и задаст значение автоматически реализуемого свойства. 
			Точки останова можно устанавливать только в тех свойствах, которые программист пишет самостоятельно. 

	2.4) При использование AIP свойства должны иметь уровень доступа для чтения и записи, так как компилятор генерирует методы get и set. Это разумно, посколько поля для чтения и записи бесполезны без возможности чтения их значения.

3) Осторожный подход к определению свойств
	3.1) Джеффри Рихтеру не нравятся свойства. Он считает, что столкнувшись с кодом, обращающимся с полем, разработчик привычно предполагает наличие массы условий, которые далеко не всегда 
		соблюдаются, если речь идет о свойстве
		1) Свойства могут быть доступны только для чтения или только для записи, в то время как поля всегда доступны и для чтения и для записи. 
			Определяя свойство, лучше всего создавать для него оба аксессора (get и set)
		2) Свойство, являясь по сути методом, может привести к исключению, а при доступе к полям исключений не бывает
		3) Свойства нельзя передавать в метод в качестве параметров с ключевым словом ref или out.
		4) Свойство-метод может выполняться довольно долго, в то время как доступ к полям выполняется моментально. Часто свойства применяют для синхронизации потоков, но это может привести к приостановке потока на
			неопределенное время, поэтому свойства не следует использовать для этих целей - в такой ситуации лучше задействовать метод. Кроме этого, если предусмотрен удаленный доступ к классу (например, если он наследует
			от System.MarshalByRefObject), вызов свойства-метода выполняется очень медленно, поэтому предпочтение следует отдать методу. 
		5) При нескольких вызовах подряд свойство-метод может возвращать разные значения, а поле возвращает одно и то же значение. В классе System.DateTime есть неизменяемое свойство Now
			которое возвращает текущие дату и время. При каждом последующем вызове свойство возвращает новое значение. По мнению Рихтера это ошибка, по мне так, все логично, это полностью соответвует ожидамому поведению этого свойства
		6) Свойство-метод может порождать видимые сторонние эффекты, невозможные при доступе к полю. Иначе говоря, порядок определения значений различных свойств типа никак не должен влиять на поведения типа, однако в действительно часто бывает не так
		7) Свойству-методу может требоваться дополнительная память или ссылка на объект, не являющийся частью состояния объекта, поэтому изменение возвращаемого объекта никак не сказывается на исходном объекте; при запросе поля всегда 
			возвращается ссылка на объект, который гарантированно относится к состоянию исходного объекта. Свойство, возвращающее копию - источник путаницы для разработчиков, причем об этом часто забывают упомянуть в документации
		
4) Инициализаторы объектов и коллекций
	4.1) Можно очень удобно инициализировать свойства и коллекции
	Например: 
		1) new Emp1oyee () { Name = "Jeff", Age = 45 }
		   new Employee { Name = "Jeff", Age = 45}
		2) Classroom classroom = new Classromm { Students = { "Jeff", "Kristin", "Grant" } }
		   Этот код развернется компилятором, как простые методы Add к свойству Students экземплярного объекта classroom
		   Если тип свойства реализует IEnumerable, но не предлагает метод Add, то компилятор не разрешит использовать синтаксис инициализации коллекции
		   для добавления элементов в коллекцию, будет ошибка CS0117: System.Collections.Generic.IEnumerable не содержит определения дял Add

		   некоторые методы имеют разные сигнатуры для Add, вот пример как сделать инициализацию для Dictionary:
		   var table = new Dictionary<String, Int32> 
		   { {"2", 1}, {"2", 2} }

5) Анонимные типы
	Механизм анаонимных типов в C# позволяет автоматически объявить кортежный тип при помощи простого синтаксиса
	Кортежный тип (tuple type) - это тип, который содержит коллекцию свойств, относящихся друг к другу сходным образом. 
	Когда мы создаем анонимный тип, компилятор делает вывод о типе каждого выражения, создает закрытые поля этих типов, для каждого типа поля создает открытые свойства
	только для чтения путем вычисления результирующих значений. В дополнение к этому, компилятор переопределяет методы Equals, GetHashCode и ToString объекта
	и генерирует код внутри всех этих методов. 
	5.1) Класс, создаваемый компилятором выглядит следуюшим образом:
	```
	[CompilerGenerated] 
	internal sealed class <>f __ AnonymousType0<...>: Object { 
	private readonly tl fl : 
	public tl pl { get { return fl; } } 
	pri vate readonly tn fn ; 
	puЬliс tn pn { get { return fn ; } } 
	puЬlic <>f_AnonymousType0<...>(tl al ..... tn an) { 
	fl = a l ; ... ; fn = an ; // Назначает все поля 
	} 
	puЬlic override Boolean Equals(Object value) { 
	// Возвращает fal se. если поля не сопоставлены ; иначе возвращает true 
	puЬlic override Int32 GetHashCode() { }
	// Возвращает хэш-код . сгенерированный из хэш-кодов каждого поля 
	puЬlic override String ToString ( )  { }
	// Возвращает пары " name = value", разделенные точками 
	}
	```

	5.2) Компилятр очень разумно выясняет анонимный тип. Если компилятор видит, что вы определили множество анонимный типов с идентичными структурами, то он создает 
		одно определение для анонимного типа и множество экземпляров этого типа.
		
	5.3) Анонимные типы обычнно используются с технологией языка интегрированных запросов (Language Integrated Query, LINQ), когда запросы записывают результаты в коллекции объектов анонимного типа. 
	5.4) Экземпляры анонимного типа не предполагают своего распространения за пределы одного метода. 

6) Тип System.Tuple
	6.1) Тип Tuple создается один раз и остается неизменным (все свойства только для чтения)
	6.2) Очень важно, чтобы и производитель и потребитель типа Tuple имели ясное представление о том, что будет возвращаться в свойствах Item
	6.3) System. Dyпamic.ExpandoObject

7) Свойства с параметрами
	7.1) До этого рассматривались аксессоры без параметров (parameterless properties). Они проще, так как их использование напоминает обращение к полю. 
	7.2) Также есть свойства с параметрами (parameterful properties). У таких свойств аксессоры get принимают один или несколько параметровю 
	7.3) В C# свойства с параметрами называются индексаторы. В C# синтаксис поддержки индексаторов напоминает синтаксис массивов. 
		Иначе говоря можно представить индекасатор как средство, позволяющее разработчику на C# перегружать оператор [].
	7.4) Аттрибут IndexerName
	7.5) csc не допускает создания разных индексаторов с одинаковой структорой, даже если пометить их разными именами с помощью IndexerName
		Поскольку в C# нельзя обратиться к индексатору по имени индексатора, а значит компилятор просто не будет знать к какому индексатору обращаются
		ошибка CS0111: в классе SomeType уже определен член this с таким же типом параметр

8) Выбор главного свойства с параметрами
	8.1) Возникает два вопроса:
		1) Что если язык, на котором написан тип, позволяет разработчику определить несколько свойств с параметрами?
		2) Как задействовать этот типа в программе на C#?
		Ответ: в этом типе надо выбрать один из методов среди индексаторов и сделать его свойством по умолчанию, применив к самому классу экземпляр
		System.Reflection.DefaultMemberAttribute
	8.2) Производительность при вызове методов-аксессоров свойств
		В случае простых методов досутпа get и set JIT компилятор подставляет (inlines) код кесессора внутрь когда вызываемого метода, поэтому характерного
		снижения производительности работы программы, проявляющегося при использовании свойств вместе полей, не наблюдается.
		Подстановка подразуемвает компиляцию кода метод (или, в данном случае, аксессора) непосредственно вместе с кодом вызывающего метода.
		Это избавляет от дополнительной нагрузки, связанной с вызовом во время выполнения, но за счет "распухания" кода скомпилированного кода.
		Поскольку асессоры свойств обычно содержат мало кода, их подстановка может приводить к сокращению общего объема машинного кода, а значит к повышению скорости выполнения.

	8.3) Доступность аксессоров свойств
		При проектировании может возникнуть необходимость назначить аксессорам get и set разный уровень доступа.
		Чаще всего применяют открытый аксессор get и закрытый set
		При определении для свойства аксессоров с различным уровнем доступа csc требут, чтобы само свойство было объявлено 
		с наименее строгим  уровнем доступа, а более строгое ограничение было наложено только на один из методов доступа

	8.4) Обобщенные методы-аксессоры свойств
		Поскольку свойства являются методами, а C# и CLR поддерживают обобщение методов, некоторые разработчики пытаются 
		определить обобщенные методы-аксессоры свойств. Однако C# этого не позволяет делать.
		Главная причина в том, что обобщенные свойства лишены смысла с концептуальной точки зрения. Предпологается, что свойство
		представляет характеристику объекта, которую можно извлечь или определить. Добавление обобщенного параметра типа означало бы, что поведение операции извлечения/определения может меняться, но 
		в принипе, от свойства не ожидается никакого поведения.
		Если нужно задать какое-либо поведение объекта - обобщенное или нет, нужно создать методе, а не свойство.