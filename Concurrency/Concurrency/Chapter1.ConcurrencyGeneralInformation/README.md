# Конкрентность: общие сведения

**Конкурентность** - выполнение сразу нескольких действий в одно и то же время

**Примеры**: UI реагирует на ввода данных пользователем во время записи в БД. Серверные приложения
используют конкуретность для реакции на второй запрос в ходе завершения первого запроса.

**Многопоточность** - форма конкуретности, использующая несколько программных потоков выполнения

Непосредственное использование низкоуровневых видов многопточности в соврременных приложениях
практически не имеет смысла; высокоуровенвые абстракции превосходят многопоточные средства старой
школы как по мощи, так и по эффективности. Поэтому ни в одном из рецептов этой книги не используются
типы **Thread** или **BackgroundWorker**.

Многопоточность продолжает жить в **пулах потоков** - полезном месте для постановки рабочих операций
в очередь, которое автоматически регулируется в зависимости от нагрузки.

**Параллельность** - выполнение большого объема работы за счет распределения ее между несколькими
потоками, выполняемыми одновременно.

Параллельная обработка (или параллельное программирование) использует 
многопоточность для максимально эффективного использования многоядерных процессоров

Параллельная обработка является одной из разновидностей многопоточности, а многопоточность является 
одной из разновидностей конкурентности.

**Асинхронность** - разновидность конкурентности, использующая обещания или обратные вызовы для 
предотвращения создания лишних потоков.

**Обещание (future/promise), или преднамеченный тип** - тип представляющий некоторую операцию, которая
завершится в будущем. Примеры современных типов обещаний в .NET - Task и Task<TResult>. Более старые
асинхронные API используют обратные вызовы или события вместо обещаний.

А асинхронном программировании центральное место занимается идея **асинхронной операции** - некоторой 
запущенной операции, которая завершится через некоторое время. ХОтя операция продолжается, она не блокирует
основной поток; поток который запустил операцию, свободен для выполнения другой работы. Когда операция
завершится, она уведомляет свое обещание или активизирует обратный вызов или событие, чтобы приложение
узнало о завершении.

**Реактивное программирование** - декларативный стиль программирования, при котором приложение
реагирует на события.

**Реактивное программирование** - еще одна форма конкурентности. Асинхронность подразумевает, что 
приложение запускает операцию, которая завершится в будущем. Реактивное программирование тесно связано 
с асинхронным программированием, но в его основе лежат асинхронные события вместо асинхронных операций.
Асинхронные события согут не иметь фактического "начала", могут происходить в любое время и могут
инициироваться многократно. Один из примеров такого рода - ввода данных пользователем.

Если рассматривать приложение как огромный конечный автомат, поведение приложения может быть описано 
как реакция на серию событий с обновлением своего состояния на каждое событие. Реактивное программирование
не обязательно конкурентно, но оно тесно связано с конкуретностью.

## Введение в асинхронное программирование

Преимущества асинхронного программирования:

1. Для GUI - быстрый отклик. Асинхронное программирование освобождает UI-поток; 
это позволяет графическому приложению сохранить высокую скорость 
отклика на ввод пользователя

2. Для серверных приложений - возможность масштабируемости. Асинхронность освобождает потоки запросов 
и позволет серверу использовать свои потоки для обслуживания большего количества запросов.

**Ключевое слово async** добавляется в объявлении метода и имеет двойное назначение: оно разрешает
использование ключевого слова await внутри этого метода и приказывает компилятору сгенерировать для 
этого метода конечный автомат по аналогии с тем, как работает yield return. Метод с ключевым словом async
может вернуть Task<TResult>, Task, IAsyncEnumerator<T> или IAsyncEnumerable<T>.

**Рассмотрим пример**

```
async Task DoSomethingAsync()
{
	int value = 13;

	// Асинхронно ожидать 1 секунду.
	await Task.Delay(TimeSpan.FromSeconds(1));
	
	value *= 2;

	// Асинхронно ожидать 1 секунду.
	await Task.Delay(TimeSpan.FromSeconds(1));
	Trace.WriteLine(value);
}
```

async метод начинает выполняться синхронно. Внутри метода команда await выполняет асинхронное ожидание 
по своему аргументу. Сначала она проверяет, завершилась ли операций: если да, то метода продолжает
выполняться (синхронно). В противном случае await приостанавливает async метода и возвращает 
незавершенную задачу. Когда операция завершится позднее, async-метода продолжает выполнение.

async-метод может рассматриваться как состоящий из нескольких синхронных частей, разделенных 
командами await. Первая синхронная часть выполняется в потоке, который вызвал метод, но где 
выполняются другие синхронные части? Ответ на этот вопрос не прост.

При выполнении await для задачи (самый распространенный сценарий) 
в момент, когда await решает приостановить метод, сохраняется контекст. 
Это текущий объект SynchronizationContext, если только он не равен 
null (в этом случае контекстом является текущий объект TaskScheduler). 
Метод возобновляет выполнение в этом сохраненном контексте. Обычно 
контекстом является UI-контекст (для UI-потока) или контекст пула 
потоков (в большинстве других ситуаций). Если вы пишете приложение 
ASP.NET Classic (до Core), то контекстом также может быть контекст 
запроса ASP.NET. В ASP.NET Core используется контекст пула потоков 
вместо специального контекста запроса.

Таким образом, в приведенном коде все синхронные части пытаются 
возобновить продолжение в исходном контексте. Если вызвать метод 
DoSomethingAsync из UI-потока, каждая из его синхронных частей будет 
выполняться в этом UI-потоке, но если вызвать его из потока из пула 
потоков, то каждая из синхронных частей будет выполняться в любом 
потоке из пула потоков.

### ConfigureAwait

Чтобы обойти это поведение по умолчанию, можно выполнить await по 
результату метода расширения ConfigureAwait с передачей false в параметре 
continueOnCapturedContext:

```await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false);```

Ключевое слово await не ограничивается работой с задачами, оно может 
работать с любым объектом, допускающим ожидание (awaitable), построенным 
по определенной схеме. Например, библиотека Base Class Library 
включает тип ValueTask<T>, который сокращает затраты памяти, если 
результат в основном является синхронным; например, если результат 
может быть прочитан из кэша в памяти. Тип ValueTask<T> не преобразуется 
в Task<T> напрямую, но строится по схеме, допускающей ожидание, поэтому 
может использоваться с await. Также существуют другие примеры, 
и вы можете строить свои собственные, но в большинстве случаев await
получает Task или Task<TResult>.

### Создание Task

Существует два основных способа создания экземпляров Task. Некоторые 
задачи представляют реальный код, который должен выполняться процессором; 
такие вычислительные задачи должны создаваться вызовом Task.
Run (или TaskFactory.StartNew, если они должны выполняться по определенному расписанию). 
Другие задачи представляют уведомления; такие 
задачи, основанные на событиях, создаются TaskCompletionSource<TResult>
(или одной из сокращенных форм). Большинство задач ввода/вывода 
использует TaskCompletionSource<TResult>.

### Обработка ошибок

```
async Task TrySomethingAsync()
{
	try
	{
		await PossibleExceptionAsync();
	}
	catch (NotSupportedException ex)
	{
		LogException(ex);
		throw;
	}
}
```

Метод PossibleExceptionAsync может выдать исключение NotSupportedException, но TrySomethingAsync 
может перехватить исключение естественным образом. Трассировка стека перехваченного исключения сохраняется
без исскуственной упаковки в TargetInvocationException или AggregateException.

Когда async-метод выдает (или распространяет) исключение, оно помещается в возвращаемый объект 
Task, и задача Task завершается. При 
выполнении await для этого объекта Task оператор await получает это 
исключение и (заново) выдает его так, что исходная трассировка стека 
сохраняется. Такой код, как в примере ниже, будет работать так, как ожидается, если
PossibleExceptionAsync является async-методом.

```
async Task TrySomethingAsync()
{
	// Исключение попадает в Task, а не выдается напрямую.
	Task task = PossibleExceptionAsync();
	
	try
	{
		// Исключение из Task exception будет выдано здесь, в точке await.
		await task;
	}
	catch (NotSupportedException ex)
	{
		LogException(ex);
		throw;
	}
}
```

## Борьба с Task.Wait, Task<TResult>.Result, GetAwaiter().GetResult()

Относительно async-методов существует одна важная рекомендация: 
при использовании ключевого слова async лучше позволить ему распространяться в вашем коде. 
Если вы вызываете async-метод, следует 
(в конечном итоге) выполнить await для возвращаемой им задачи. 
Боритесь с искушением вызвать Task.Wait, Task<TResult>.Result или 
GetAwaiter().GetResult(): это приведет к взаимоблокировке (deadlock). 

**Рассмотрим следующий метод:**

```
async Task WaitAsync()
{
	// await сохранит текущий контекст ...
	await Task.Delay(TimeSpan.FromSeconds(1));
	// ... и попытается возобновить метод в этой точке с этим контекстом.
}

void Deadlock()
{
	// Начать задержку.
	Task task = WaitAsync();
	// Синхронное блокирование с ожиданием завершения async-метода.
	task.Wait();
}
```

Код в этом примере создат взаимоблокировку при вызове из UI-контекста или контекста ASP.NET Classic, потому
что оба эти контекста допускают выполнение только одного потока. Deadlock вызовет WaitAsync, что приводит
к началу задержки. Затем Deadlock (синхронно) ожидает завершения этого метода с блокированием контекстного
потока. Когда задержка завершится, await пытается возобновить WaitAsync в сохранненом контексте, но не 
сможет, так как в контексте уже есть заблокированный поток, а контекст допускает только один поток в 
любой момент времени. 

Взаимоблокировку можно предотвратить двумя способами: использовать ConfigureAwait(false) в WaitAsync 
(что заставляет await игнорировать его контекст) или же использовать await с вызовом WaitAsync 
(что превращает Deadlock в async-метод)

## Введение в параллельное программирование

Везде, где можно разделить серьезный объем вычислительной информации на независимые блоки.

Это полезно для клиентских приложений, но в серверных приложениях обычно неуместно.

У большинства серверов присутствуют некоторые встроенные функции параллелизма; например, ASP.NET 
обрабатывает несколько запросов паралелльно. Написание паралелльного кода на сервере может приносить пользу
в некоторых ситуациях (если вам известно, что количество одновременных пользователей будет низким), но,
как правило, параллельное программирование на сервере будет конфликтовать со встроенными параллельными
средствами и не принесет никакой реальной пользы.

Есть две форма параллельного программирования: *параллелизм данных* и *параллелизм задач*.

Параллелизм данных возникает тогда, когда имеется 
набор элементов данных, ожидающих обработки, и обработка каждого 
фрагмента данных в основном не зависит от других фрагментов. Под 
параллелизмом задач понимается такая ситуация, в которой имеется некоторый пул 
работы, где каждый фрагмент работы в основном не зависит 
от остальных. Параллелизм задач может быть динамическим — если один 
фрагмент работы порождает несколько дополнительных фрагментов 
работы, они могут быть добавлены в пул работы

### Известно несколько подхдодов для реализации параллелизма данных

Метод *Parallel.ForEach* является аналогом foreach. For - аналог цикла for и может использоваться, если
обработка данных зависит от индекса.

```
void RotateMatrices(IEnumerable<Matrix> matrices, float degrees)
{
	Parallel.ForEach(matrices, matrix => matrix.Rotate(degrees));
}
```

Другой вариант - Parallel LINQ (PLINQ). **Parallel более эффективно использует ресурсы, чем PLINQ.**

Parallel лучше сосуществует с другими процессами в системе, тогда как PLINQ (по умолчанию) будет пытаться
распространиться по всем процессорам. 

К недостаткам Parallel следует 
отнести то, что он требует более явной реализации; PLINQ во многих 
случаях позволяет писать более элегантный код.

```
IEnumerable<bool> PrimalityTest(IEnumerable<int> values)
{
	return values.AsParallel().Select(value => IsPrime(value));
}
```

**Давайте рассмотрим параллелизм задач**

Параллелизм данных ориентирован на обработку данных, а параллелизм задач — на выполнение работы. 
На высоком уровне между параллелизмом данных и параллелизмом задач есть много общего; 
«обработка данных» может рассматриваться как 
разновидность «работы». Многие задачи параллелизма могут решаться 
любым из этих способов; используйте тот API, который покажется вам 
более естественным для текущей задачи

Parallel.Invoke - одна из разновидностей метода Parallel, которая реализует разновидность 
параллелизма задач типа «ветвление/объединение»

```
void ProcessArray(double[] array)
{
	Parallel.Invoke(
	() => ProcessPartialArray(array, 0, array.Length / 2),
	() => ProcessPartialArray(array, array.Length / 2, array.Length)
	);
}
void ProcessPartialArray(double[] array, int begin, int end)
{
	// Действия, интенсивно использующие процессор...
}
```

Код, использующий Task напрямую, сложнее кода, в котором используется Parallel, он и он может быть полезным,
если структура параллелизма неизвестна до стадии выполнения. С этой разновидностью динамического 
пареллелизма количество необходимых фрагментов работы неизвестно до начала обработки; это выясняется во 
время выполнения. В общем случае динамический фрагмент работы должен запускать все дочерние задачи, 
необходимые ему, а затем ожидать их завершения. У типа Task имеется специальный флаг TaskCreationOptions.AttachedToParent,
который может использоваться для этой цели.

При параллелизме задач следует ососбенно внимательно следить за переменными, сохраненными в 
**замыканиях**. Помните, что в замыканиях сохраняютс яссылки (а не значения), и это может привести к
неочевидным ситуациям с совместным использованием данных.

Обычно не приходится беспокоиться о том, что пул потоков организует выполнение работы. Параллелизм данных
и задач используют динамически регулируемые распределители (partinioners) для распределеиния работы
между рабочими потоками. Пул потоков увеличвает количество потоков по мере необходимости. Он имеет одну
рабочую очередь, и каждый поток из пула потоков использует собственную рабочую очередь. Когда поток из 
пула ставит в очередь дополнительную работу, то сначала отправлять ее в свою очередь, так как работа 
обычно связывается с текущим рабочим элементов (work item); такое поведение заставляет потоки 
заниматься своей собственной частью работы и максимизирует процент попадений в кэш. Если у другого потока
нет работы он забирает работу из очереди другого потока. Компания Microsoft потратила много сил на то, чтобы 
пул потоков по возможности работал эффективно; существует множество настроек, которые можно изменять для
достижения максимального быстродействия. Если ваши задачи не слишком малы, они должны хорошо работать с 
настройками по умолчанию.

**Задачи должны быть не слишком большими, и не слишком маленькими**

Если задачи получаются слишком короткими, то затраты ресурсов на разбиение данных на задачи и планирование
этих задач в пуле потоков начинает играть значительную роль.

Если задачи слишком длинные, то пул потоков не может динамически регулировать равномерное распределение 
работы.

## Введение в реактивное программирование (Rx)

Если вы не пожалеете времени и сил, реактивное программирование 
открывает исключительно мощные возможности. Реактивное программирование позволяет 
рассматривать поток событий как поток данных. Как 
правило, если событию передаются какие-либо аргументы, то в коде лучше 
использовать System.Reactive вместо обычного обработчика событий.

Реактивное программирование основано на концепции *наблюдаемых потоков* (observable streams)

Подписавшись на наблюдаемый поток, вы будете получать любое количество элементов данных (OnNext); поток
может завершиться одной ошибкой (OnError) или уведомлением "конец потока" (OnCompleted). Некоторые 
наблюдаемые потоки никогда не завершаются. Реальные интерфейсы выглядят так:

```
interface IObserver<in T>
{
	void OnNext(T item);
	void OnCompleted();
void OnError(Exception error);
}
interface IObservable<out T>
{
	IDisposable Subscribe(IObserver<TResult> observer);
}
```

Однако вам никогда не придется реализовать эти интерфейсы. Библиотека 
System.Reactive (Rx) компании Microsoft содержит все реализации, которые могут понадобиться. 
Код Reactive в конечном итоге очень похож на LINQ; его можно рассматривать как своего рода «LINQ to Events»
System.Reactive содержит все возможности LINQ, а также добавляет большое количество собственных операторов -
особенно предназначенных для работы со временем.


**Рассмотрим пример кода:**

```
Observable.Interval(TimeSpan.FromSeconds(1))
	.Timestamp()
	.Where(x => x.Value % 2 == 0)
	.Select(x => x.Timestamp)
	.Subscribe(x => Trace.WriteLine(x));
```

Пример кода начинается с запуска счетчика по периодическому таймеру (Interval) и добавления временной 
метки для каждого события (Timestamp). Затем события фильтруются так, чтобы выключались только четные
значения счетчика (Where), выбираются значения временной метки (Timestamp), после чего каждое
поступившее значение временной метки записывается в отладчик (Subscribe).

**Главное отличие заключается в том**, что LINQ to Objects и LINQ to Entities используют *модель 
вытягивания* (pull model), при которой перечисление запроса LINQ "вытягивает" данные из запроса,
тогда как LINQ to Events использует модель проталкивания (push model), при которой события поступают и 
перемещаются по запросу сами по себе.

Подписки ведут себя по-разному с холодными и горячими наблюдаемыми 
объектами. **Горячий (hot)** наблюдаемый объект представляет собой поток 
событий, который всегда находится в движении, и, если при появлении 
события нет ни одного подписчика, оно теряется. Например, перемещение 
мыши является горячим наблюдаемым событием. У **холодного (cold)** 
наблюдаемого объекта события не поступают постоянно. Холодный наблюдаемый 
объект реагирует на подписку, начиная последовательность 
событий. Например, загрузка HTTP является холодным наблюдаемым 
объектом; подписка инициирует отправку запроса HTTP.

## Введение в Dataflow

Библиотека TPL Dataflow — интересное сочетание асинхронных и параллельных 
технологий. Эта библиотека может быть полезной для последовательности 
процессов, которые должны применяться к вашим данным.

Базовым структурным элементом сети потока данных (dataflow mesh) 
является *блок потока данных* (dataflow block). Блок может быть 
блоком-приемником (получение данных), блоком-источником (производство 
данных) или их сочетанием. Блоки-источники могут связываться с 
блоками-приемниками для формирования сети.

Блоки являются полунезависимыми; они обрабатывают данные по мере поступления и передают результат дальше. 
В обычном способе использования TPL Dataflow вы создаете все блоки, устанавливаете связи между ними, а 
затем начинаете подавать данные с одного конца.

Данные после этого выходят с другого конца сами по себе. Еще 
раз уточню, что возможности потоков данных этим не ограничиваются; 
можно создавать связи и добавлять их в сеть в то время, когда по ним 
перемещаются данные, но это весьма нетривиальный сценарий.

Блоки-приемники содержат буферы для получаемых данных. Наличие буфера 
позволяет им получать новые элементы данных даже в том 
случае, если они еще не готовы к их обработке; это позволяет данным 
перемещаться по сети. Такая буферизация может создать проблемы 
в сценариях с ветвлением, в которых один блок-источник связывается 
с двумя блоками-приемниками. Если у блока-источника имеются данные 
для отправки по направлению потока, он начинает предлагать их своим 
связанным блокам по одному. По умолчанию первый блок-приемник 
просто получает данные и буферизует их, а второй блок-приемник эти 
данные никогда не получит. Проблема решается ограничением буферов 
блоков-приемников.

Если что-то пойдет не так, происходит отказ блока — например, если 
обрабатывающий делегат выдает исключение при обработке элемента 
данных. Когда в блоке происходит отказ, он перестает получать данные.
По умолчанию это не приводит к нарушению работоспособности всей 
сети, а позволяет перестроить эту часть сети или перенаправить данные. 
Тем не менее это нетривиальный сценарий; в большинстве случаев обычно нужно, 
чтобы отказы распространялись по связям к целевым блокам.

```
try
{
	var multiplyBlock = new TransformBlock<int, int>(item =>
	{
		if (item == 1)
			throw new InvalidOperationException("Blech.");
		return item * 2;
	});

	var subtractBlock = new TransformBlock<int, int>(item => item - 2);
	multiplyBlock.LinkTo(subtractBlock,
		new DataflowLinkOptions { PropagateCompletion = true });

	multiplyBlock.Post(1);
	subtractBlock.Completion.Wait();
}
catch (AggregateException exception)
{
	AggregateException ex = exception.Flatten();
	Trace.WriteLine(ex.InnerException);
}
```

### TPL Dataflow и Rx обладают разными возможностями

Наблюдаемые объекты Rx в общем случае лучше блоков потока данных
при выполнении любых операций, связанных с хронометражом.

Блоки потоков данных в общем случае лучше наблюдаемых объектов Rx при 
выполнении параллельной обработки.

На концептуальном уровне работа 
Rx напоминает настройку обратных вызовов: каждый шаг наблюдаемого 
объекта напрямую вызывает следующий шаг.

С другой стороны, каждый 
блок в сети потока данных практически независим от всех остальных блоков.

## Введение в многопточное программирование

У каждого приложения .NET имеется пул потоков. Пул потоков содержит 
набор рабочих потоков, готовых к выполнению любой работы, которая им 
будет назначена. Пул потоков отвечает за определение количества потоков, 
находящихся в пуле потоков в любой момент времени. Есть десятки 
настроек конфигурации, с которыми можно экспериментировать для 
изменения этого поведения, но я не рекомендую это делать; пул потоков 
был тщательно оптимизирован для большинства реальных ситуаций.

### Коллекции для конкуретных приложений

Существует пара разновидностей коллекций, которые могут принести 
пользу при конкурентном программировании: **конкурентные коллекции**
и **неизменяемые коллекции**

Конкурентные коллекции позволяют нескольким потокам обновлять их одновременно 
с обеспечением безопасности. Многие конкурентные коллекции используют снимки (snapshots) 
текущего состояния, чтобы один поток мог перечислять значения, пока другой может добавлять или 
удалять значения. Конкурентные коллекции обычно работают эффективнее простой защиты обычной 
коллекции с помощью блокировок (lock).

С неизменяемыми коллекциями дело обстоит иначе. Неизменяемая 
коллекция действительно не может изменяться; вместо этого для модификации 
неизменяемой коллекции создается новая коллекция, представляющая измененную коллекцию. 
Это может показаться ужасно неэффективным, но неизменяемые коллекции разделяют максимально 
возможный объем памяти между экземплярами коллекций, поэтому все 
не так плохо. Одно из достоинств неизменяемых коллекций заключается 
в том, что все их операции являются чистыми, поэтому они очень хорошо 
работают в сочетании с функциональным кодом

### Современная разработка

У многих современных технологий есть одно сходство: они функциональны по своей природе. 
В данном случае речь идет не о *функциональности* в том смысле, что «они делают то, что положено», 
а в смысле стиля программирования, основанного на композиции функций. И если вы возьмете 
на вооружение функциональный менталитет, ваши конкурентные архитектуры будут менее запутанными.

Одним из принципов функционального программирования является чистота (т. е. отсутствие побочных эффектов).
Каждый компонент решения получает некоторое значение(-я) на входе и выдает некоторое значение(-я) 
на выходе. Эти компоненты должны настолько, насколько это возможно, избегать зависимости этих 
компонентов от глобальных (или общих) переменных или обновления глобальных (или общих) структур данных.

Конечно, рано или поздно ваши вычисления должны на что-то повлиять, но код 
будет более элегантным, если вы сможете провести обработку в чистых 
блоках, а затем проводить обновления с *результатами*.

## Ключевые технологии

Асинхронное программирование было очень сложным до 2012 года, когда в .NET 4.5 (вместе с C# 5.0 и VB 2012)
появились ключевые слова async и await.

Библиотека Task Parallel Library (TPL) была представлена в .NET 4.0 с полной поддержкой как параллелизма данных,
так и параллелизма задач. В наши дни она доступна даже на платформах с меньшими ресурсами, включая 
мобильные телефоны. Библиотека TPL построена на базе .NET.

Команда разработчиков System.Reactive приложила немало усилий для 
поддержки максимального количества платформ. System.Reactive, как 
и async с await, предоставляет полезные возможности для любых типов 
приложений — как клиентских, так и серверных. Поддержка System.
Reactive доступна в пакете System.Reactive.

Библиотека TPL Dataflow официально распространяется в составе пакета 
NuGet для System.Threading.Tasks.Dataflow.

Многие конкурентные коллекции встроены в .NET; также существуют другие конкурентные коллекции, 
содержащиеся в пакете System.Threading.Channels. Неизменяемые коллекции доступны в пакете System.
Collections.Immutable.

