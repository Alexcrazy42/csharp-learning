# Глава 13. Планирование

Каждая часть должна выполняться в каком-то потоке. Планировщик
(scheduler) — объект, который решает, где должен выполняться тот или 
иной код.

В фреймворке .NET существует несколько разных типов планировщиков, 
которые по-разному используются параллельным кодом 
и кодом потоков данных.

Не рекомендуется задавать параметры планировщика, обычно настройки по умолчанию правильные.

Например, оператор await в асинхронном коде автоматически возобновит выполнение метода 
в том же контексте, если только вы не переопределите значение по умолчанию.

У реактивного кода тоже имеются разумные контексты по умолчанию для выдачи событий, хотя их можно
переопределить с помощью ObserveOn.

Если друго код должен выполняться в конкретном контексте (например, в контексте UI-потока или в контекснте
запроса ASP.NET), то рецепты этой главы помогут в планировании кода.


# 13.1. Планирование работы в пуле потоков

## Задача

Имеется фрагмент кода, который должен выполняться в потоке из пула потоков.

## Решение

Task.Run возвращает объект Task Или Task<T>, который может естественным образом потребляться асинхронным
или реактивным кодом.

## Пояснение

Task.Run идеально подходит для UI-приложений с продолжительной работой, которая не должна выполняться в UI-потоке.

Тем не менее не используйте Task.Run в ASP.NET если только вы не уверены в том, что делаете. В ASP.NET код обработки
запросов уже выполняется в потоке из пула потоков, так что перенесение его в другой поток из пула потоков обычно
нерационально.

Task.Run является фактической заменой для BackgroundWorker, Delegate.
BeginInvoke и ThreadPool.QueueUserWorkItem

Параллельный код и кодо потоков данных выполняется в пуле потоков по умолчанию, поэтому Task.Run не нужно использовать
с кодом, выполняемым Parallel, библиотекой TPL Dataflow или PLINQ.

Если вы применяете динамический параллелизм, используйте Task.
Factory.StartNew вместо Task.Run. Это необходимо из-за того, что у объекта 
Task, возвращаемого Task.Run, параметры по умолчанию настроены для 
асинхронного использования (т. е. для потребления в асинхронном или 
реактивном коде). Кроме того, он не поддерживает такие расширенные 
возможности, как задачи «родитель/потомок», типичные для динамического параллельного кода

# 13.2. Выполнение кода с помощью планировщика задач

## Задача

Есть несколько частей код, которые требуется выполнить определенным способом. Например, все части код
должны выполняться в UI-потоке или же в любой момент времени должно выполняться только определенное
количество частей.

В этом рецепте показано, как определить и сконструированить планироващик для этих частей кода. Применению
планировщика будут посвящены следующие 2 рецепта.

## Решение

Простейшая разновидность TaskScheduler - TaskScheduler.Default - ставит работу в очередь пула потоков. 

Можно сохранить конкретный контекста и позднее спланировать работу в этом контексте с помощью 
TaskScheduler.FromCurrentSynchronizationContext:

```
TaskScheduler scheduler = TaskScheduler.FromCurrentSynchronizationContext();
```

Этот код создает объект TaskScheduler, чтобы сохранить текущий объект SynchronizationContext и 
спланировать выполнение кода в этом контексте.

Тип SynchronizationContext представляет контекст планирования общего назначения. В фрейморке .NET предусмотрено
несколько разных контекстов; многие UI-фрейморвки предоставляют контекст SynchronizationContext, представляющий
UI-поток, а в ASP.NET до Core представлялся контекст SynchronizationContext, представляющий контекст запроса HTTP

ExclusiveScheduler выполняет только по одной задаче за раз и только 
в том случае, если в настоящее время никакие задачи не выполняются 
в ConcurrentScheduler:

```
var schedulerPair = new ConcurrentExclusiveSchedulerPair();
TaskScheduler concurrent = schedulerPair.ConcurrentScheduler;
TaskScheduler exclusive = schedulerPair.ExclusiveScheduler;
```

Одно из частых применений ConcurrentExclusiveSchedulerPair — простое 
использование ExclusiveScheduler, гарантирующее, что в любой момент 
времени будет выполняться только одна задача. Код, выполняемый 
в ExclusiveScheduler, будет выполняться в пуле потоков, но будет ограничен 
монопольным выполнением без всего остального кода с использованием экземпляра ExclusiveScheduler.

Также ConcurrentExclusiveSchedulerPair может выполняться в качестве 
регулирующего планировщика. Вы можете создать объект ConcurrentExclusiveSchedulerPair, 
который будет ограничивать собственный уровень 
параллелизма. В этом сценарии ExclusiveScheduler обычно не используется:

```
var schedulerPair = new ConcurrentExclusiveSchedulerPair(TaskScheduler.Default, maxConcurrencyLevel: 8);
TaskScheduler scheduler = schedulerPair.ConcurrentScheduler;
```

## Пояснение

# 13.3. Планирование параллельного кода

## Задача

Требуется управлять выполнением отдельных фрагментов в параллельном коде.

## Решение

Следующий код получает последовательность матриц. Он запускает несколько параллельных циклов и ограничивает общий
параллелизм всех циклов одновременно независимо от количества матриц в каждой последовательности:

```
void RotateMatrices(IEnumerable<IEnumerable<Matrix>> collections, 
 float degrees)
{
	var schedulerPair = new ConcurrentExclusiveSchedulerPair(TaskScheduler.Default, maxConcurrencyLevel: 8);

	TaskScheduler scheduler = schedulerPair.ConcurrentScheduler;
	
	ParallelOptions options = new ParallelOptions { TaskScheduler = 
	scheduler };

	Parallel.ForEach(collections, options,
		matrices => Parallel.ForEach(matrices, options,
		matrix => matrix.Rotate(degrees)));
}
```

## Пояснение

# 13.4. Синхронизация потоков данных с помощью планировщиков

## Задача

Требуется управлять выполнением отдельных фрагментов в коде потоков данных.

## Решение

## Пояснение



Task.Run, Task.Factory.StartNew, TaskScheduler, SynchronizationContext, ConcurrentExclusiveSchedulerPair,
ExclusiveScheduler