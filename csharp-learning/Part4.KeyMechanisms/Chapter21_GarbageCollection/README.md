# Глава 21. Автоматическое управление памятью (уборка мусора)

В этой главе рассказано о создании новых объектов управляемыми приложениями, 
о том, как управляемая куча распоряжается временем жизни этих объектов и как 
освобождается занятая ими память. Мы рассмотрим работу уборщика мусора 
общеязыковой среды CLR и проблемы, связанные с его производительностью. 
В конце главы речь пойдет о приемах проектирования приложений, эффективно 
использующих память.

## Управляемая куча

Любая программа использует ресурсы - файлы, буферы в памяти, пространство экрана, 
сетевые подключения, базы данных и т.п. В ООП каждый тип идентифицирует некий 
доступный этой программе ресурс. Чтобы им воспользоваться, должна быть выделена 
память для представления этого типа.
Для доступа к ресурсу вам нужно:

1. Выделить память для типа, представляющего ресурс
2. Инициализировать выделенную память, установив начальное состояние ресура и сделав
его пригодным к использованию. За установку начального состояния типа отвечает конструктор.
3. Использовать ресурс, обращаясь к членам его типа (при необходимости операция
может повторяться).
4. В рамках процедуры очистки уничтожить состояние ресурса
5. Освободить память. За этот этпа отвечает исключитель GC

Программисты, ответственные за управление памятью, хронически забывают освободить
память, ставшую ненужной, или пытаются использовать уже освобожденную память.

Если вы пишете код, безопасный по отношению к типам (без использования ключевого
слова C# unsafe), повреждение памяти в ваших приложениях невозможно. Утечки памяти
остаются возможными и возникают из-за того, что приложение хранит объекты в коллекции, 
но не удаляет их, когда они становятся ненужными.

Иногда очистка ресураса дложна выполняться как можно раньше, не дожидаясь вмешательства
уборщика мусора. В таких классах можно вызвать дополнительный метод (Dispose), чтобы
очистка была выполнена по вашему собственному расписанию. Как правило, типы, требующие
специальной очистки, используют низкоуровневые системные ресурсы - файлы, сокеты или
подключения к базе данных.

## Выделение ресурсов из управляемой кучи

В CLR память для всех ресурсов выделяется из так называемой управляемой кучи (managed
heap). При инициализации процесса CLR резервирует область адресного пространства 
под управляемую кучу, а также указатель, который Рихтер называет NextObjPtr.
Он определяет, где в куче будет выделена память для следующего обхекта, и изначально
указывает на базовый адрес этой зарезервированной области адресного пространства.

По мере заполнения области объектами CLR выделяет новые области памяти, вплоть до 
заполнения всего адресного пространства. Таким образом, память приложения ограничивается
виртуальным адресным пространством процесса. Для 32-разрядных процессов можно выделить
до 1.5 гигабайта памяти, а для 64-разрядных процессов - около 8 терабайт памяти.

При выполнении оператора new среда CLR:

1. Подсчитывает количество байтов, необходимых для размещения полей типа (и всех 
полей, унаследованных об базового типа)
2. прибавляет к полученному значению количество байт, необходимых для размещения
системных полей объекта. У каждого объекта есть пара таких полей: указатель на 
объект-тип и индекс блока синхронизации. В 32 разрядных приложениях для каждого
из этих полей требуется 32 бита, что увеличивает размер каждого объекта на 8 байт, а 
в 64 разрядных приложениях каждое поле занимает 64 бита, добавляя к каждому объекту
16 байт
3. Проверяет, хватает ли в зарезервированной области байтов на выделение памяти для
объекта (при необходимости передает память). Если в heap недостаточно места для объекта,
ему выделяется память, начиная с адреса, на который ссылается указатель NextObjPtr, а
занимаемые им байты обнуляются. Затем вызывается конструктор типа (передающий NextObjPtr
в качестве параметра this), и оператор new возвращает ссылку на объект. Перед
возвратом этого адреса NextObjPtr переходит на первый адрес после объета, указывая 
на адрес, по которому в куче будет помещен следующий объект.

![](images/just_init_heap.png)

Увеличение указателя выполняется почти мгновенно.
Во многих приложениях, объекты, выделяемые примерно в одно время, тесно связаны
друг с другом, к тому же часто к ним обращаются примерно в одно время. Так, обычно
сразу после объекта FileStream создается объект BinaryWriter. Затем приложение 
обращается к объекту BinaryWriter, внутренний код которого использует FileStream. 
В среде, поддерживающей уборку мусора, новые объекты располагаются в памяти
непрерывно, что повышает производительность за счет близкого расположения ссылок. 
В частности, это значит, что рабочий рабор процесса будет меньше, чем подобного 
приложения, работающего в неуправляемой среде. Также, скорее всего, все объекты, 
используемые в программе, уместятся в кэше процессора. Приложение сможет получать 
доступ к этим объетам очень быстро, тк процессор будет выполнять большинство своих 
операций без кэш-промахов, замедляющих доступ к оперативной памяти.

Итак, пока складывается впечатление, что управляемая куча обладает превосходными 
характеристиками быстродействия. И все же это описание предполагает, 
что память всегда бесконечна, а CLR всегда может выделить блок для нового объекта. 
Конечно, это не так, поэтому управляемой куче необходим механизм уничтожения 
объектов, которые перестали быть нужными приложению. Таким механизмом 
является уборка мусора (Garbage Collection, GC).

## Алгоритм уборки мусора

Для управления сроком жизни объетов в некоторых системах используется алгоритм 
подсчета ссылок. Например, он используется в модели Microsoft COM (Component
Object Model). В системах с подсчетом ссылок каждый объект в куче содержит внутреннее
поле с информацией о том, сколько "частей" программы в настоящее время использует
данный объект. Когда каждая часть переходит к точке кода, в которой объект 
становится недоступным, она уменьшает поле счетчика объекта. Когда значение
счетчика уменьшается до 0, объект удаляется из памяти. К сожалению, в системах с 
подсчетом ссылок возникают серьезные проблемы с циклическими ссылками. Объекты ссылаются
друг на друга несмотря на то, что на них уже никто другой не ссылается.

Из-за проблем с алгоритмами, основанными на подсчете ссылок, CLR использует алгоритм
отслеживания ссылок вместо этого алгоритма. Алгоритм отслеживания ссылок работает
только с переменными ссылочного типа, потому что эти переменные могут ссылаться на 
объекты в куче; переменные значимых типов просто содержат данные экземпляра значимого
типа. Все переменные ссылочных типов называеются корнями (roots).

### Очистка мусора происходит в несколько фаз: 
1. Остановка всех потоков в процессе
2. Маркировка
3. Сжатие (compacting phase)
4. Перенос ссылок на новые места

Когда среда CLR запускает уборку мусора, она сначала приостанавливает все программные
потоки в процессе. Тем самым предотвращается обращение к объектам и возможное изменение
состояния во время их анализа CLR. Затем CLR переходит к этапе уборку мусора, называемому
маркировкой (marking). CLR перебирает все объекты в куче, задавая биту в поле индекса
блока синхронизации значение 0. Это означает, что все эти объекты могут быть удалены.
Затем CLR проверяет все активные корни и объекты, на которые они ссылаются. Если корень
содержит null, CLR игнорирует его и переходит к следующему корню.

Если корень ссылается на объект, в поле индекса блока синхронизации устанавливается 
бит - это и есть признак маркировки объекта. После маркировки объекта CLR 
проверяет все корни в этом объекте и маркирует объекты, на которые они ссылаются.
Встретив уже маркированный объект, уборщик мусора устанавливается, чтобы избежать 
возникновения бесконечного цикла в случае циклических ссылок.

![](images/ref_in_heap.png)

После проверки всех корней куча содержит набор маркированных и немаркированных 
объектов. Маркированные объекты переживут уборку мусора, потому что 
на них ссылается хотя бы один объект; можно сказать, что они достижимы из кода 
приложения. Немаркированные объекты недостижимы, потому что в приложении 
не существует корня, через который приложение могло бы к ним обратиться.

Теперь, когда CLR знает, какие объекты должны остаться, а какие можно удалить, 
начинается следующая фаза уборки мусора, называемая сжатием (compacting 
phase). В этой фазе CLR перемещает вниз все «немусорные» объекты, чтобы 
они занимали смежный блок памяти. Перемещение имеет много преимуществ. 
Во-первых, оставшиеся объекты будут находиться поблизости друг от друга; это 
приводит к сокращению размера рабочего набора приложения, а следовательно, 
повышает производительность обращения к этим объектам в будущем. Во-вторых, 
свободное пространство тоже становится непрерывным, что позволяет освободить 
эту область адресного пространства. Наконец, сжатие позволяет избежать проблем 
фрагментации адресного пространства при использовании управляемой кучи.

После перемещения в памяти все ссылки на «выжившие» объекты из корней 
указывают на прежнее местонахождение объекта в памяти, а не на тот адрес, по 
которому объект был перемещен. Если возобновить выполнение потоков на этой 
стадии, потоки обратятся по старым адресам, что приведет к некорректному 
использованию памяти. Разумеется, этого допускать нельзя, поэтому в фазе сжатия 
CLR вычитает из каждого корня количество байт, на которое объект был сдвинут 
вниз в памяти. Тем самым гарантируется, что каждый корень будет ссылаться на тот 
же объект, что и прежде; просто сейчас этот объект оказался в другом месте памяти.

После сжатия памяти кучи в указатель NextObjPtr управляемой кучи заносится 
первый адрес за последним объектом, не являющимся мусором. По этому адресу 
следующий новый объект будет размещен в памяти. На рисунке показана управляемая 
куча после сжатия. После завершения фазы сжатия CLR возобновляет выполнение 
потоков приложения, а они обращаются к объектам так, словно никакой 
уборки мусора и не было.

![](images/heap_after_GC.png)

Если CLR не удается освободить память в результате уборки мусора, а в процессах 
не осталось адресного пространства для выделения нового сегмента, значит, 
свободная память процесса полностью исчерпана. В этом случае попытка выделения 
новой памяти оператором new приведен к выдаче исключения OutOfMemoryException.
Ваше приложение может перехватить это исключение и восстановиться после 
него, но большинство приложений не пытается это делать; вместо этого исключение 
превращается в необработанное, Windows завершает процесс, а затем освобождает 
всю память, использованную процессом.

Программист должен извлечь для себя несколько важных уроков из этого описания. Во-первых, исключается утечка объектов, так как все объекты, недоступные 
от корней приложения, рано или поздно уничтожает уборщик мусора. Во-вторых, 
благодаря уборке мусора невозможно получить доступ к освобожденному объекту 
с последующим повреждением памяти.

### ВНИМАНИЕ
Статическое поле типа хранит объект, на которые ссылается, бессрочно или до выгрузки
домена приложений с загруженными типами. Чаще всего утечка памяти возникает из-за
хранения в статическом поле ссылки на коллекцию, в которую добавляются элементы. 
Статическое поле сохраняет объект коллекции, которая, в свою очередь, сохраняет все
свои элементы. Поэтому статических полей следут по возможности избегать.


## Уборка мусора и отладка

Как только объект становится недостижимым, он превращается в кандидата на удаление - 
объекты далеко не всегда "доживают" до завершения работы метода. Для приложения эта
особенность может иметь интересные последствия.

В представленном примере с Timer, если выполнить код без каких либо сторонних инструментов
IDE, то метод будет выполнен всего один раз, тк мы принудительно запустили сборку 
мусора.

Но если мы используем отладчик, то тут уже включится в ход решение, предложенное 
специалистами Microsoft:
при компиляции сборки с ключом /debug компилятора C# компилятор применяет к полученной
сборке атрибут System.Diagnostics.DebuggableAttribute с установленным флагом 
DisableOptimizations. При компиляции метода во время выполнения JIT-компилятор 
видит, что этот атрибут задан, и искуственно продлевает время жизни всех корней до 
завершения метода. В этом примере JIT-компилятор считает, что переменная t должна
существовать до конца метода. Таким образом, если происходит уборка мусора, уборщик
теперь считает, что t остается корнем, а объект Timer, на который ссылается t
по-прежнему достижим. Объект Timer переживает уборку мусора, а метод TimerCallback
будет вызываться многократно вплоть до выхода из Main.

JIT-компилятор делает это, чтобы помочь вам в процессе отладки. Теперь можно 
запустить приложение в обычном режиме (без отладчика), и если метод будет 
вызван, JIT-компилятор искусственно увеличит время жизни переменных до его 
окончания. Затем, если к процессу будет добавлен отладчик, можно вставить точку 
останова в ранее скомпилированный метод и изучить переменные.

перь вы знаете, как создать программу, которая работает в отладочном варианте, 
но не работает должным образом в готовой версии. Но программа, корректно 
работающая только в режиме отладки, бесполезна. Поэтому необходимо средство, 
обеспечивающее работу программы независимо от типа ее сборки.

Можно попробовать изменить метод Main следующим образом:
```
public static void Main() {
	// Создание объекта Timer, вызывающего метод TimerCallback каждые 2000 мс
	Timer t = new Timer(TimerCallback, null, 0, 2000);

	// Ждем, когда пользователь нажмет Enter
	Console.ReadLine();

	// Создаем ссылку на t после ReadLine
	// (в ходе оптимизации эта строка удаляется)
	t = null;
}
```

Все равно после компиляции этого кода (без параметра /debug+) и запуска полученного исполняемого файла (без отладчика) выяснится, что метод Timer_Callback
вызывается всего раз. Дело здесь в том, что JIT-компилятор является оптимизирующим, а приравнивание локальной переменной или переменной-параметра к null
равнозначно отсутствию ссылки на эту переменную. Иначе говоря, JIT-компилятор 
в ходе оптимизации полностью убирает строку t = null; из программы, из-за 
этого она работает не так, как хотелось бы. Вот как правильно следовало изменить 
метод Main:

```
public static void Main() {
	// Создание объекта Timer, вызывающего метод TimerCallback каждые 2000 мс
	Timer t = new Timer(TimerCallback, null, 0, 2000);

	// Ждем, когда пользователь нажмет Enter
	Console.ReadLine();

	// Создаем ссылку на переменную t после ReadLine
	// (t не удаляется уборщиком мусора
	// до возвращения управления методом Dispose)
	t.Dispose();
}
```

Теперь, скомпилировав этот код (без параметра /debug+) и запустив полученный 
исполняемый файл (без отладчика), вы увидите, что метод TimerCallback вызывается
несколько раз, и программа работает корректно. Это объясняется тем, что 
объект, на который ссылается переменная t, не должен удаляться, чтобы для него 
можно было вызвать метод Dispose (значение t нужно передать методу Dispose
как аргумент this). Парадокс: явно указывая, в каком месте таймер должен быть 
уничтожен, мы продлеваем его жизнь до этой точки.

### Примечание

После всего сказанного не стоит преждевременно беспокоиться о том, что ваши
собственные объекты могут быть уничтожены раньше времени. Класс Timer использовался 
в обсуждении только из-за своего специфического отсутствующего
у других классов поведения. Дело в том, что присутствие в куче объекта Timer 
приводит к периодическому вызову метода. Другие типы не в состоянии так себя вести. 
К примеру, наличие в памяти объекта String не имеет никаких последствий. Строка
просто находится в куче. Именно поэтому, чтобы продемонстрировать, как работают
корни и как время жизни объекта связано с отладчиком, я использовал объект Timer. 
Но при этом основной вопрос состоял не в том, как растянуть время жизни объекта. 
Время жизни остальных объектов определяется приложением автоматически.

## Поколения

Уборщик мусора с поддержкой поколений, который также называют эфемерным уборщиком 
мусора, работает на основе следующий предположений:

1. чем младше объект, тем короче его время жизни
2. чем старше объект, тем длиннее его время жизни
3. уборка мусора в части кучи выполняется быстрее, чем во всей куче

Сразу после инициализации в управляемой куче нет объектов. Говорят, что 
создаваемые в куче объекты составляют поколение 0. Проще говоря, к нулевому 
поколению относятся только что созданные объекты, которых не касался уборщик 
мусора

При инициализации CLR выбирает пороговый размер для поколения 0. Если 
в результате выделения памяти для нового объекта размер поколения 0 превышает 
пороговое значение, должна начаться уборка мусора. Объекты, пережившие 
уборку мусора, становятся поколением 1. Объекты из поколения 1 были 
проверены уборщиком мусора один раз. 
После уборки мусора объектов в поколении 0 не остается. Туда помещаются 
новые объекты. Приложение продолжает работу и размещает 
новые объекты. Также в ходе работы приложения становятся недоступными объекты, 
поэтому занятая ими память должна рано или поздно освободиться.

Если при попытке разместить новый объект размер поколения 0 превысил пороговое
значение, должна начаться уборка мусора. При этом уборщик мусора решает, какие
поколения следует обработать. CLR помимо выборп порогового значения поколения 0, 
также выбирает пороговый размер для поколения 1.
Начиная уборку мусора, уборщик определяет, сколько памяти занято поколением 1. ДОпустим, 
пока поколение 1 занимает намного меньше отведенной памяти, поэтому уборщик проверяет
только объект поколения 0.

Ясно, что игнорирование объектов поколения 1 повышает быстродействие уборщика. Однако
его производительность растет еще больше благодаря выборочной проверки объектов в heap.
Если корень или объект ссылается на объект из старшего поколения, уборщик игнорирует 
все внутренние ссылки старшего объекта, сокращая время построения графа доступных 
объектов. Конечно, возможна ситуация, когда старый объект ссылается на новый. Чтобы
не пропустить обновленные поля этих старых объетов, уборщик использует внутренний 
механизм JIT-компилятора, устанавливающий флаг при изменении ссылочного поля 
объекта. Он позволяет уборщику выяснить, какие из старых объектов (если они есть)
были изменены с момента последней уборки мусора. Остается проверять только старые
объекты с измененными полями, чтобы выяснить, не ссылаются ли они на новые объекты
из поколения 0.

Уборщик мусора с поддержкой поколений, предполагает, что если объект сейчас в 1 поколении,
то он будет жить и дальше, поэтому особо нет смысла проводить сборку мусора в 1 
поколении, потому что там можно высвободить мало памяти. 

Начинается проверка 1 поколения только когда оно превышает пороговое значение.
Управляемая куча поддерживает только три поколения: 0, 1 и 2.

Если уборщик видит, что после уборки мусора в поколении 0 остается очень мало 
выживших объектов, он может снизить порог для поколения 0. В этом случае уборка 
мусора будет выполняться чаще, но это меньше загрузит уборщик, поэтому рабочий 
набор процесса останется небольшим. В сущности, если все объекты поколения 0 
станут мусором, уборщику не придется даже дефрагментировать память — достаточно будет вернуть указатель NextObjPtr в начало поколения 0, чтобы посчитать 
уборку мусора законченной. Замечательный способ освобождения памяти!

В то же время, если после обработки поколения 0 уборщик мусора обнаруживает 
множество выживших объектов, значит, удается освободить мало памяти. В этом 
случае уборщик мусора может поднять порог для поколения 0. В результате уборка 
мусора выполняется реже, но каждый раз будет освобождаться значительный объем 
памяти. Кстати, если уборщик освобождает недостаточно памяти, перед генерированием
исключения OutOfMemoryException он выполняет полную уборку мусора.

## Запуск уборки мусора

Как вы уже знаете, CLR запускает уборку мусора, когда обнаруживает, что объем 
поколения 0 достиг своего порогового значения. Это самая распространенная причина 
запуска уборки мусора, однако есть и другие:

1. Вызов статического метода Collect объекта System.GC. Код явно указывает, 
в какой момент должна быть выполнена уборка мусора. Хотя Microsoft решительно 
не рекомендует использовать этот метод, иногда принудительная уборка 
мусора в приложении может быть оправдана. Этот способ рассматривается 
позднее в этой главе
2. Windows сообщает о нехватке памяти. CLR использует функции Win32 
CreateMemoryResourceNotification и QueryMemoryResourceNotification для 
контроля состояния памяти системы. Если Windows сообщает о недостаточном 
объеме свободной памяти, CLR запускает уборку мусора, чтобы избавиться от 
неиспользуемых объектов и сократить размер рабочего набора процесса.
3. Выгрузка домена приложения. При выгрузке домена приложения CLR выполняет 
полную уборку мусора для всех поколений. Домены приложений рассматриваются в 
главе 22
4. Завершение работы CLR. CLR завершает работу при нормальном завершении 
процесса (по сравнению, например, с внешним завершением работы 
из Диспетчера задач). Во время заверения CLR считает, что в процессе нет 
корневых ссылок; объектам предоставляется возможность выполнить очистку, 
но CLR не пытается дефрагментировать или освобождать память, потому 
что после завершения всего процесса Windows автоматически освобождает 
всю его память

## Большие объекты

Существует еще один путь повышения быстродействия, о котором стоит рассказать. 
CLR делит объекты на малые и большие. До настоящего момента рассматривались 
только малые объекты. Любые объекты размером 85 000 байт и более считаются 
большими. CLR работает с большими объектами по несколько отличающимся 
правилам:

1. Память для них выделяется в отдельной части адресного пространства процесса
2. К большим объектам не применяется сжатие, так как на их перемещение в памяти 
потребуется слишком много процессорного времени. Возможная фрагментация 
адресного пространства между большими объектами может привести к выдаче 
исключения OutOfMemoryException. В будущих версиях CLR большие объекты 
могут участвовать в сжатии.
3. Большие объекты всегда считаются частью поколения 2, поэтому их следует 
создавать лишь для ресурсов, которые должны жить долго. Размещение в памяти 
короткоживущих больших объектов приведет к необходимости частой уборки 
мусора в поколении 2, что снижает производительность. Обычно в больших 
объектах хранятся большие строки (например, XML или JSON) или массивы 
байтов, используемые в операциях ввода/вывода — например, при чтении данных 
из файла или сети в буфер для последующей обработки.

Все эти механизмы абсолютно прозрачны для разработчика. Вы можете просто 
забыть об их существовании до тех пор, пока в программе не возникнет какая-нибудь 
аномальная ситуация (например, фрагментация адресного пространства)

## Режимы уборки мусора

