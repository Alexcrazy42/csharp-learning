# Посмотреть позже:

1. Глава 6 про System.Reactive

2. Глава 7: рецепты начиная с 4

3. Глава 8: рецепты начиная с 5, + подразобраться с репептами 1-3

4. Глава 10: 10.6, 10.7

5. Глава 11: 11.4., 11.5, 11.6

6. Глава 13: 13.2, 13.4, 13,3

7. Глава 14: целиком

8. Приложение Б: Распознавание и интерпретация асинхронных паттернов


# Структура книги

1. В главе 1 содержится введение в различные виды конкурентности, 
описанные в книге: параллелизм, асинхронное и реактивное программирование, потоки данных.

2. В главах 2–6 представлено более подробное введение в разновидности 
конкурентности.

3. В каждой из оставшихся глав рассматривается конкретный аспект конкурентности; они также могут 
рассматриваться как сборник решений типичных проблем

# Главные моменты

1. Каждый поток имеет собственный независимый 
стек, но он совместно использует память со всеми остальными потоками 
процесса


2. Пул потоков содержит набор рабочих потоков, готовых к выполнению любой работы, которая им 
будет назначена. Пул потоков отвечает за определение количества потоков, 
находящихся в пуле потоков в любой момент времени.

3. Поток - низкоуровневая концепция. Работа с пулом потоков напрямую - чуть выше.
Параллельная обрабботка и потоки данных - еще выше. На нем мы и находимся.

4. Терминальный оператор и асинхронный делегат

5. Неизменяемые коллекции: (9 глава)

    Экземпляр никогда не изменяется
    Так как экземпляр никогда не изменяется, он потокобезопасен по своей природе
    При вызове изменяющего метода для неизменяемой коллекции возвращается новая измененная версия
    Неизменяемые коллекции являются потокобезопасными, но ссылки на них потокобезопасными не являются


6. (171 страница)
Одно важное примечание по поводу отсортированных множеств: индексирование 
для них выполняется за время O(log N), а не O(1), как у 
ImmutableList<T> (см. рецепт 9.2). Это означает, что в данной ситуации 
действует та же рекомендация: используйте foreach вместо for там, где 
это возможно, с ImmutableSortedSet<T>.

7. При использовании блокировок следуюет руководствоваться четырьмя важными рекомендациями:

1. Ограничье видимость блокировки

2. Документируйте, что именно защищает блокировка

3. Сократите до минимума объем кода, защищенного блокировкой

4. Никогда не выполняйте произвольный код при удержании блокировки

8. Асинхронные паттерны

1. TAP (Task Asynchronous Pattern) - современный паттерн

2. APM (Asynchronous Programming Model) - характерный признак - объекты IAsyncResult в сочетании с парой методов,
управляющих операцией; имя одного начинается с Begin, а имя другого - с End.

Пример типа с APM API:

```
class MyHttpClient
{
    public IAsyncResult BeginGetString(Uri requestUri,
        AsyncCallback callback, object state);

    public string EndGetString(IAsyncResult asyncResult);

    // Синхронный эквивалент для сравнения
    public string GetString(Uri requestUri);
}
```

3. EAP (Event Asynchronous Pattern) - "метод/событие". 

Имя метода обычно завершается суффиксом Async, и он 
в конечном итоге приводит к выдаче события, имя которого завершается 
суффиксом Completed.

Пример типа с EAP API:

```
class GetStringCompletedEventArgs : AsyncCompletedEventArgs
{
    public string Result { get; }
}

class MyHttpClient
{
    public void GetStringAsync(Uri requestUri);
    public event Action<object, GetStringCompletedEventArgs> GetStringCompleted;

    // Синхронный эквивалент для сравнения
    public string GetString(Uri requestUri);
}
```

4. Стиль передачи продолжений (CPS)

Пример:

```
class MyHttpClient
{
 public void GetString(Uri requestUri, Action<Exception, string> done);

 // Синхронный эквивалент для сравнения
 public string GetString(Uri requestUri);
}
```

5. Нестандартные асинхронные паттерны

Нестандартные паттерны не обладают общими характеристиками, поэтому 
распознать их труднее всего. К счастью, нестандартные асинхронные 
паттерны встречаются редко.

Пример типа с нестандартным асинхронным API:

```
class MyHttpClient
{
    public void GetString(Uri requestUri, MyHttpClientAsynchronousOperation operation);

    // Синхронный эквивалент для сравнения
    public string GetString(Uri requestUri);
}
```

6. ISynchronizeInvoke

Так как паттерн ISynchronizeInvoke подразумевает существование множественных 
событий в модели подписки, правильный способ потребления 
этих компонентов заключается в преобразовании событий в наблюдаемый поток — с 
использованием либо FromEvent (см. рецепт 6.1), либо Observable.Create.

 
# Вопросы

1. В чем прикол потокобезопасных коллекций, если автор пишет, что надо чтобы операции были
достаточно редки

# Рассмотреть позже

1. Рецепт 5.4. BufferBlock, 9.9