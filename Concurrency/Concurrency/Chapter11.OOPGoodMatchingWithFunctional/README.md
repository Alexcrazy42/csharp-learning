# Глава 11. ООП, хорошо сочетающееся с функциональным программированием

Асинхронное программирование близко к функциональному программированию.

Главное преимущество async заключается в том, что вы можете мыслить 
процедурными категориями, но программировать асинхронно. Это существенно 
упрощает написание и понимание асинхронных методов.

Во внутренней реализации асинхронный код остается функциональным по 
своей природе, и это создает некоторые проблемы, когда разработчики 
пытаются втиснуть async-методы в классические объектно-ориентированные архитектуры

В рецептах этой главы рассматриваются проблемные
области, в которых асинхронный код конфликтует с объектно-ориентированным программированием.

Эти проблемные области становятся особенно заметны при преобразовании существующей ООП-кодовой базы 
в кодовую базу, хорошо сочетающуюся с async.

# 11.1. Асинхронные интерфейсы и наследование

## Задача

В интерфейсе или базовом классе метода имеется метод, который требуется сделать асинхронным.

## Решение

Вспомните, что ожидание допускают типы, а не методы. Вы можете использовать await
с объектом Task, возвращенным методом, независимо 
от того, был метод реализован с ключевым словом async или нет. Таким 
образом, интерфейс или абстрактный метод может просто вернуть Task
(или Task<T>), а возвращаемое значение этого метода может допускать 
ожидание.

```
interface IMyAsyncInterface
{
	Task<int> CountBytesAsync(HttpClient client, string url);
}
```

Этот паттерн работает и с абстрактными методами базовых классов.

Асинхронная сигнатура метода означает лишь то, что реализация может
быть асинхронной. Фактическая реализация может быть синхронной, если 
нет реальной асинхронной работы, которую нужно было бы выполнять. 
Например, тестовая заглушка может реализовать тот же интерфейс (без 
async), используя нечто вроде FromResult:

```
class MyAsyncClassStub : IMyAsyncInterface
{
	public Task<int> CountBytesAsync(HttpClient client, string url)
	{
		return Task.FromResult(13);
	}
}
```

## Пояснение

На момент написания книги async и await еще только набирали обороты. 
По мере того как асинхронные методы становятся все более распространенными, 
асинхронные методы интерфейсов и базовых классов встречаются все чаще. Работать 
с ними не так уж сложно, если помнить, что 
ожидание должно применяться к возвращаемому типу (а не к методу), 
а определение асинхронного метода может быть реализовано асинхронно 
или синхронно.


# 11.2. Асинхронное конструирование: фабрики

## Задача

Вы программируете тип, который требует выполнения некоторой асинхронной работы в конструкторе.

## Решение

Конструкторе не могут объявляться с async; кроме того, они не могут содержать ключевого слова await. 
Конечно, использование await в конструкторе могло бы быть полезным, но это привело бы к существенному изменению
языка C#.

ОДна из возможностей - использовать конструктор в паре с инициализирующим async-методом, чтобы тип использовался
следующим образом:

```
var instance = new MyAsyncClass();
await instance.InitializeAsync();
```

У этого решения есть проблемы: разработчик может забыть вызвать второй метод, а экземпляр не может использоваться
сразу же после выполнения конструктора.

Вот более качественное решение, которое основано на применении паттерна асинхронного фабричного метода:

```
class MyAsyncClass
{
	private MyAsyncClass()
	{
	}

	private async Task<MyAsyncClass> InitializeAsync()
	{
		await Task.Delay(TimeSpan.FromSeconds(1));
		return this;
	}

	public static Task<MyAsyncClass> CreateAsync()
	{
		var result = new MyAsyncClass();
		return result.InitializeAsync();
	}
}
```

В другом коде, вызов будет выглядеть следующим образом:

```
MyAsyncClass instance = await MyAsyncClass.CreateAsync();
```

## Пояснение

И в этом методе есть проблема. К сожалению, ни одна заметная библиотека внедрения зависимостей не работает 
с async-кодом. Если вы окажетесь в одной из таких ситуаций, существует пара альтернатив.

Если создаваемый экземпляр в действительности является общим ресурсом, можно 
использовать асинхронную отложенную инициализацию, рассмотренную в рецепте 14.1. 
В противном случае можно воспользоваться 
паттерном асинхронной инициализации, описанным в рецепте 11.3.

```
class MyAsyncClass
{
	public MyAsyncClass()
	{
		InitializeAsync();
	}

	// ПЛОХОЙ КОД!!
	private async void InitializeAsync()
	{
		await Task.Delay(TimeSpan.FromSeconds(1));
	}
}
```

На первый взгляд решение может показаться разумным: вы получаете 
обычный конструктор, который запускает асинхронную операцию; при 
этом у него есть ряд недостатков, обусловленных использованием async 
void.

Первая проблема заключается в том, что при завершении конструктора экземпляр 
все еще продолжает асинхронно инициализироваться, ине 
существует очевидного способа определить, когда завершится асинхронная 
инициализация. Вторая проблема связана с обработкой ошибок: любые 
исключения, выданные из InitializeAsync, не могут быть перехвачены 
секциями catch, окружающими конструирование объекта.

# 11.3. Асинхронное конструирование: паттерн асинхронной инициализации

## Задача

Вы программируете тип, требующий выполнения некоторой асинхронной работы в его конструкторе, но не можете
воспользоваться паттерном асинхронной фабрики (рецепт 11.2), так как экземпляр создается с применением отражения
(например, библиотеки внедрения зависимостей/инверсии управления, связывания данных, Activator.CreateInstanse и т.д.)

## Решение

Если вы столкнулись с таким сценарием, вам приходится возвращать инициализованный экземпляр, хотя ситуацию
можно частично сгладить применением распроранненого паттерна асинхронной инициализации. Каждый тип, 
требующий асинхронной инициализации, должен определеять свойство следующего типа:

```
Task Initialization { get; }
```

```
/// <summary>
/// Помечает тип как требующий асинхронной инициализации
/// и предоставляет результат этой инициализации.
/// </summary>
public interface IAsyncInitialization
{
	/// <summary>
	/// Результат асинхронной инициализации этого экземпляра.
	/// </summary>
	Task Initialization { get; }
}
```

```
class MyFundamentalType : IMyFundamentalType, IAsyncInitialization
{
 public MyFundamentalType()
 {
	Initialization = InitializeAsync();
 }

 public Task Initialization { get; private set; }

 private async Task InitializeAsync()
 {
	 // Провести асинхронную инициализацию этого экземпляра.
	 await Task.Delay(TimeSpan.FromSeconds(1));
 }
}
```

Если вы используете библиотеку внедрения зависимостей/инверсии управления, то экземпляр этого типа может 
быть создан и инициализирован кодом следуюещо вида:

```
IMyFundamentalType instance = UltimateDIFactory.Create<IMyFundamentalType>();

var instanceAsyncInit = instance as IAsyncInitialization;
if (instanceAsyncInit != null)
	await instanceAsyncInit.Initialization;
```

Этот паттерн можно расширить так, чтобы он допускал композиацию типов с асинхронной инициализацией. 
В следующей примере определяется другой тип, зависящий от IMyFundametnalType:

```
class MyComposedType : IMyComposedType, IAsyncInitialization
{
	private readonly IMyFundamentalType _fundamental;

	public MyComposedType(IMyFundamentalType fundamental)
	{
		_fundamental = fundamental;
		Initialization = InitializeAsync();
	}

	public Task Initialization { get; private set; }
	
	private async Task InitializeAsync()
	{
		// Асинхронно ожидать инициализации фундаментального экземпляра
		// при необходимости.
		var fundamentalAsyncInit = _fundamental as IAsyncInitialization;
		if (fundamentalAsyncInit != null)
			await fundamentalAsyncInit.Initialization;
		// Выполнить собственную инициализацию (синхронно или асинхронно).
		...
	}
}
```

Составной тип ожидает инициализации всех своих компонентов перед тем, как переходить к собственной инициализации.
При этом следует руководствоваться таким правилом: каждый компоенент должен быть инициализирован к концу InitializeAsync.
Это гарантирует, что все зависимые типы будут инициализированы как часть составной инициализации. Любые исключения,
возникающие в ходе составной инициализации, распространяются в инициализацию составного типа.

## Пояснение

По возможности рекомендуется применять асинхронные фабрики или асинхронную отложенную инициализацию вместо этого 
решения. Эти решения предпочтительны, потому что в них исключается доступ к неинициализированному экземпляру. 


Если ваши экземпляры создаются библиотеками внедрения зависимостей/инверсии 
управления, связывания данных и т. д., вы будете вынуждены открыть 
доступ к неинициализированному экземпляру; в этом случае рекомендую 
использовать паттерн асинхронной инициализации из этого рецепта.

Код, который проверяет, реализует ли экземпляр IAsyncInitialization и инициализирует его, получается немного 
громоздким - и ситуация только усугубляется для составных типов, зависящих от большого количества компонентов.
Вы можете легко создать вспомогательный метод для упрощения код:

```
public static class AsyncInitialization
{
	public static Task WhenAllInitializedAsync(params object[] instances)
	{
		return Task.WhenAll(instances
			.OfType<IAsyncInitialization>()
			.Select(x => x.Initialization));
	}
}
```

Вызовите InintializeAllAsync и передайте любые экземпляры, которые требуется инициализировать; метод проигнорирует
экземпляры, не реализующие IAsyncInitialization. Код инициализации для составного типа, зависящего от трех
внедренных экземпляров, будет выглядеть примерно так:

```
private async Task InitializeAsync()
{
	// Асинхронно ожидать инициализации всех 3 экземпляров, если потребуется.
	await AsyncInitialization.WhenAllInitializedAsync(_fundamental, _anotherType, _yetAnother);
	// Выполнить собственную инициализацию (синхронно или асинхронно).
	...
}
```

# 11.4. Асинхронные свойства

## Задача

Имеется свойство, которое вам хотелось бы объявить как асинхронное. Свойство не задействовано в связывании данных.

## Решение

Эта проблема часто встречается при преобразовании существующего код для использования async

Ключевое слово async Не может использоваться со свойством.

```
// Чего хотелось бы (не компилируется).
public int Data
{
	async get
	{
		await Task.Delay(TimeSpan.FromSeconds(1));
		return 13;
	}
}
```

```
// Это "асинхронное свойство" является асинхронным методом.
public Task<int> Data
{
	get { return GetDataAsync(); }
}
```

Но все еще не рекомендуется применять этот подход. Если при каждом обращении у свойству будет запускаться
новая асинхронная операция, это "свойство" в действительности должно быть оформлено в виде метода.


Иногда значение свойства должно вычисляться при каждом чтении. В других случаях свойстввао должно инициализировать
только одно (асинхронное) вычисление и кэшировать полученное значение для использования в будущем. В этом случае
можно использовать асинхронную отложенную инициализацию.

```
// Как кэшированное значение
public AsyncLazy<int> Data
{
	get { return _data; }
}

private readonly AsyncLazy<int> _data =
	new AsyncLazy<int>(async () =>
	{
		await Task.Delay(TimeSpan.FromSeconds(1));
		return 13;
	});
```

Код будет выполнять асинхронное вычисление только один раз, а затем полученное значение будет возвращаться всем
остальным вызывающим сторонам. Код вызова выглядит примерно так:

```
int value = await instance.Data;
```

В данном случае синтаксис свойства уместен, потому что вычисление 
происходит только один раз.

## Пояснение

Если вы преобразуете синхронное свойство в «асинхронное свойство», 
следующий пример показывает, как это делать не следует:

```
private async Task<int> GetDataAsync()
{
	await Task.Delay(TimeSpan.FromSeconds(1));
	return 13;
}
public int Data
{
	// ПЛОХОЙ КОД!!
	get { return GetDataAsync().Result; }
}
```

# 11.5. async-события

## Задача

Событие должено использоваться с обработчиками, которые могут быть асинхронными; требуется проверить, завершились
ли обработчики событий. Следует учитывать, что при работе с событиями такая ситуация встречается довольно редко;
обычно при выдаче события вас не интересует, когда завершатся обработчики.

## Решение

На платформе Universal Windows появилась 
концепция так называемых объектов отложенного выполнения (deferrals), 
которые могут использоваться для отслеживания асинхронных обработчиков.

Асинхронный обработчик создает объект отложенного выполнения перед первым ключевым словом await и позднее
уведомляет объекта отложенного выполнения при завершении. Синхронным обработчикам использовать объекты отложенного
выполнения не нужно.

Библиотека Nito.AsyncEx включает тип DeferralManager, который используется компонентом, выдающим событие. 
Объект DeferralManager затем разрешает обработчикам событий создавать объекты отложенного 
выполнения и отслеживает завершение всех таких объектов.

Для каждого из ваших событий, для которых необходимо дождаться завершения обработчиков, начните с расширения
типа аргументов события.

С асинхронными обработчиками событий лучше сделать тип аргументов события потокобезопасным. Проще всего для этого
объявить его неизменяемым (т.е. потребовать, чтобы все его свойства были доступными только для чтения).

Затем каждый раз при выдаче события вы можете (асинхронно) ожидать 
завершения всех асинхронных обработчиков событий. Следующий пример 
вернет завершенную задачу при отсутствии обработчиков; в противном 
случае он создаст новый экземпляр типа аргументов события, передаст 
его обработчикам и будет ожидать завершения всех асинхронных обработчиков:

```
public event EventHandler<MyEventArgs> MyEvent;

private async Task RaiseMyEventAsync()
{
	EventHandler<MyEventArgs> handler = MyEvent;
	if (handler == null)
		return;
	var args = new MyEventArgs(...);
	handler(this, args);
	await args.WaitForDeferralsAsync();
}
```

После этого асинхронные обработчики событий смогут использовать 
объект отложенного выполнения в блоке using. Объект отложенного 
выполнения уведомит DeferralManager о своем освобождении:

```
async void AsyncHandler(object sender, MyEventArgs args)
{
	using IDisposable deferral = args.GetDeferral();
	await Task.Delay(TimeSpan.FromSeconds(2));
}
```

Происходящее несколько отличается от того, как работают объекты отложенного выполнения в Universal Windows. 
В Universal Windows API каждое событие, которому понадобятся объекты отложенного выполнения, 
определяет собственный тип объекта отложенного выполнения, 
и этот тип содержит явно определенный метод Complete (вместо того 
чтобы реализовать IDisposable).


## Пояснение

События уведомлений и командные события.

События уведомлений - уведомление других компонентов о некоторой ситуации

Командные события - инициализируются для реализации некоторой функциональности по поручению компонента-отправителя.

Отправитель дожидается, когда команда будет обработана получателем.

Любое событие UI-фреймворка тоже являяется командным событием, как и события жизненого цикла страниц ASP.NET.

Если ваше событие является событием уведомления, то для поддержки асинхронных обработчиков вам не придется ничего 
делать (просто сделать событие async void).

Командные события - совсем другое дело. Необходимо определять, когда обработчики были завершены.

# 11.6. Асинхронное освобождение

## Задача

Имеется тип с асинхронными операциями, который должен обеспечить 
освобождение своих ресурсов.

## Решение

Есть два распространенных варианта действий в отношении существующих операций 
при освобождении экземпляра: освобождение можно либо 
рассматривать как запрос на отмену, применяемый ко всем существующим 
операциям, либо реализовать настоящее асинхронное освобождение.

В следующем код Dispose отменить все операции, но не ожидает завершения этих операций:

```
class MyClass : IDisposable
{
	private readonly CancellationTokenSource _disposeCts = new CancellationTokenSource();

	public async Task<int> CalculateValueAsync(CancellationToken)
	{
		using CancellationTokenSource combinedCts = CancellationTokenSource
			 .CreateLinkedTokenSource(cancellationToken, _disposeCts.Token);
		await Task.Delay(TimeSpan.FromSeconds(2), combinedCts.Token);
		return 13;
}

	public void Dispose()
	{
		_disposeCts.Cancel();
	}
}
```

Метод CalculateValueAsync принимает CancellationToken, которые объединияется вместе с общим CancellationTokenSource, 
для того, чтоб метод мог остановиться при отмене любого из этих маркером.

Асинхронное освобождение появилось в C# 8.0 и .NET Core 3.0. В BCL появился новый интерфейс IAsyncDisposable.
Также была введеная команда await using - асинхронный аналог using.

```
class MyClass : IAsyncDisposable
{
	public async ValueTask DisposeAsync()
	{
		await Task.Delay(TimeSpan.FromSeconds(2));
	}
}
```

Типы, реализующие IAsyncDisposable, обычно потребляются с await:

```
await using (var myClass = new MyClass())
{
	...
} // Здесь вызывается DisposeAsync (с ожиданием)
```

Если нужно обойти контекст с использованием ConfigureAwait(false), 
это возможно, но решение получается более громоздким, потому что 
переменная должна быть объявлена за пределами команды await using:

```
var myClass = new MyClass();
await using (myClass.ConfigureAwait(false))
{
	...
} // Здесь вызывается DisposeAsync (с ожиданием) 
 с ConfigureAwait(false).
```

## Пояснение

В этом рецепте представлены два паттерна для реализации освобождения; 
также при желании вы можете использовать их одновременно. Одновременное 
использование обоих паттернов наделит ваш тип семантикой 
четкого завершения, если в клиентском коде используется await using, 
и семантикой отмены, если клиентский код использует Dispose. Я бы не 
рекомендовал так поступать, но знайте, что такой вариант существует.