# csharp-learning

вопросы по CLR: 
1) место в сборке, куда могут стекаться различные типы данных (manager, provider)
2) где найти сорцы шарпов, асп, еф, xunit
3) builder как в ef для свойств класса
4) StringComparer
5) намеренно наивная проверка на соответстиве поведению EmailAddressAttribute ASP.NET Core https://github.com/dotnet/runtime/issues/27592
6) связывание с другими языками, технологиями, протокаолами языка C# (http, db api)
7) int[] как key в dict
8) пройти стэк от начала до конца, а не от конца к началу
2) создание своих внешних псевдонимов
3) как следить в runtime за heap и стеком выполнения, искать утечки памяти
4) невиртуальный вызов виртуального метода 
5) call - экземплярный или виртуальный метод 
callvirt - невиртуальный экз метод, виртуальный экз метод
6) как sealed может оптимизировать вызов callvirt, если он действует только на отсечение производных типов, а callvirt менее эффективен, потому что ищет реализую в предках, а не в потомках
7) история языка C#: версии .net и C#, .net framework после создания net core
9) BeforeFieldInit
10) почему компилятор не подсвечивает когда мы пытаемся сделать преобразование неявно, когда в типе есть только явное преобразование (но в книге говорится об обратном) надо проверить
11) почему язык не поддерживает свойств расширения, событий расширения, операторов расширения
12) реальный пример частичных методов
14) C# индексатор
15) DefaultParameterValue
16) typeof
17) когда реально может понадобиться ref и out
2) порядок инициализации полей
3) рабочий набор приложения, домен приложений
4) когда CLR решает, что нужно упаковать объект
5) ссылочный переход из пункта 10 (IList<string> в List<Object> допустим)
7) что значит что значимые типы неявно называются изолированными, а еще есть какие то запечатанные классы
1) изолированные методы
2) как в самом языке с помощью каких то интерфейсов можно добавлять всякие конструкции новые
по типу: реализовал IEnumerator и ты можешь использовать foreach для объекта
3) почему EIMI методы нельзя отметить как public
5) абстрактная реализация интерфейса
2) Ordinal, cultural comparison
4) Интернирование строк
6) как между собой связаны CLR, .NET и C# (граф связей)

---------------------------------------------------
что нужно будет потом посмотреть:
1) IEnumerator
2) делегаты: Invoke, Invoker
1) System.IO.Stream, FileStream, MemoryStream, System.Net.Sockets.Network.Stream
2) Windows Forms: Button, CheckBox, ListBox порождаемые от System.Windows.Forms.Control
3) System.Collections.Generic: IEnumerable<T>, ICollection, IList, IDictionary
1) System.Enviroment
2) класс является изолированным
3) StringBuilder реализация, что происходит после вызова ToString, сравнить что изменилось с тех пор как 
Рихтех писал про SB
4) System.Globalization.NumberStyles
5) IO операции и кодировки UTF: BinaryWrite/Reader, StreamWriter/Reader, Encoding, UTF8/32/7Encoding
6) System.Security.Cryptography.CspParameters;
System.Security.Cryptography.X509Certificates.X509Certificate и System.Security.Cryptography.X509Certificates.X509Certificate2
System.Diagnostics.Process и System.Diagnostics.ProcessStartinfo
System.Diagnostics.Eventing.Reader.EventlogSession
SecurePassword
7) Marshal, указатели, unsafe код
8) delegates: action, func
9) typeof, gettype ...
10) RuntimeHelpers
11) События еще раз посмотреть
12) политика расширения
13) formatter: binary, soap
14) SynchronizationContext
15) почему при блокировке потока появится новый поток в пуле

-----------------------------------------
проблемы в C#:
1) 322 страница: невозможно спроетировать математический алгонритм для произвольных числовых типов данных.
Поскольку во время компляции компилятор не знает тип обобщенных типов: в .NET 6 появился интерфейс INumber

---------------------------------------------------------
Появилось еще в C#, после выпуска книги:
1) $""
2) Метод Main может стать async

---------------------------------------
Интересные непонятные вещи из книги:
1) Даже если объект String существует недолго и становится добычей
GC, CLR может не сразу задействовать ранее занятиую этим объектом память (особенно если речь идет об объектах String предыдущих версий), оставляя символы
объекта в памяти, где они могут быть скомпрометированы. 
2) При создании этого объекта его
	код выделяет блок неуправляемой памяти, которая содержит массив символов. Сборщик муcора ничего не знает об этой неуправляемой памяти

Определенные страницы:
старая книга: 
378 страница - StringBuilder.AppendFormat
388 страница - Decoder

новая:
424 - реализация интерфейсов IEnumberable, ICollection и IList
433 - Небезопасный доступ к массивам и массивы фиксированного размера
451 - 463 - делегаты
475 - 483 - атрибуты
515 - 523 - очень много непонятного про исключения в многопоточной среде
538 - 540 - отладка исключений, не понял к чему может помочь представленный метод в разработке и отладке
543 - области ограниченного действия
546 - 553 - контракты входа
564 - поколения, вызов барьерного метода записи
574 - PerfView, PerfMon, SOS - утилиты, чтобы смотреть за эффективностью GC
582-583 - SafeHandle при работе с неуправляемым кодом
594 - 597 - Внутреннняя реализация финализации
597 - 605 - мониторинг и контроль времени жизни объектов
631 - 635 - нетривиальное управление хостингом
688 - 691 - сериализация в другой тип и десериализация в другой объект
691 - 695 - суррогаты
710 - AsTask внутренний код
710 - 722 - Взаимодействия между потоками WinRT и потоками .NET и еще про WinRT
796 - 799 - AsyncStateMachine
800 - 803 - два примера кода
806 - асинхронная модель для WebClient
813 - SynchronizationContext
815 - WithCancellationToken
817 - 819 - приоритеты запросов ввода-вывода + последнее примечание
851 - 853 - мьютексы
864 - 865 - почему класс Monitor не должен быть реализован как статический
880 - паттерн условной переменной
885 - код AsyncOneManyLock
888 - конкурентные коллекции из FCL




----------------------------------------------------------
Что касается самого репозитория:
1) что нужно сделать:
	1) добавить везде ------- и название подтемы, в реадми добавить ссылку на это место
	2) узнать про курсивы, жирный, полужирный текст и сделать это для многих определений
	3) сделать место, куда записать все главные мысли и то что наиболее полезно в разработке

2) Обдумать что включить в репу:
	1) Best Practices для разработчик приложений: время, кодировки, безопасность, производительности, языки
	2) Concurrency
	3) IO-операции
	4) работа с внешними приложениями, интеграция
	5) история развития языка
	6) завязка с системными ресурсами, как CLR получает к ним доступ
	7) Разбор кода популярных либ и фрейморвков: именно их структура на диграммах и интересные модели
	8) Win32

3) Популярные либы:
1. newtosoft.json: 
как реализована сериалиализация любого объекта
2. Microsoft.Extensions.DependencyInjection
https://github.com/dotnet/runtime/tree/main/src/libraries/Microsoft.Extensions.DependencyInjection/src

3. autofac: 
свой DI
4. ASP.NET
cancellationToken в любом месте
паттерн Controller
внедрение DI

5. CLR

4) Теоретические знания

1) Потоки и процессы ОС, ядра, асинхронность, фоновые потоки


5) Классы, которые хочу разобрать:

1. Task, TaskScheduler, Parallel, TaskAwaiter, GetAwaiter(), IAsyncStateMachine 

Как в Parallel LINQ обрабатывается ParallelMergeOptions.AutoBuffered,
как поток выбирает какие результаты буферизовать. 

Timer, ThreadPool


"Windows уведомляет CLR-пул о том, что один из его потоков прекратил работу", как?
порт завершения ввода-вывода - наверно то что нужно нам

AsyncEnumerator (из библиотеки Power Threading — см. http://
Wintellect.com/)

EventArgs


ЛАЙФХАКИ:

1) Кстати, для завершения Windows-процесса со всеми его доменами можно воспользоваться 
статическим методом Exit класса System.Environment. Это самый корректный
способ завершения процесса, так как данный метод сначала вызывает методы финализации 
всех объектов в управляемой куче, а затем освобождает все неуправл

2) WhenAll, WhenAny

3) SpinLock и WaitLock