# Глава 14. Символы, строки и обработка текста


1) Символы
	1) System.Char - Значимый тип
	2) Категория символа - управляющий символ, символ валюты, буква в нижнем или верхнем регистре, знак 
		пунктуации, математический символ и т.д. System.Globalization.UnicodeCategory
	3) I sDigit, Isletter, IsWhiteSpace, IsUpper, Islower, IsPunctuation, 
		IsletterOrDigit, IsContro1 , IsNumber, IsSeparator, IsSurrogate, IsLowSurrogate, 
		IsHighSurrogate и IsSymbo1

	4) Региональные стандарты - culture, для преобразования символа с учетом culture, относящихся к вызывающему
		потоку (статическое свойство CurrentCulture класса Thread), служат ToLower и ToUpper
		Чтобы задать определенный набор региональных стандартов, передайте этим методам экземпляр класса 
		CultureInfo
	5) Equals - возвращает true, если два экземпляра представляют один и тот же 16-разрядный Unicode символ
		CompareTo - сравнивает два кодовых значения без учета региональных стандартов
		ToString - возвращает строку, состоящую из одного символа
		Parse и TryParse - получают односимвольную строку и возвращают соответствующую кодовую позицию UTF-16
		GetNumericValue - возвращает числовой эквивалент символа

	6) Три способа преобразования различных числовых типов в экземпляры типа Char и наоборот:
		- Приведение типа. Самый эффективный способ, тк компилятор генерирует IL-команды преобразования без
		вызовов каких-либо методов. ДЛя преобразования типа Char в числовое значение, такое как Int32,
		приведение подходит лучше всего. Кроме того, в C# допускается указывать, какой код выполняет 
		преобразование: проверяемый или непроверяемый
		- Использование типа Convert. У типа System.Convert есть несколько статических методов, корректно
		преобразующих Char в числовой тип и обратно. Все эти методы выполняют преобразование как проверяемую
		операцию, чтобы в случае потери данных при преобразовании вбрасывалось исключение OverflowException
		- Использование интерфейса IConvertible. В типе Char и во всех числовых типах библиотеки FCL 
		реализован интерфейс IConvertible, в котором определены такие методы, как ToUInt16 и ToChar. Этот
		способ наименее эффективен, так как вызов интерфейсных методов для числовых типов приводит к упаковке
		экземпляра: Char и все числовые типы являются значимыми. Методы IConvertible выбрасывают исключение
		InvalidCastException, если преобразование невозможно или грозит потерей данных. Все методы IConvertible
		за исключением GetTypeCode принимают ссылку на объект, реализующий интерфейс IFormatProvider. Этот 
		параметр полезен, когда по какой-либо причине при преобразовании требуется учитывать региональные 
		стандарты. В большинстве операций в этом параметре передается null, потому что он все равно 
		игнорируется.

2) Тип System.String
	1) Неизменяемый упорядоченный набор символом
	2) В C# String считают элементарным типом, то есть csc разрешает вставлять литеральные строки 
		непостредственно в исходный код. Компилятор помещает эти литеральные строки в метаданные модуля, где
		они часто загружаются и на них ссылаются во время выполнения.
		в C# с помощью оператора new нельзя создавать объекты типа String
	3) За создание нового экземпляра объекта отвечает IL-команда newobj. Однако для создание строки нет
		такой команды, вместо нее используется специальная команда ldstr (загрузка строки), которая создает
		объект String на основе литеральной строки, полученной из метаданных. 
	3) В C# имеется специальный синтаксис для ввода литеральных строк в исходный код. Для вставки специальных
		символов, таких как конец строки, возврат каретки, забой
		Задавать в коде последовательность символов конца строки и перевода каретки напрямую не рекомендуется
		Лучше использовать System.Enviroment.NewLine, которая зависит от платформы
	4) оператор + выполняется на этапе компиляции и не создается отдельных строк из литералов
		Конкатенация нелитеральных строк с помощью оператора + происходит на этапе выполнения. Для
		конкатенации нескольких строк на этапе выполнения оператор + применять нежелательно, тк он создает 
		в куче несколько строковых объектов. Вместо него использовать надо тип System.Text.StringBuilder
	5) В C# есть особый вариант объявления строки, в которой все символы между кавычками трактуются как часть
		строки. Это специальные объявления - буквальные строки (verbatim strings) - обычно используют при
		задании пути к файлу или каталогу и при работе с регулярными выражениями

3) Неизменяемые строки
	1) объект String - неизменяемым, то есть созданную однажды строку нельзя сделать длиннее или короче, 
		в ней нельзя изменить ни одного символа. Неизменяемость строк дает определенные преимущества. 
		```
		if(s.ToUpperInvariant().Substring(10, 21).EndWith("EXE")) { }
		```
		В приведенном коде ToUpperInvariant возвращает новую строку, символы в строке s не изменяются.
		Substring обрабатывает стркоу, возвращенную ToUpperInvariant, и тоже возаращает новую строку, которая
		затем передается методу EndsWith. По итогу в куче помимо строки s создается еще 2 строки, на которые
		нет ссылки. Это приведет потом к сборке мусора. Если требуется эффективно выполнять много операций со
		строками лучше использовать класс StringBuilder
	2) Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками. 
		Кроме того, в CLR несколько ссылок String могут указывать на один, а не на несколько разных строковых
		объектов, если строки идентичны. А значит, можно сократить количество строк в системе и уменьшить 
		расход памяти - это именно то, что непосредственно относится к интернированию строк (string interning)
		По соображениям производительности тип String тесно интегрирован с CLR. В частности CLR "знает" о 
		размещении полей в этом типе и обращается к ним напрямую. За повышение производительности и прямой доступ
		приходится платить небольшую цену: класс String является изолированным. Иначе, имея возможность
		описать собственный тип, производный от String, можно было бы добавлять свои поля, противоречащие
		структуре String и нарушающие работу CLR. Кроме того, ваши действия могли бы нарушить представляения
		CLR об объекте String, которые вытекают из его неизменности

4) Сравнение строк
	1) Сравнение - одно из наиболее часто выполняемых со строками операций. Мы сравниваем их для выяснения, 
		равны ли они, и для сортировки
	2) Для сравнения строк Рихтер настоятельно рекомендует использовать один из этих методов, реализованных
		в классе String:
		![](images/string_comparison.png)
		При сортировке всегда нужно учитывать регистр
		А аргументе comparisonType передается одно из значений, определенных в перечислимом типе
		StringComparison, где есть: CurrentCulture, CuurentCultureIgnoreCase, InvariantCulture,
		InvariantCultureIgnoreCase, Ordinal, OrdinalIgnoreCase
		Аргумент CompareOptions является одним из значений, определенным перечислимым типом CompareOptions
	3) Во многих программах строки применяют для решения таких задач, как поддержка имен путей и файлов, 
		URL-адресов, параметров и разделов реестра, переменных окружения, отражения, XML-тегов. Для сравнения
		строк внутри программы следует всегда использовать флаг StringComparison.Ordinal или
		StringComparison.OrdinalIgnoreCase. Это дает самый быстрый инструмент сравнения так как он игнорирует
		лингвистические особенности и региональные стандарты.
		В то же время, если требуется корректно сравнивать строки с точки зрения лингвистических особенностей
		(обычно перед выводом их на экран для пользователя), следует использовать флаг
		SystemComparison.CurrrentCulture или SystemComparison.CurrrentCultureIgnoreCase 
	4) Обычно следует избегать использования флагов StriпgComparison.InvariantCulture и 
		StringComparison.InvariantCultureIgnoreCase. Хотя эти значения и позволяют выполнить лингвистически 
		корректное сравнение, применение их для сравнения строк в программе занимает больше времени, чем флага 
		StringComparisoп.Ordinal или StringComparison.OrdinalIgnoreCase. Кроме того, игнорирование региональных 
		стандартов - совсем неудачный выбор для сортировки строк, которые планируется показывать пользователю
	5) Если вы хотите изменить регистр символов строки перед выполнением п ростого срав нения, следует 
		использовать предоставляемый String  метод ToUpperInvariant или ToLowerInvariant. При нормализации строк 
		настоятельно рекомендуется использовать метод ToUpperInvariant, а не 
		TolowerInvariant из-за того, что в Microsoft сравнение строк в верхнем 
		регистре оптимизировано. На самом деле, в FCL перед не зависящим от 
		регистра сравнением строки нормализуют путем приведения их к верхнему 
		регистру.
	6) В типе String определено несколько вариантов перегрузок методов Equals, StartWith, EndsWith,
		и CompareTo помимо тех, что приведены ранее. Microsoft рекомендует избегать других версий: 
		CompareTo, CompareOrdinal и операторов == и != следует также избегать. Причина в том, что 
		вызывающий код не определяет явно, как должно выполняться сравнение строк, а на основании
		метода нельзя узнать, какой способ сравнения выбран по умолчанию. Например, по умолчанию
		метод CompareTo выполняет сравнение с учетом региональных страндартов, а Equals - без учета. 
		Код будет легче читать и поддерживать, если всегда явно описывать, как следует выполнять
		сравнение строк.
	7) Лингвистически корректные сравнения. ДЛя представления пары "язык-страна" (как описано в 
		спецификации RFC 1766) в .NET используется System.Globalization.CultureInfo. 
		В CLR у каждого потока есть два свойства, относящиеся к этой паре и ссылающиеся на объект
		CultureInfo: 
		![](images/culture_info_2properties.png)
		Внутренняя реализация объекта CultureInfo ссылается на объект System.Globalization.CompareInfo, 
		инкапсулирующий принятые в данных региональных стандартах таблицы сортировки в соответствии с 
		правилами Unicode. Эти таблицы являются частью самой инфраструктуры .NET Framework, поэтому все
		версии .NET (независимо от ОС) также будут сравнивать и сортировать строки.
	8) В некоторых редких случаях требуется более тонкий контроль при сравнении строк для проверки на 
		равенство и для сортировки. Это может потребоваться при сравнении строк с японскими иероглифами. 
		Дополнительный контроль получают через объект Cultureinfo свойства Compareinfo. Как отмечалось 
		ранее, объект Cultureinfo инкапсулирует таблицы сравнения символов для различных региональных 
		стандартов, причем для каждого регионального стандарта существует только один объект CompareInfo
	9) Метод Compare класса Compareinfo принимает в качестве параметра значение 
		перечислимого типа CompareOptions, в котором определены символы IgnoreCase, 
		IgnoreKanaType, IgnoreNonSpace, IgnoreSymbols, IgnoreWidth, None, Ordinаl и StringSort. 
		Эти символы представляют собой битовые флаги, которые можно объединять 
		посредством оператора или для большего контроля над сравнением строк.
	10) Интернирование строк
		Сравнение строк трубуется во многих приложениях. Но эта операция может ощутимо сказаться на
		производительности. При порядковом сравнении (ordinal comparison) CLR быстро проверяет, 
		равно ли количество символов с строках. При отрицательном результате строки точно не равны, но
		если длина одинакова, приходится сравнивать символ за символом. При сравнении с учетом 
		региональных стандартов среде CLR тоже приходится посимвольно сравнить строки, потому что 
		две строки разной длины могут оказаться равными.
		К тому же, если в памяти содержится еще несколько экземпляров строки, 
		потребуется дополнительная память, ведь строки неизменяемы. Эффективного 
		использования памяти можно добиться, если держать в ней одну строку, на 
		которую будут указывать соответствующие ссылки. 
		Если в приложении строки сравниваются часто методом порядкового сравнения с учетом порядкового
		сравнения с учетом регистра или если в прриложении ожидается появление множества одинаковых 
		строковых объектов, то для повышения производительности надо применять поддерживаемый CLR 
		механизм интернирования строк (string interning). При инициализации CLR создает внутреннюю
		хэш таблицу, в которой ключами являются строки, а значениями - ссылки на строовые объекты в 
		heap. В классе String есть два метода, предоставляющие доступ к внутренней хэш-таюлице: 
		String Intern (String str), String IsInterned(String str)
		Первый из них, Intern, ищет String во внутренней хэш таблице. Если таковая находится возвращается
		ссылка на соответствующий объект string. Иначе создается копия строки, она добавляется во 
		внутренню хэщ-таблицу и возвращается ссылка на копию. Если приложение больше не удерживает
		ссылку на исходный объект String, сборщик мусора вправе осовободить память, занимаемую этой
		строкой. Обратите внимание, что GC не вправе освободить строки, на которые ссылается внутренняя
		хэш-таблица, поскольку в ней самой есть ссылки на эти String. Объекты String, на которые ссылается
		внутренняя хеш-таблица, нельзя освободить, пока не выгружены соответствующие домены или не закрыт
		поток.
		По умолчанию при загрузку сборки CLR интернирует все литеральные строки, описанные в метаданных
		сборки. В Microsoft выяснили, что это отрицатльно сказывается на производительности из-за 
		необходимости дополнительного поиска в хэш-таблицах, поэтому теперь можно отключить
		эту "функцию". Если сборка отмечена аттрибутом System.Runtime.CompilerServices.CompilationRelaxationAttribute,
		определяющим значение флага System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning, то в
		соответствии со спецификацией ECMA среда CLR может не интернировать все строки, определенные
		в метаданных сборки. Обратите внимание, что в целях производительности работы приложения csc
		всегда при компиляции сборки определяет этот атрибут/флаг
		Никогда не стоит писать код, в надежде, что строки будут ссылаться на один объект в heap
		В действительности, CLR версии 2.0 учитьтает этот атрибут/флаг, но только если код сборки 
		создан с помощью утилиты NGen.exe
	11) Создание пулов строк
		При обработке исходного кода компилятор должен каждую литеральную строку 
		поместить в метаданные управляемого модуля. Если одна строка встречается 
		в исходном коде много раз, размещение всех таких строк в метаданных приведет к увеличению 
		размера результирующего файла. Чтобы этого не допуститьь, многие компиляторы (в том числе csc)
		хранят литеральную строку в метаданных модуля только в одном экземпляре. Все упоминания этой 
		строки в исходном коде компилятор заменяет ссылками на ее экземпляр в метаданных. Благодаря 
		этому заметно уменьшается размер модуля. Способ не нов - в компиляторах C/C++ этот механизм 
		реализован уже давно и называется созданием пула строк (string pooling)
	12) Работа с символами и текстовыми элементами в коде
		На самом деле System.Char представляет одно 1 6-разрядное кодовое значение в кодировке Unicode, 
		которое необязательно соответствует абстрактному Uniсоdе-символу. Так, некоторые абстрактные 
		Uniсоdе-символы являются комбинацией двух кодовых значений. Например, сочетание символов U+0625 
		(арабская буква 'алеф' с подстрочной 'хамза') и U +0650 (арабская 'казра' ) 
		образует один арабский символ, или текстовый элемент. Кроме того, представление некоторых 
		абстрактных Uniсоdе-символов требует не одного, а двух 16-разрядных кодовых значений. Первое 
		называют старшим. (high surrogate), а второе - м.ладшим. заменителем. (low surrogate). 
		Значения старшего находятся в диапазоне от U+D800 до U+DBFF, младшего - от U+DCOO до U+DFFF. 
		Такой способ кодировки позволяет представить в Unicode более миллиона различных символов. 
		Символы заменители востребованы в основном в странах Восточной Азии и гораздо меньше в США и Европе
		
5) Прочие операции со строками
	![](images/another_operations_with_strings.png)

6) Эффективное создание строк
	1) Для динамический операций со строками и символами при создании объектов String в FCL имеется тип
		System.Text.StringBuilder. Его можно рассматривать как некий общедоступный конструктор для String. 
		В общем случае нужно создавать методы, у которых в качестве параметров выступают объекты String, а 
		не StringBuilder, хотя можно написать метод, возвращающий строку, создаваемую динамически 
		внутри метода. 
		У объекта StringBuilder предусмотрено поле со ссылкой на массив структур Char. Используя члены 
		StringBuilder, можно эффективно манипулировать этим массивом, сокращая строку и изменяя символы строки. 
		При увеличении строки, представляющей ранее выделенный массив символов, StringBuilder автоматически 
		выделит память для нового, большего по размеру массива, скопирует символы и приступит к работе с 
		новым массивом. А прежний массив попадет в сферу действия сборщика мусора. 
		Объект String, возвращаемый методом ToString, не может быть изменен. Поэтому, если вы вызовете метод, 
		который попытается изменить строкавое поле, управляемое объектом StringBuilder, методы этого объекта, 
		зная, что для него был вызван метод ToString, создадут новый массив символов, манипуляции с которым 
		не повлияют на строку, возвращенную предыдущим вызовом ToString
	2) У типа StringBuilder несколько конструкторов, каждый из которых обязан выделить память и инициализировать
		три внутренних поля, управляемых любым объектом StringBuilder:
		- Максимальная емкость (maximum capacity) - максимальное число символов, размещаемых в строке.
		По умолчанию оно равно Int32.MaxValue
		- Емкость (capacity) - размер массива символов StringBuilder. По умолчанию равно 16. При добавлении
		символов StringBuilder определяет не вышло ли это за пределы, и если да - удваивает емкость, и 
		копирует значения из старого массива в новый. 
		- Массиво символов (character array) - массив структур Char, содержащий набор символов 'строки'. 
		Число символом всегда меньше или равно емкости и максимальной емкости. 
	3) Сформировав строку с помощью SB, "преобразуйте" массив символов SB в объект String, вызвав метод
		ToString типа SB. Этот метод просто возвращает ссылку на поле-строку, управляемую объектом SB.
		Поскольку массив символов здесь не копируется, методе выполняется очень быстро. Объект String, 
		возращаемый методом ToString, не может быть изменен. Поэтому, если вы вызовете метод, который
		попытается изменить строковое поле, управляемое объектом StringBuilder, методы этого объекта, 
		зная, что для него был вызван метод ToString, создадут новый массив символов, манипуляции с которым
		не повлияют на строку, возвращенную предыдущим вызовом ToString

7) Члены типа StringBuilder
	1) Тип StringBuilder в отличии от String представляет изменяемую строку. Это значит, что многие члены
		SB изменяют содержимое в массиве символов, не создавая новых объектов, размещаемых в heap.
		SB выделяет память для новых объектов только: 
		- при динамическом увеличении размера строки больше установленной емкости
		- при попытке изменить массив после вызова метода ToString типа StringBuilder
	2) Методы класса StringBulder
		![](images/string_builder_class_methods.png)
	3) Большинство методов SB возвращают ссылку на тот же объект SB, похоже на паттерн строитель, который 
	помогает выстроить цепочку сразу нескольких операций:
	```
	StringBuilder sb = new StringBuilder();
	String s = sb.AppendFormat("29837498237").Replace('2', ' ').Remove(4, 3).ToString();
	```
	4) У класса StringBuilder нет некоторых аналогов для методов класса String. 
		Например, у класса String есть методы Tolower, ToUpper, EndsWith, Padleft, 
		Trim и т. д., отсутствующие у класса StringBuilder. В то же время у класса  
		StringBuilder есть удобный метод Replасе, выполняющий замену символов 
		и строк лишь в части строки (а не во всей строке). Из-за отсутствия полной 
		аналогии методов иногда приходится прибегать к преобразованиям между 
		String и StringBuilder.

8) Получение строкового представления объекта
	1) Каждый тип должен сам предоставить код, преобразующий значение экземпляра в некий строковый компонент
		Выбирая способы решения этой задачи, разработчики FCL придумали эталон программирования, предназначенный
		для повсеместного использования
		Семантически ToString возвращает строку, которая представляет текущее значение объекта в формате, 
		учитывающем текущие региональные стандарты вызвавшего потока. Строкавое представление числа, к 
		примеру, должно правильно отображать разделитель дробной части, разделитель групп разрядов и тому 
		подобные параметры, устанавливаемые региональными стандартами вызывающего потока.
		Реализация ToString из System.Object просто возвращает полное имя типа объекта.
		Все базовые типы встроенные в FCL (Byte, Int32, UInt64, Double и тд) имеюь переопределенный метод
		ToString, реализация которого возвращает строку с учетом региональных стандартов
		В отладчике Visual Studio, когда указатель мыши наводится на соответствующую переменную, появляется всплывающая подсказка. Текст этой 
		подсказки формируется путем вызова метода ToString этого объекта. Таким образом, при определении 
		класса вы должны всегда переопределять метод ToString, чтобы иметь качественную поддержку при отладке программнаго 
		кода
	2) Форматы и региональные стандарты
		Метод ToString без параметров является источником двух проблем. Во-первых, вызывающая программа 
		не управляет форматированием строки, как например, когда приложению нужно представить число в 
		денежном или десятичном формате, в процентном или шестнадцатеричном виде. Во-вторых, вызывающая
		программа не может выбрать формат, учитывающий конкретные региональные стандарты
		Вторая проблема более остро стоит для серверных приложений и менее 
		актуальна для кода на стороне клиента. Изредка приложению требуется форматировать строку с учетом 
		региональных стандартов, отличных от таковых у вызывающего потока. Для управления форматированием строки нужна 
		версия метода ToString, позволяющая задавать специальное форматирование 
		и сведения о региональных стандартах. 
	3) Тип может предложить вызывающей программе выбор форматирования и региональных стандартов, если он 
		реализует интерфейс System.IFormattable:
		```
		public interface IFormattable
		{
			String ToString(String format, IFormatProvider formatProvider);
		}
		```
		У метода ToString интерфейса IFormattable два параметра. Первый, format, - это строка, сообщающая
		методу способ форматирования объекта. Второй, formatProvider, - это экземпляр типа, который реализует
		интерфейс System.IFormatProvider. Этот типа предоставляет методу ToString информацию о региональных
		стандартах.
		Тип, реализующий метод ToString интерфейса IFormattalle, определяет допустимые варианты форматирования. 
		Если переданная строка форматирования неприемлема, тип должен генерировать исключение 
		System.FormatException. 
		Format:
		![](images/string_formatters.png)
		formatProvider:
		По умолчанию форматирование выполняется с учетом региональных стандартов, связанных с 
		вызывающим потоком. Это свойственно методу ToString без параметров и методу ToString интерфейса 
		IFormattalle со значением null в качестве formatProvider.
		При форматировании числа метод ToString 'анализирует' параметр formatProvider. Если это null, 
		метод ToString определяет региональные стандарты, связанные с вызывающим потоком, считывая 
		свойство System.Threading.Thread.CurrentThread.CurrentCulture. Оно возвращает экземпляр типа 
		System.Globalization.CultureInfo
	4) Основная идея применения интерфейса IFormatProvider такова: реализация 
		этого интерфейса означает, что экземпляр типа 'знает', как обеспечить учет 
		региональных стандартов при форматировании, а региональные стандарты, 
		связанные с вызывающим потоком, игнорируются.
	5) Тип System.Globalization. CultureInfo - один из немногих определенных 
		в FCL типов, в которых реализован интерфейс IFormatProvider. Если нужно 
		форматировать строку, скажем, для Вьетнама, следует создать объект Culturelnfo 
		и передать его ToString как параметр formatProvider. Вот как формируют строкавое представление 
		числа Decimal в формате вьетнамской валюты:
		```
		Decimal price = 123.54M;
		String s = price.ToString("C", new CultureInfo("vi-VN"));
		```
	6) Кстати, чтобы получить строку для объекта, который не отформатирован 
		в соответствии с определенными региональными стандартами, вызовите статическое свойство 
		InvariantCulture класса System.Globalization.CultureInfo и 
		передайте возвращенный объект как параметр formatProvider методу ToString:
		```
		Decimal price = 123.54M;
		String s = price.ToString("C", CultureInfo.InvariantCulture);
		```
	7) Чаще всего при получении строкового представления объекта вызывающая 
		программа задает только формат, довольствуясь региональными стандартами, 
		связанными с вызывающим потоком. Поэтому обычно мы вызываем ToString, 
		передавая строку форматирования и nu1 1 как параметр formatProvider. Для 
		упрощения работы с ToString во многие типы включены перегруженные версии 
		метода ToString. Например, у типа Decima1 есть четыре перегруженных метода 
		ToString:
		![](images/decimal_tostring_overloads.png)
	8) Форматирование нескольких объектов в одну строку
		

Вопросы:
1) Зачем строки сделали неизменяемыми (Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками?)
2) Ordinal, cultural comparison
3) разобраться с тем что вообще написано в этой хуйне в 9 пункте
4) Интернирование строк


Дальше посмотреть:
1) System.Enviroment
2) класс является изолированным
3) StringBuilder реализация, что происходит после вызова ToString, сравнить что изменилось с тех пор как 
Рихтех писал про SB