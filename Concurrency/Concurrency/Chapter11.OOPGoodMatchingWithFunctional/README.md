# Глава 11. ООП, хорошо сочетающееся с функциональным программированием

Асинхронное программирование близко к функциональному программированию.

Главное преимущество async заключается в том, что вы можете мыслить 
процедурными категориями, но программировать асинхронно. Это существенно 
упрощает написание и понимание асинхронных методов.

Во внутренней реализации асинхронный код остается функциональным по 
своей природе, и это создает некоторые проблемы, когда разработчики 
пытаются втиснуть async-методы в классические объектно-ориентированные архитектуры

В рецептах этой главы рассматриваются проблемные
области, в которых асинхронный код конфликтует с объектно-ориентированным программированием.

Эти проблемные области становятся особенно заметны при преобразовании существующей ООП-кодовой базы 
в кодовую базу, хорошо сочетающуюся с async.

# 11.1. Асинхронные интерфейсы и наследование

## Задача

В интерфейсе или базовом классе метода имеется метод, который требуется сделать асинхронным.

## Решение

Вспомните, что ожидание допускают типы, а не методы. Вы можете использовать await
с объектом Task, возвращенным методом, независимо 
от того, был метод реализован с ключевым словом async или нет. Таким 
образом, интерфейс или абстрактный метод может просто вернуть Task
(или Task<T>), а возвращаемое значение этого метода может допускать 
ожидание.

```
interface IMyAsyncInterface
{
	Task<int> CountBytesAsync(HttpClient client, string url);
}
```

Этот паттерн работает и с абстрактными методами базовых классов.

Асинхронная сигнатура метода означает лишь то, что реализация может
быть асинхронной. Фактическая реализация может быть синхронной, если 
нет реальной асинхронной работы, которую нужно было бы выполнять. 
Например, тестовая заглушка может реализовать тот же интерфейс (без 
async), используя нечто вроде FromResult:

```
class MyAsyncClassStub : IMyAsyncInterface
{
	public Task<int> CountBytesAsync(HttpClient client, string url)
	{
		return Task.FromResult(13);
	}
}
```

## Пояснение

На момент написания книги async и await еще только набирали обороты. 
По мере того как асинхронные методы становятся все более распространенными, 
асинхронные методы интерфейсов и базовых классов встречаются все чаще. Работать 
с ними не так уж сложно, если помнить, что 
ожидание должно применяться к возвращаемому типу (а не к методу), 
а определение асинхронного метода может быть реализовано асинхронно 
или синхронно.


# 11.2. Асинхронное конструирование: фабрики

## Задача

Вы программируете тип, который требует выполнения некоторой асинхронной работы в конструкторе.

## Решение

Конструкторе не могут объявляться с async; кроме того, они не могут содержать ключевого слова await. 
Конечно, использование await в конструкторе могло бы быть полезным, но это привело бы к существенному изменению
языка C#.

ОДна из возможностей - использовать конструктор в паре с инициализирующим async-методом, чтобы тип использовался
следующим образом:

```
var instance = new MyAsyncClass();
await instance.InitializeAsync();
```

У этого решения есть проблемы: разработчик может забыть вызвать второй метод, а экземпляр не может использоваться
сразу же после выполнения конструктора.

Вот более качественное решение, которое основано на применении паттерна асинхронного фабричного метода:

```
class MyAsyncClass
{
	private MyAsyncClass()
	{
	}

	private async Task<MyAsyncClass> InitializeAsync()
	{
		await Task.Delay(TimeSpan.FromSeconds(1));
		return this;
	}

	public static Task<MyAsyncClass> CreateAsync()
	{
		var result = new MyAsyncClass();
		return result.InitializeAsync();
	}
}
```

В другом коде, вызов будет выглядеть следующим образом:

```
MyAsyncClass instance = await MyAsyncClass.CreateAsync();
```

## Пояснение

И в этом методе есть проблема. К сожалению, ни одна заметная библиотека внедрения зависимостей не работает 
с async-кодом. Если вы окажетесь в одной из таких ситуаций, существует пара альтернатив.

Если создаваемый экземпляр в действительности является общим ресурсом, можно 
использовать асинхронную отложенную инициализацию, рассмотренную в рецепте 14.1. 
В противном случае можно воспользоваться 
паттерном асинхронной инициализации, описанным в рецепте 11.3.

```
class MyAsyncClass
{
	public MyAsyncClass()
	{
		InitializeAsync();
	}

	// ПЛОХОЙ КОД!!
	private async void InitializeAsync()
	{
		await Task.Delay(TimeSpan.FromSeconds(1));
	}
}
```

На первый взгляд решение может показаться разумным: вы получаете 
обычный конструктор, который запускает асинхронную операцию; при 
этом у него есть ряд недостатков, обусловленных использованием async 
void.

Первая проблема заключается в том, что при завершении конструктора экземпляр 
все еще продолжает асинхронно инициализироваться, ине 
существует очевидного способа определить, когда завершится асинхронная 
инициализация. Вторая проблема связана с обработкой ошибок: любые 
исключения, выданные из InitializeAsync, не могут быть перехвачены 
секциями catch, окружающими конструирование объекта.

# 11.3. Асинхронное конструирование: паттерн асинхронной инициализации

## Задача

Вы программируете тип, требующий выполнения некоторой асинхронной работы в его конструкторе, но не можете
воспользоваться паттерном асинхронной фабрики (рецепт 11.2), так как экземпляр создается с применением отражения
(например, библиотеки внедрения зависимостей/инверсии управления, связывания данных, Activator.CreateInstanse и т.д.)

## Решение

225

## Пояснение

# 11.4. Асинхронные свойства

## Задача

## Решение

## Пояснение

# 11.5. async-события

## Задача

## Решение

## Пояснение

# 11.6. Асинхронное освобождение

## Задача

## Решение

## Пояснение