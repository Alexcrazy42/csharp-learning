Вернуться к рецептам с 4

# Тестирование

# 1. Муодльное тестирование async-методов

## Задача

Имеется async-метод, для которого необходимо провести модульное 
тестирование

## Решение

Пример async-модульного теста в MSTest:

```
[TestMethod]
public async Task MyMethodAsync_ReturnsFalse()
{
	var objectUnderTest = ...;
	bool result = await objectUnderTest.MyMethodAsync();
	Assert.IsFalse(result);
}
```

Фреймворк модульного тестирования замечает, что метод имеет возвращаемый тип Task, и ожидает
завершения задачи перед тем, как сделать отметку о прохождении или отказе теста.

Если фреймворк не поддерживает модульные тесты async Task, то ему придется помочь с ожиданием
тестируемой асинхронной операции.

Один из вариантов - использовать GetAwaiter().GetResult() для синхронного блокирования
по задаче; если после этого использовать GetAwaiter().GetResult() вместе Wait(), это позволит
избежать обертки AggregateException, когда в задаче произойдет исключение. ОДнако я предпочитаю
использовать тип AsyncContext из Nuget пакета Nito.AsyncEx:

```
[TestMethod]
public void MyMethodAsync_ReturnsFalse()
{
	AsyncContext.Run(async () =>
	{
		var objectUnderTest = ...;
		bool result = await objectUnderTest.MyMethodAsync();
		Assert.IsFalse(result);
	});
}
```

AsyncContext.Run ожидает завершения всех асинхронных методов.

## Пояснение

Мокинг асинхронных зависимостей на первый взгляд кажется немного неуклежим. Всегда желательно
хотя бы проверить, как ваши методы реагируют на синхронный успех (имитация с Task.FromResult), 
синхронные ошибки (имитация Task.FromException) и асинхронный успех (имитация Task.Yield и
возвращаемым значением).

Task.Yield может исползоваться для принудительного применения асинхронного поведения и задействуется
прежде всего при модульном тестировании

```
interface IMyInterface
{
	Task<int> SomethingAsync();
}
class SynchronousSuccess : IMyInterface
{
	public Task<int> SomethingAsync()
	{
		return Task.FromResult(13);
	}
}

class SynchronousError : IMyInterface
{
	public Task<int> SomethingAsync()
	{
		return Task.FromException<int>(new InvalidOperationException());
	}
}

class AsynchronousSuccess : IMyInterface
{
	public async Task<int> SomethingAsync()
	{
		await Task.Yield(); // Принудительно включить асинхронное поведение.
		return 13;
	}
}
```

При тестировании асинхронного кода взаимоблокировки и состояния гонки могут проявляться чаще, 
чем при тестировании синхронного кода. Автор считает полезным назначением тайм-аута на уровне
тестов.

В Visual Studio можно добавить в решение файл тестовых настроек, в котором можно задавать 
тайм-ауты для отдельных тестов. Значение по умолчанию достаточно велико; обычно автор использует 
двухсекундный тайм-аут уровня тестов.

# 2. Асинхронные методы модульного тестирования, которые не должны проходить

## Задача

Требуется написать модульный тест, который проверяет конкретный 
отказ метода async Task.

## Решение

Если вы занимаетесь разработкой для настольных компьютеров или сервером, MSTest подддерживает 
тестирование на отказ с помощью обычного класса ExpectedExceptionAttributeL

```
// Использовать это решение не рекомендуется; см. ниже.
[TestMethod]
[ExpectedException(typeof(DivideByZeroException))]
public async Task Divide_WhenDenominatorIsZero_ThrowsDivideByZero()
{
	await MyClass.DivideAsync(4, 0);
}
```

Тем не менее это не лучшее решение: ExpectedException обычно является 
признаком плохого дизайна. Ожидаемое исключение может быть выдано 
любым из методов, вызванных вашим методом модульного тестирования.
Нужно проверять, что исключение было выдано конкретным фрагментом кода,
а не модульным тестом в целом.

**Пример из xUnit:**

```
[Fact]
public async Task Divide_WhenDenominatorIsZero_ThrowsDivideByZero()
{
	await Assert.ThrowsAsync<DivideByZeroException>(async () =>
	{
		await MyClass.DivideAsync(4, 0);
	});
}
```

Но не все фрейморвки поддерживают эквивалентных async-совместимыъ конструкций ThrowsAsync.

Можно написать свой аналог, как представлено в примере


## Пояснение

Тестирование обработки ошибок не менее важно, чем тестирование успешных сценариев.

Но автор не рекомендует использовать ExpectedException. Лучше протестировать выдачу исключения
в конкретной точке вместо того, чтобы тестировать исключение в любом момент во время теста.

# 3. Модульное тестирование методов async void

## Задача

Имеется метод async void, для которого необходимо написать модульные 
тесты

## Решение

Такой ситуации нужно избегать всеми силами. Если метод async void
можно преобразовать в метод async Task — сделайте это.

Если же ваш метод *обязан быть* методом async void (например, для соответствия сигнатуре метода
интерфейса), рассмотрите возможность написания двух методов: метода async Task, содержащего всю
логику, и обертки async void, которая просто вызывает метод async Task и ожидает результата.

Метод async void удовлетворяет требованиям архитектуры, тогда как метод async Task (со всей логикой)
пригоден для тестирования.

Если изменить метод невозможно и вы вынуждены заниматься модульным тестированием метода 
async void, это тоже возможно. Используйте класс AsyncContext из библиотеки Nito.AsyncEx:

```
// Не рекомендуется; см. далее в этом разделе.
[TestMethod]
public void MyMethodAsync_DoesNotThrow()
{
	AsyncContext.Run(() =>
	{
	var objectUnderTest = new Sut(); // ...;
	objectUnderTest.MyVoidMethodAsync();
	});
}
```

Тип AsyncContext ожидает завершения всех асинхронных операций (включая методы async void) 
и распространяет выданные ими исключения

## Пояснение

Одно из важнейших правил async-кода — по возможности избегать async 
void. Настоятельно рекомендую провести рефакторинг кода, а не использовать AsyncContext 
для модульного тестирования методов async void

# 4. Модульное тестирование сетей потоков данных

## Задача



## Решение



## Пояснение


# 5. Модульное тестирование наблюдаемых объектов System.Reactive

## Задача



## Решение



## Пояснение


# 6. Модульное тестирование наблюдаемых объектов System.Reactive с использованием имитации планирования

## Задача



## Решение



## Пояснение


