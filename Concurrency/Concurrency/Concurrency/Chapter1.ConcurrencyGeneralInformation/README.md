# Конкрентность: общие сведения

**Конкурентность** - выполнение сразу нескольких действий в одно и то же время

**Примеры**: UI реагирует на ввода данных пользователем во время записи в БД. Серверные приложения
используют конкуретность для реакции на второй запрос в ходе завершения первого запроса.

**Многопоточность** - форма конкуретности, использующая несколько программных потоков выполнения

Непосредственное использование низкоуровневых видов многопточности в соврременных приложениях
практически не имеет смысла; высокоуровенвые абстракции превосходят многопоточные средства старой
школы как по мощи, так и по эффективности. Поэтому ни в одном из рецептов этой книги не используются
типы **Thread** или **BackgroundWorker**.

Многопоточность продолжает жить в **пулах потоков** - полезном месте для постановки рабочих операций
в очередь, которое автоматически регулируется в зависимости от нагрузки.

**Параллельность** - выполнение большого объема работы за счет распределения ее между несколькими
потоками, выполняемыми одновременно.

Параллельная обработка (или параллельное программирование) использует 
многопоточность для максимально эффективного использования многоядерных процессоров

Параллельная обработка является одной из разновидностей многопоточности, а многопоточность является 
одной из разновидностей конкурентности.

**Асинхронность** - разновидность конкурентности, использующая обещания или обратные вызовы для 
предотвращения создания лишних потоков.

**Обещание (future/promise), или преднамеченный тип** - тип представляющий некоторую операцию, которая
завершится в будущем. Примеры современных типов обещаний в .NET - Task и Task<TResult>. Более старые
асинхронные API используют обратные вызовы или события вместо обещаний.

А асинхронном программировании центральное место занимается идея **асинхронной операции** - некоторой 
запущенной операции, которая завершится через некоторое время. ХОтя операция продолжается, она не блокирует
основной поток; поток который запустил операцию, свободен для выполнения другой работы. Когда операция
завершится, она уведомляет свое обещание или активизирует обратный вызов или событие, чтобы приложение
узнало о завершении.

**Реактивное программирование** - декларативный стиль программирования, при котором приложение
реагирует на события.

**Реактивное программирование** - еще одна форма конкурентности. Асинхронность подразумевает, что 
приложение запускает операцию, которая завершится в будущем. Реактивное программирование тесно связано 
с асинхронным программированием, но в его основе лежат асинхронные события вместо асинхронных операций.
Асинхронные события согут не иметь фактического "начала", могут происходить в любое время и могут
инициироваться многократно. Один из примеров такого рода - ввода данных пользователем.

Если рассматривать приложение как огромный конечный автомат, поведение приложения может быть описано 
как реакция на серию событий с обновлением своего состояния на каждое событие. Реактивное программирование
не обязательно конкурентно, но оно тесно связано с конкуретностью.

## Введение в асинхронное программирование

Преимущества асинхронного программирования:

1. Для GUI - быстрый отклик. Асинхронное программирование освобождает UI-поток; 
это позволяет графическому приложению сохранить высокую скорость 
отклика на ввод пользователя

2. Для серверных приложений - возможность масштабируемости. Асинхронность освобождает потоки запросов 
и позволет серверу использовать свои потоки для обслуживания большего количества запросов.

**Ключевое слово async** добавляется в объявлении метода и имеет двойное назначение: оно разрешает
использование ключевого слова await внутри этого метода и приказывает компилятору сгенерировать для 
этого метода конечный автомат по аналогии с тем, как работает yield return. Метод с ключевым словом async
может вернуть Task<TResult>, Task, IAsyncEnumerator<T> или IAsyncEnumerable<T>.

**Рассмотрим пример**

```
async Task DoSomethingAsync()
{
	int value = 13;

	// Асинхронно ожидать 1 секунду.
	await Task.Delay(TimeSpan.FromSeconds(1));
	
	value *= 2;

	// Асинхронно ожидать 1 секунду.
	await Task.Delay(TimeSpan.FromSeconds(1));
	Trace.WriteLine(value);
}
```

async метод начинает выполняться синхронно. Внутри метода команда await выполняет асинхронное ожидание 
по своему аргументу. Сначала она проверяет, завершилась ли операций: если да, то метода продолжает
выполняться (синхронно). В противном случае await приостанавливает async метода и возвращает 
незавершенную задачу. Когда операция завершится позднее, async-метода продолжает выполнение.

async-метод может рассматриваться как состоящий из нескольких синхронных частей, разделенных 
командами await. Первая синхронная часть выполняется в потоке, который вызвал метод, но где 
выполняются другие синхронные части? Ответ на этот вопрос не прост.

При выполнении await для задачи (самый распространенный сценарий) 
в момент, когда await решает приостановить метод, сохраняется контекст. 
Это текущий объект SynchronizationContext, если только он не равен 
null (в этом случае контекстом является текущий объект TaskScheduler). 
Метод возобновляет выполнение в этом сохраненном контексте. Обычно 
контекстом является UI-контекст (для UI-потока) или контекст пула 
потоков (в большинстве других ситуаций). Если вы пишете приложение 
ASP.NET Classic (до Core), то контекстом также может быть контекст 
запроса ASP.NET. В ASP.NET Core используется контекст пула потоков 
вместо специального контекста запроса.

Таким образом, в приведенном коде все синхронные части пытаются 
возобновить продолжение в исходном контексте. Если вызвать метод 
DoSomethingAsync из UI-потока, каждая из его синхронных частей будет 
выполняться в этом UI-потоке, но если вызвать его из потока из пула 
потоков, то каждая из синхронных частей будет выполняться в любом 
потоке из пула потоков.

### ConfigureAwait

Чтобы обойти это поведение по умолчанию, можно выполнить await по 
результату метода расширения ConfigureAwait с передачей false в параметре 
continueOnCapturedContext:

```await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false);```

Ключевое слово await не ограничивается работой с задачами, оно может 
работать с любым объектом, допускающим ожидание (awaitable), построенным 
по определенной схеме. Например, библиотека Base Class Library 
включает тип ValueTask<T>, который сокращает затраты памяти, если 
результат в основном является синхронным; например, если результат 
может быть прочитан из кэша в памяти. Тип ValueTask<T> не преобразуется 
в Task<T> напрямую, но строится по схеме, допускающей ожидание, поэтому 
может использоваться с await. Также существуют другие примеры, 
и вы можете строить свои собственные, но в большинстве случаев await
получает Task или Task<TResult>.

### Создание Task

Существует два основных способа создания экземпляров Task. Некоторые 
задачи представляют реальный код, который должен выполняться процессором; 
такие вычислительные задачи должны создаваться вызовом Task.
Run (или TaskFactory.StartNew, если они должны выполняться по определенному расписанию). 
Другие задачи представляют уведомления; такие 
задачи, основанные на событиях, создаются TaskCompletionSource<TResult>
(или одной из сокращенных форм). Большинство задач ввода/вывода 
использует TaskCompletionSource<TResult>.

### Обработка ошибок

```
async Task TrySomethingAsync()
{
	try
	{
		await PossibleExceptionAsync();
	}
	catch (NotSupportedException ex)
	{
		LogException(ex);
		throw;
	}
}
```

Метод PossibleExceptionAsync может выдать исключение NotSupportedException, но TrySomethingAsync 
может перехватить исключение естественным образом. Трассировка стека перехваченного исключения сохраняется
без исскуственной упаковки в TargetInvocationException или AggregateException.

Когда async-метод выдает (или распространяет) исключение, оно помещается в возвращаемый объект 
Task, и задача Task завершается. При 
выполнении await для этого объекта Task оператор await получает это 
исключение и (заново) выдает его так, что исходная трассировка стека 
сохраняется. Такой код, как в примере ниже, будет работать так, как ожидается, если
PossibleExceptionAsync является async-методом.

```
async Task TrySomethingAsync()
{
	// Исключение попадает в Task, а не выдается напрямую.
	Task task = PossibleExceptionAsync();
	
	try
	{
		// Исключение из Task exception будет выдано здесь, в точке await.
		await task;
	}
	catch (NotSupportedException ex)
	{
		LogException(ex);
		throw;
	}
}
```

## Борьба с Task.Wait, Task<TResult>.Result, GetAwaiter().GetResult()

Относительно async-методов существует одна важная рекомендация: 
при использовании ключевого слова async лучше позволить ему распространяться в вашем коде. 
Если вы вызываете async-метод, следует 
(в конечном итоге) выполнить await для возвращаемой им задачи. 
Боритесь с искушением вызвать Task.Wait, Task<TResult>.Result или 
GetAwaiter().GetResult(): это приведет к взаимоблокировке (deadlock). 

**Рассмотрим следующий метод:**

```
async Task WaitAsync()
{
	// await сохранит текущий контекст ...
	await Task.Delay(TimeSpan.FromSeconds(1));
	// ... и попытается возобновить метод в этой точке с этим контекстом.
}

void Deadlock()
{
	// Начать задержку.
	Task task = WaitAsync();
	// Синхронное блокирование с ожиданием завершения async-метода.
	task.Wait();
}
```

Код в этом примере создат взаимоблокировку при вызове из UI-контекста или контекста ASP.NET Classic, потому
что оба эти контекста допускают выполнение только одного потока. Deadlock вызовет WaitAsync, что приводит
к началу задержки. Затем Deadlock (синхронно) ожидает завершения этого метода с блокированием контекстного
потока. Когда задержка завершится, await пытается возобновить WaitAsync в сохранненом контексте, но не 
сможет, так как в контексте уже есть заблокированный поток, а контекст допускает только один поток в 
любой момент времени. 

Взаимоблокировку можно предотвратить двумя способами: использовать ConfigureAwait(false) в WaitAsync 
(что заставляет await игнорировать его контекст) или же использовать await с вызовом WaitAsync 
(что превращает Deadlock в async-метод)

## Введение в параллельное программирование

25