# Глава 11. События
Если в типе определен член-событие, то этот типе может уведомлять другие объекты о некоторых ситуациях, которые могут случиться
Тип, в котором определены события, как минимум поддерживает:
1) регистрацию статического метода типа или экземплярнога метода объекта, заинтересованного в получении уведомления о событии
2) отмену регистрации статического метода типа или экземплярнога метода объекта, получающего уведомления о событии
3) уведомление зарегистрированных методов о том, что событие произошло

Модель событий CLR основана на делегатах (delegate)
Делегаты позволяют обращаться к методам обратного вызова, не нарушаяя безопасность типов. 
Метод обратного вызова (callback метод) - это механизм, позволяющий объекту получать уведомеления, на которые он подписался

1) Разработка типа, поддерживающего событие
	1.1) Этап 1 - определение типа для хранения всей доп. информации, передаваемой получателям уведомления о событии
	1.2) Этап 2 - определение члена-события в классе отправителя
	1.3) Этап 3 - определение метода, ответственного за уведомления зарегистрированных объектов о событии
		В соответствии с соглашением в классе должен быть виртуальные защищенный метод, вызываемый из когда класса и его потомков при возникновении события. 
	1.4) Этап 4 - Определение метода, транслирующего входную информацию в желаемое событие

	1.5) Когда мы создаем событие - генерируется 3 конструкции:  
		1) закрытое поле делегата, инициализированное значение null
		2) Открытый метод add_Xxx (где Xxx - это имя события)
		3) Открытый метод remove_Xxx (где Xxx - это имя события)
		Система событий построена на делегатах - subsribers подписываются на события другого типа, через созданный компилятором метод add_Xxx, 
		в котором определена логика добавления делегата подписчика на события, потом при наступлении этого события вызывается этот делегат
		Также есть метод remove_Xxx - он удаляет подписчика, удаляя его делегат из списка
		Если вызвать remove_Xxx для делегата, который не был добавлен - исключения не будет
		Помимо генерации этих трех конструкций компиляторы генерируют запись с определением события и помещает ее в метаданные управляемого модуля.
		Эта запись содержит ряд флагов и базовый тип-делегат, а также ссылки на методы аксессоры add и remove. Эта информация нужна просто для того, чтобы 
		очертить связь между абстрактным понятием "событие" и его методами-аксессорами. Эти метаданные могут использовать компиляторы и другие инструметры, и конечно же, 
		эти сведения можно получить при помощи класса System.Reflection.EventInfo. Однако сама среда CLR эти метаданные не использует и во время выполнения трубует лишь методы аксессоры

2) Создание типа, отслеживающего событие
	1) Компилятор обладает встроенный поддержкой событий. Он транслирует такой код: mm.NewMailEvent += FaxMsg в код, регистрирующий объект
		для получения уведомлений о событии: mm.add_NewMailEvent(new EventHandler<NewMailEventArgs>(this.FaxMsg))
		Компилятор вызывает метод add_Xxx объекта издателя события, передавая ему новый делегат. В этом можно убедиться скомпилировав код и затем изучить IL-код через ILDasm.exe.
		Компилятор вызывает метод remove_Xxx объекта издателя события, когда используется оператор -= к EventHandler

3) Явное управление регистрацией событий
	Тут описано каким образом csc позволяет разработчикам явно управлять регистрацией событий, контролировать добавление и удаление методов, манипулировать делегатами обратных вызовов.
	Для эффективного использования делегатов события каждый объект, применяющий события, содержится в главной коллекции (обычно это словарь) с несколькими
	типами идентификаторов событий в качестве ключей и списком делегатов в качестве значений. При регистрации событий идентификатор события ищется в коллекции. 
	Если идентификатор события найден, то новый делегат добавляется в список делегатов для этого события. Если идентификатор события не найден, то он добавляется 
	к делегатам. Когда наступает событие, идентификатор события ищется в коллекции. Если в коллекции нет записи для него, то оно не регистрирутся и делегаты и не вызываются. 
	Если идентификатор события находится в коллекции, то вызывается список делегатов, ассоциированных с этим идентификатором события. 

