# Глава 13. Интерфейсы

CLR не поддерживает множественное наследование от классов, но поддерживает от интерфейсов. 

1) Наследование в классах и интерфейсах
	1) Любой производный от Object класс наследует следующее:
		Сигнатуры методов. Это позволяет коду считать, что он оперирует экземпляром класса Object, тогда как на самом деле он 
		работает с экземпляром какого-либо другого класса
		Реализацию этих методов. Разработчик может определить класс, производный от Object, не реализуя методы класса Object вручную
	2) Одна из замечательных особенностей наследования классов - возможность подставлять экземпляры производиого типа в любые контексты, в которых 
		выступают экземпляры базового типа. Аналогично, наследование интерфейсов позволяет подставлять экземпляры типа, реализующего интерфейс, 
		во все контексты, где требуются экземпляры указанного интерфейсного типа.

2) Определение интерфейсов
	1) Интерфейс - именованный набор сигнатур методов.
		В них можно определять события, свойства - без параметров или с ними (индексаторы). В интерфейса нельзя определять методы-конструкторы и 
		экземплярные поля
	2) Хотя CLR допускает наличие в интерфейсах статических методов, полей и конструкторов, а также констант, СLS-совместимый интерфейс не может 
		иметь подобных статических членов, поскольку некоторые языки не поддерживают их определение или обращение к ним. На самом деле, С# не 
		позволяет определить в интерфейсе статические члены.
	3) С точки зрения CLR, определение интерфейса - почти то же, что и определение типа. То есть CLR определяет внутреннюю структуру данных 
		для объекта интерфейсного типа, а для обращения к различным членам интерфейса может использовать отражение

3) Наследование интерфейсов
	1) Компилятор С# требует, чтобы метод, реализующий интерфейс, отмечался модификатором publiс
	2) CLR требует, чтобы интерфейсные методы были виртуальными. Если метод явно не определен в коде как виртуальный, компилятор сделает его
		таковым и, вдобавок, изолированным. Это не позволяет производному классу переопределять интерфейсные методы. Если явно задать метод как
		виртуальный, компилятор сделает его таковым и оставит неизолированным, что предоставит производному классу возможность переопределить 
		интерфейсные методы
	3) Производный класс не в состоянии переопределять интерфейсные методы, объявленные изолированными, но может повторно унаследовать тот же 
		интерфейс и предоставить собственную реализацию его методов. При вызове интерфейсного метода объекта вызывается реализация, 
		связанная с типом самого объекта

3) Подробнее о вызовах интерфейсных методов
	1) CLR допускает определение поля, параметры или локальных переменных, имеющих интерфейсный тип. Используя переменную интерфейсного типа, 
		можно вызывать методы, определенные эти интерфейсом, а также методы, определенные в типе Object
	2) Как и ссылочный тип, значимый тип может реализовать несколько (или нуль) интерфейсов. Но при приведении значимого типа к интерфейсному
		этот экземпляр надо упаковать, потому что переменная интерфейса является ссылкой, которая должна указывать на объект в куче, чтобы среда
		CLR могла проверить указатель и точно выяснить тип объекта. Затем при вызове метода интерфейса с упакованным значимым типом CLR использует
		указатель, чтобы найти таблицу методов типа объекта и вызвать нужный методю

4) Явные и неявные реализации интерфейсных типов (что происходит за кулисами)
	1) Когда тип загружается в CLR, для типа создается и инициализируется таблица методов. Она содержит по одной записи для каждого 
		нового, представляемого только этим типом метода, а также записи для всех методов, унаследованных типом. Унаследованные методы 
		включают методы, определенные в базовых типах иерархии наследования, а также все методы, определенные интерфейсными типамиэ
	2) 
	```
	internal sealed class SimpleType : IDisposable { public void Dispose() { Console.WriteLine("Dispose"); } }
	```
	Таблица методов этого типа содержит записи, в которых представлены:
	- все экземплярные методы, определенные в типе Object и неявно унаследованные от этого базового класса
	- все интерфейсные методы, определенные в явно унаследованном интерфейсе IDisposable
	- новый метод Dispose, появившийся в типе SimpleType
	Чтобы было проще, csc считает, что появившийся в типе SimpleType метод Dispose является реализацией метода Dispose из интерфейса IDisposable. 
	Компилятор вправе так считать, потому что метод открытый и сигнатура совпадает с нужной. Если бы новый метод был помечен, как виртуальные 
	компилятор все равно бы сопоставил этот метод одноименному интерфейсному методу.
	Сопоставляя новый метод интерфейсному методу, csc генерирует метаданные, указывающие на то, что обе записи в таблице методов типа SimpleType
	должны ссылаться на одну реализацию.
	3) Если в C# перед именем метода ставить имя интерфейса, в котором определен этот метод, то мы создаем явную реализацию интерфейсного 
	метода (Explicit Interface Method Implementation, EIMI). Когда в C# определяется явный интерфейсный метод, нельзя указывать область доступа
	(открытый или закрытый). Однако когда компилятор создается методанные для метода, его область доступа оказываается закрытой (private), что 
	запрещает любому коду использовать экземпляр класса, просто вызвав интерфейсный метод. Единственный способ вызвать интерфейсный метод - 
	обратиться через переменную этого интерфейсного типа
	EIMI-метод не может быть виртуальным, а значит, его нельзя переопределить. Это происходит потому, что EIMI-метод в действительности не является
	частью объектной модели типа. Это средство подключения интерейса (набора вариантов поведения или методов) к типу, которое не делает эти 
	варианты поведения/методы очевидными.

5) Обобщенные интерфейсы
	1) Обобщенные интерфейсы значительно снижают время компиляции. Некоторые интерфейсы определяют методы, которые принимают или возвращают параметры
	типа Object. При вызове в коде методов таких интерфейсов можно передать ссылку на экземпляр любого типа. Однако обычно это не требуется.
	2) Можно задать ограничение на тип с помощью обобщенного интерфейса
		При использовании обобщенных интерфейсов происходит меньше операций упаковки
		При написании кода нужно использовать обобщенные версии интерфейсов. Необобщенные версии оставлены в FCL лишь для обратной совместимости
		с кодом, написанным до того как в .NET Framework появилась поддержка обобщений. Необобщенные версии также предоставляют пользователям механизм 
		работы с данными более универсальным, но и менее безопасным образом
		Иногда, при необходимости интеграции с другим кодом, вам придется реализовывать необобщенный интерфейс просто потому, что необобщенной
		версии не существует. В этом случае, если любой из интерфейсных методов принимает или возвращает тип Object, теряется контроль типов
		при компиляции, и значимые типы должны упаковываться.
	3) Третьим преимуществом обобщенных интерфейсов является то, что класс можно реализовать один интерфейс многократно, просто используя параметры
	различного типа.

6) Обобщения и ограничения интерфейса
	1) Первое преимущество - позволение нам диктовать условия вызываемому коду на те параметры, которые нам передают, и 
		в случае несоответствия - возникают ошибки компиляции
	2) Второе преимущество - избавление от упаковки при передачи экземпляров значимых типов
	3) Для ограничений интерфейсов csc генерирует определенные IL-инструкции, которые вызывают интерфейсный метод для значимого
	типа напрямую, без упаковки

7) Реализация нескольких интерфейсов с одинаковыми сигнатурами и именами методов
	1) Нужно просто сообщить компилятору какой из методов какого интерфейса мы реализуем этим методом в объекте
		```
		void IWindow.GetMenu { }
		void IRestaraunt.GetMenu { }
		```
	2) Код, в котором вызывается данный объект должен выполнять приведение типа к определенному интерфейсу, чтобы вызвать
		желаемый метод:
		```
		MarioPizzeria mp = new();

		IWindow window = mp;
		window.GetMenu();

		((IRestaraunt)mp).GetMenu();
		```

8) Совершенствование контроля типов за счет явной реализации интерфейсных методов
	1) Часто приходится реализовывать необобщенные интерфейсные, вследствии чего теряется безопасность типов при выполнении
		и выполняется упаковка для значимых типов
		С помощью явной реализации интерфейсных методов можно смягчить ситуацию (EIMI)
	2)  Есть несколько проблем:
		- нежелательная упаковка - внутри метода происходит упаковка для value type
		- отсутствие безопасности типов - компиляция проходит без проблем, но внутри метода может происходить приведение
		и выбрасываться исключение InvalidCastException
		Оба недостатка можно решить с помощью EIMI
	3) EIMI позволяет нам избавиться от этих двух проблем, однако если мы определим переменную интерфейсного типа, то
		потеряем безопасность типов при компиляции и опять вернемся к упаковке
		При приведении экземплярного типа к интерфейсному CLR должна упаковывать экземпляр значимого типа.
	4) К EIMI часто прибегают при реализации таких интерфейсов, как IConvertible, ICollection, IList, IDictionary

9) Опасности явной реализации интерфейсных методов
	1) Исключительно важно понимать, некоторые особенности EIMI, из за которых следует избегать явной реализации 
		интерфейсных методов везде, где это возможно. К счастью, в некоторые случаях вместо EIMI можно обойтись обобщенными
		интерфейсами
	2) С явной реализацией интерфейсных методов связаны некоторые серьезные проблемы:
		- отсутствие документации объясняющей, как именно тип реализует EIMI метод, а также отсутствие IntelliSense-поддержки
		в VS
		- при приведении к интерфейсному типу экземпляры значимого типа упаковываются
		- EIMI нельзя вызвать из производного типа
	3) К явной реализации интерфейсных методов нужно прибегать с осторожностью. Когда разработчики 
		впервые узнали о EIMI, многие посчитали это отличной новостью и стали пытаться выполнять явную реализацию 
		интерфейсных методов везде, где только можно. Не попадайтесь на эту удочку! Явная реализация интерфейсных методов 
		полезна в лишь некоторых случаях, но ее следует избегать везде, где можно обойтись другими средствами.

10) Диллемы разработчика: базовый класс или интерфейс?
	1) Ответ на вопрос, что выбрать для реализации - базовый класс или интерфейс не всегда очевиден.
		Вот несколько правил которые могут помочь сделать этот выбор:
		- Связь потомка с предком. Любой тип может наследовать только одну реализацию. Если производный тип не может 
		ограничиваться функциональностью базового, нужно применять интерфейс, а не базовый тип.
		Значимые типы наследуются от System.ValueType и поэтому не могут наследоваться от произвольного базового класса.
		В этом случае надо определять интерфейс.
		- Простота использования. Разработчику проще определить новый тип, производный от базового, чем создать интерфейс.
		Базовый тип может предоставлять массу функций, и в производном типе потребуется лишь незначительные изменения,
		чтобы изменить его поведение. При создании интерфейса в новом типе придется реализовывать все члены.
		- Четкая реализация. Как бы хъорошо ни был документирован контракт, маловероятно, что он будет реализован 
		абсолютно корректно. По сути, проблемы с COM связаны именно с этим - вот почему некоторые COM-объекты нормально
		работают только с Microsoft Word или Microsoft Internet Explorer. Базовый тип с хорошей реализацией основных 
		функций - прекрасная отправная точка, вам останется лишь изменить лишь отдельные части.
		- Управление версиями. Когда вы добавляете метод к базовому типу, производный тип наследует стандартную реализацию
		этого метода без всяких затрат. Пользовательский исходный код даже не нужно перекомпилировать. Добавление нового
		члена к интерфейсу требует изменения пользовательского исходного кода и его перекомпиляции.
	2) Примеры:
		1) В FCL классы, связанные с потоками данных, построены по принципу наследования реализации.
			System.IO.Stream - это абстрактный базовый класс, предоставляющий множество методов, в том числе Read и Write.
			Другие классы (System .IO.FileStream, System.IO.MemoryStream и System.Net.Sockets.NetworkStream) 
			являются производными от Stream. В Microsoft выбрали такой вид отношений между этими тремя классами и 
			Stream по той причине, что так проще реализовывать конкретные классы. Так, производные классы должны 
			реализовать только операции синхронного ввода-вывода, а способность выполнять асинхронные операции 
			они наследуют от базового класса Stream.
		2) Что касается коллекций, то их специалисты Microsoft реализовали в FCL с помощью интерфейсов. 
			В пространстве имен System.Collections.Generic определено несколько интерфейсов для работы с коллекциями:
			IEnumerable<T>, ICollection, IList, IDictionary и конкретные классы, реализующие эти интерфейсы: Stack, 
			List, Queue, Dictionary
			Такой подходит объясняется тем, что реализация всех классов-коллекций существенно различается. 
			Иначе говоря - у List, Dictionary, Queue, Stack не так много совместно используемого кода.

	3) Также можно определить интерфейс и создать базовый класс, который реализует этот интерфейс. 
		Например, в FCL определен интерфейс IComparer<T>, и любой тип может реализовать этот интерфейс. 
		Кроме того, FCL предоставляет абстрактный базовый класс Comparer<T>, который 
		реализует этот интерфейс (абстрактно) и предлагает некоторые дополнительные 
		методы. Применение обеих возможностей дает большую гибкость, поскольку разработчики теперь могут выбрать из двух
		вариантов наиболее предпочтительный.