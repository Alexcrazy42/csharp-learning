# csharp-learning


вопросы по CLR: 
1) место в сборке, куда могут стекаться различные типы данных (manager, provider)
2) где найти сорцы шарпов, асп, еф, xunit
3) builder как в ef для свойств класса
4) StringComparer
5) намеренно наивная проверка на соответстиве поведению EmailAddressAttribute ASP.NET Core https://github.com/dotnet/runtime/issues/27592
6) связывание с другими языками, технологиями, протокаолами языка C# (http, db api)
7) int[] как key в dict
8) пройти стэк от начала до конца, а не от конца к началу
1) где может понадобиться приведение типов
2) создание своих внешних псевдонимов
3) как следить в runtime за heap и стеком выполнения, искать утечки памяти
4) невиртуальный вызов виртуального метода 
5) call - экземплярный или виртуальный метод 
callvirt - невиртуальный экз метод, виртуальный экз метод
6) как sealed может оптимизировать вызов callvirt, если он действует только на отсечение производных типов, а callvirt менее эффективен, потому что ищет реализую в предках, а не в потомках
7) история языка C#: версии .net и C#, .net framework после создания net core
8) зачем нужны конструкторы типов
9) BeforeFieldInit
10) почему компилятор не подсвечивает когда мы пытаемся сделать преобразование неявно, когда в типе есть только явное преобразование (но в книге говорится об обратном) надо проверить
11) почему язык не поддерживает свойств расширения, событий расширения, операторов расширения
12) реальный пример частичных методов
13) ++n, n++
14) C# индексатор
15) DefaultParameterValue
16) typeof
17) когда реально может понадобиться ref и out
18) for(; fs != null; ContinueProcessingFiles(ref fs)) - это что
1) зачем нужен статический конструктор
2) порядок инициализации полей, и всего такого
3) рабочий набор приложения, домен приложений
4) когда CLR решает, что нужно упаковать объект
5) ссылочный переход из пункта 10 (IList<string> в List<Object> допустим)
6) индексаторы
7) что значит что значимые типы неявно называются изолированными, а еще есть какие то запечатанные классы
1) изолированные методы
2) как в самом языке с помощью каких то интерфейсов можно добавлять всякие конструкции новые
по типу: реализовал IEnumerator и ты можешь использовать foreach для объекта
3) почему EIMI методы нельзя отметить как public
4) почему Рихтер такой уклон делает на то, что если пользовательский код не надо перекомплилировать то это хорошо, 
когда может возникнуть ситуация, когда его не нужно будет перекомпилировать
5) абстрактная реализация интерфейса
1) Зачем строки сделали неизменяемыми (Благодаря неизменности строк отпадает проблема синхронизации потоков при работе со строками?)
2) Ordinal, cultural comparison
3) разобраться с тем что вообще написано в этой хуйне в 9 пункте
4) Интернирование строк
5) Как можно интегрировать внешние объекты с C# классами: NetworkStream например

---------------------------------------------------
что нужно будет потом посмотреть:
1) IEnumerator
2) делегаты: Invoke, Invoker
1) System.IO.Stream, FileStream, MemoryStream, System.Net.Sockets.Network.Stream
2) Windows Forms: Button, CheckBox, ListBox порождаемые от System.Windows.Forms.Control
3) System.Collections.Generic: IEnumerable<T>, ICollection, IList, IDictionary
1) System.Enviroment
2) класс является изолированным
3) StringBuilder реализация, что происходит после вызова ToString, сравнить что изменилось с тех пор как 
Рихтех писал про SB
4) System.Globalization.NumberStyles
5) IO операции и кодировки UTF: BinaryWrite/Reader, StreamWriter/Reader, Encoding, UTF8/32/7Encoding
6) System.Security.Cryptography.CspParameters;
System.Security.Cryptography.X509Certificates.X509Certificate и System.Security.Cryptography.X509Certificates.X509Certificate2
System.Diagnostics.Process и System.Diagnostics.ProcessStartinfo
System.Diagnostics.Eventing.Reader.EventlogSession
SecurePassword
7) Marshal, указатели, unsafe код
8) delegates: action, func
9) typeof, gettype ...


-----------------------------------------
проблемы в C#:
1) 322 страница: невозможно спроетировать математический алгонритм для произвольных числовых типов данных.
Поскольку во время компляции компилятор не знает тип обобщенных типов: в .NET 6 появился интерфейс INumber

---------------------------------------------------------
Появилось еще в C#, после выпуска книги:
1) $""

---------------------------------------
Интересные непонятные вещи из книги:
1) Даже если объект String существует недолго и становится добычей
GC, CLR может не сразу задействовать ранее занятиую этим объектом память (особенно если речь идет об объектах String предыдущих версий), оставляя символы
объекта в памяти, где они могут быть скомпрометированы. 
2) При создании этого объекта его
	код выделяет блок неуправляемой памяти, которая содержит массив символов. Сборщик муcора ничего не знает об этой неуправляемой памяти

Определенные страницы:
старая книга: 
378 страница - StringBuilder.AppendFormat
388 страница - Decoder

новая:
424 - реализация интерфейсов IEnumberable, ICollection и IList
433 - Небезопасный доступ к массивам и массивы фиксированного размера
451 - 463 - делегаты
475 - 483 - атрибуты


----------------------------------------------------------
Что касается самого репозитория:
1) что нужно сделать:
	1) добавить везде ------- и название подтемы, в реадми добавить ссылку на это место
	2) узнать про курсивы, жирный, полужирный текст и сделать это для многих определений

2) Обдумать что включить в репу:
	1) Best Practices для разработчик приложений: время, кодировки, безопасность, производительности
	2) Concurrency
	3) IO-операции
	4) работа с внешними приложениями, интеграция
	5) история развития языка