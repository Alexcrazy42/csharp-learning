# Взаимодействие

# 1. Асинхронные обертки для «Async»-методов с «Completed»-событиями

## Задача

Существует старый асинхронный паттерн, в котором используются методы 
с именами вида ОперацияAsync и события с именами вида 
ОперацияCompleted. Требуется выполнить операцию с использованием 
старого асинхронного паттерна и использовать await с результатом.

Паттерн ОперацияAsync/ОперацияCompleted называется асинхронным паттерном на 
основе событий (EAP, Event-based Asynchronous Pattern). Они будут упакованы в 
метод, возвращающий Task и реализующий асинхронный паттерн на основе Task 
(Task-based Asynchronous Pattern).

## Решение

С помощью типа TaskCompletionSource<TResult> можно создавать обертки для асинхронных операций.
Тип TaskCompletionSource<TResult> управляет Task<TResult> и позволяет завершить задачу в нужный
момент.

В примере опрпделяется метод расширенияд для WebClient, которые загружает строку.
Тип WebClient определяет методы DownloadStringAsync и DownloadStringCompleted. С их помощью
можно определить метод DownloadStringTaskAsync

## Пояснение

Этот конкретный приер не слишком полезен, потому что WebClient уже определяет DownloadStringAsync,
а вы можете использовать более удобную для async версию HttpClient. Тем не менее этот прием
также может использоваться для взаимодействия со старым асинхронным кодом, который еще не был
обновлен для использования Task.

В обычной ситуации TAP-метод для загрузки строк будет называться 
ОперацияAsync (например, DownloadStringAsync); тем не менее эта схема 
формирования имен в данном случае не работает, потому что EAP уже 
определяет метод с таким именем. В таком случае TAP-методу присваивается 
имя ОперацияTaskAsync (например, DownloadStringTaskAsync)

При создании оберток для EAP-методов существует вероятность того, что 
«стартовый» метод может выдать исключение; в предыдущем примере 
это может произойти в DownloadStringAsync. В этом случае необходимо 
решить, разрешить ли исключению распространяться или перехватить 
исключение и вызвать TrySetException. В большинстве случае исключения, 
выданные в этой точке, происходят от ошибок использования, 
поэтому неважно, какой из вариантов вы выберете. Если вы не уверены 
в том, являются ли исключения ошибками использования, рекомендую 
перехватить исключение и вызвать TrySetException.

# 2. Асинхронные обертки для методов «Begin/End»

## Задача

В старом асинхронном паттерне используются пары методов с именами BeginОперация 
и EndОперация, а также объектом IAsyncResult, 
представляющим асинхронную операцию. Имеется операция, реализованная на 
базе старого асинхронного паттерна; требуется организовать 
ее потребление с ключевым словом await

Паттерн «BeginОперация/EndОперация» называется асинхронной 
моделью программирования (APM, Asynchronous Programming Model). 
Он будет упакован вметод, возвращающий Task и реализующий асинхронный 
паттерн на основе Task (Task-based Asynchronous Pattern).

## Решение

Лучший способ упаковки APM - использование одного из методов FromAsync с типом TaskFactory.

FromAsync использует TaskCompletionSource­
<TResult> во внутренней реализации, но при создании обертки для APM 
FromAsync намного проще использовать.

Этот пример определяет метод расширения для WebRequest, который 
отправляет запрос HTTP и получает ответ. Тип WebRequest определяет 
BeginGetResponse и EndGetResponse; вы можете определить метод 
GetResponseAsync в следующем виде:

```
public static Task<WebResponse> GetResponseAsync(this WebRequest client)
{
	return Task<WebResponse>.Factory.FromAsync(client.BeginGetResponse, client.EndGetResponse, null);
}
```

## Пояснение

У FromAsync есть множество перегруженных версий, от которых голова 
идет кругом!

Как правило, лучше всего вызывать FromAsync так, как это сделано в нашем примере. 
Сначала передайте метод BeginОперация (не вызывая его), 
затем передайте метод EndОперация (тоже без вызова). Затем передайте 
все аргументы, которые получает BeginОперация, кроме последних аргументов 
AsyncCallback и object. Наконец, передайте null.

Не вызывайте метод BeginОперация перед вызовом FromAsync. Можно 
вызвать FromAsync с передачей объекта IAsyncOperation, полученного от 
BeginОперация, но при таком вызове FromAsync придется использовать 
менее эффективную реализацию

Возможно, вас интересует, почему в рекомендованном паттерне в конце 
всегда передается null. Метод FromAsync появился вместе с типом Task
в .NET 4.0, перед появлением async. В то время в асинхронных обратных 
вызовах было принято использовать объекты state, а тип Task поддерживает 
эту возможность с помощью своего метода AsyncState. В новом 
паттерне async объекты state уже не нужны, поэтому в параметре state
можно всегда передавать null. В те дни параметр state использовался 
только для предотвращения создания экземпляра замыкания (closure) 
при оптимизации использования памяти.

# 3. Асинхронные обертки для чего угодно

## Задача

Есть нетипичная или нестандартная асинхронная операция или событие. 
Требуется обеспечить их потребление с ключевым словом await

## Решение

Тип TaskCompletionSource<T> может использоваться для построения объектов 
Task<T> в любых сценариях. С помощью TaskCompletionSource<T>
можно завершить задачу тремя разными способами: с успешным результатом, 
с отказом или с отменой.

До появления async компания Microsoft рекомендовала использовать 
два других асинхронных паттерна: APM (рецепт 8.2) и EAP (рецепт 8.1). 
Однако и APM, и EAP были достаточно неудобными, а в некоторых 
ситуациях их было трудно реализовать. По этой причине появилась 
неофициальная схема, основанная на обратных вызовах, с методами 
следующего вида:

```
public interface IMyAsyncHttpService
{
	void DownloadString(Uri address, Action<string, Exception> callback);
}
```

Такие методы следуют соглашению, согласно которому DownloadString
запускает (асинхронную) загрузку, а при завершении callback активизируется 
либо с результатом, либо с исключением. Обычно callback
активизируется в фоновом потоке.

Нестандартные асинхронные методы (вроде приведенного в предыдущем 
примере) могут быть упакованы в TaskCompletionSource<T>, чтобы они 
естественным образом работали с await, как в следующем примере:

```
public static Task<string> DownloadStringAsync(
this IMyAsyncHttpService httpService, Uri address)
{
	var tcs = new TaskCompletionSource<string>();
	httpService.DownloadString(address, (result, exception) =>
	{
		if (exception != null)
			tcs.TrySetException(exception);
		else
			tcs.TrySetResult(result);
	});
	return tcs.Task;
}
```

## Пояснение

Тот же паттерн TaskCompletionSource<T> может использоваться для упаковки 
любых асинхронных методов, какими бы нестандартными они ни были. 
Сначала создайте экземпляр TaskCompletionSource<T>. Затем организуйте 
обратный вызов, чтобы TaskCompletionSource<T> завершал свою задачу 
соответствующим образом. Запустите асинхронную операцию и наконец 
верните объект Task<T>, связанный с этим TaskCompletionSource<T>.

В этом паттерне важно быть уверенным в том, чтобы объект TaskCompletionSource<T> 
всегда завершался. Тщательно продумайте обработку ошибок 
и убедитесь в том, чтобы TaskCompletionSource<T> завершался соответствующим образом. 
В последнем примере исключения явно передаются 
обратному вызову, так что блок catch не понадобится; но некоторые 
нестандартные паттерны могут потребовать перехвата исключений в обратных 
вызовах и включения их в TaskCompletionSource<T>.

# 4. Асинхронные обертки для параллельного кода

## Задача

Существуют параллельные вычисления (создающие нагрузку на процессор), которые 
вы хотите потреблять с помощью await. Обычно бывает нужно, чтобы UI-поток не 
блокировался в ожидании завершения параллельных вычислений.

## Решение

Тип Parallel и Parallel LINQ используют пул потоков для выполнения 
параллельной обработки. При этом вызывающий поток также включается 
в число потоков параллельной обработки, так что при вызове параллельного 
метода из UI-потока пользовательский интерфейс перестанет 
реагировать на действия пользователя до завершения обработки.

Чтобы пользовательский интерфейс не блокировался, упакуйте параллельную обработку в 
Task.Run и примените await к результату:

```
await Task.Run(() => Parallel.ForEach(...));
```

Ключевой аспект этого рецепта заключается в том, что параллельный код 
*включает вызывающий поток* в свой пул потоков, используемых для параллельной обработки. 
Это относится как к Parallel LINQ, так и к классу Parallel.


## Пояснение

Это простой рецепт, но его часто упускают из виду. Используя Task.Run, 
вы перемещаете всю параллельную обработку в пул потоков. Task.Run
возвращает объект Task, представляющий параллельную работу, а UI-поток 
может (асинхронно) ожидать его завершения.

Этот рецепт относится только к UI-коду. На стороне сервера (например, 
ASP.NET) параллельная обработка выполняется редко, потому что параллелизм 
уже обеспечивается серверным хостом. По этой причине код 
на стороне сервера не должен ни выполнять параллельную обработку, ни 
передавать ее пулу потоков.

# 5. Асинхронные обертки для наблюдаемых объектов System.Reactive

## Задача

Имеется наблюдаемый поток, который требуется потреблять с использованием await

## Решение



## Пояснение


# 6. Наблюдаемые обертки для асинхронного кода в System.Reactive

## Задача

Имеется асинхронная операция, которую требуется объединить с функциональностью 
наблюдаемых объектов

## Решение



## Пояснение


# 7. Асинхронные потоки и сети потоков данных

## Задача

В одной части вашего решения используются асинхронные потоки, 
а в другой — сети потоков данных. Требуется организовать передачу 
данных между ними.

## Решение



## Пояснение


# 8. Наблюдаемые объекты System.Reactive Observables и сети потока данных

## Задача

В одной части решения используются наблюдаемые объекты System.
Reactive, в другой — сети потоков данных. Требуется организовать их 
взаимодействие.
И у наблюдаемых объектов System.Reactive, и у сетей потоков данных 
существуют свои области применения, которые перекрываются на концептуальном 
уровне; этот рецепт показывает, как легко организовать их 
совместную работу, чтобы вы могли выбрать наилучший инструмент для 
каждой части работы.

## Решение



## Пояснение


# 9. Преобразование наблюдаемых объектов System.Reactive в асинхронные потоки

## Задача

В отдельной части вашего решения используются наблюдаемые объекты 
System.Reactive. Требуется потреблять их как асинхронные потоки.

## Решение



## Пояснение
