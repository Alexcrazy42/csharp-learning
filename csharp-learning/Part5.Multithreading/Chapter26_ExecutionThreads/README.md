# Глава 26. Потоки исполнения

В этой главе мы познакомимся с потоками исполнения, или просто потоками. Будет идти речь о том,
почему в Windows появилась концепция потоков, о тенденциях развития процессоров, о 
взаимоотношениях потоков CLR и Windows-потоков, о дополнительных затратах ресурсов при 
использовании потоков, о планировании исполнения потоков в Windows, о классах .NET, предоставляющих
доступ к свойствам потоков и многом другом.

В главах 5 части книги объясняется, каким образом Windows взаимодействует с CLR для 
формирования архитектуры потоков. 

## Для чего Windows поддерживает потоки?

На заре компьютерной эры ОС не поддерживали концепцию потоков. Существовал всего один поток,
обслуживающий как код ОС, так и код приложений. В результате этот поток могла блокировать 
большая задача, препятствующая выполнению других. Например, во времена 16 разрядной системы
Windows обычной была ситуация, когда распечатывающее документ приложение приостанавливало 
работу всей машины. ОС и остальные приложения зависали. А если вдруг в приложении возникала 
ошибка, которая приводила к бесконечному циклу, она вообще порождала массу проблем.

Пользователю оставалось только перезагрузить компьютер, нажав кнопку Resrt или выключатель 
питания. Разумеется, пользователи ненавитеди такие ситуации, потому что запущенные 
приложения при этом аварийно завершались, а обрабатываемые данные стирались из памяти. Поэтому
в Microsoft решили, что нужно создать новую ОС, которая должна была быть устойчивой, надежной, 
расширяемой, безопасной и избавленной от большинства недостатков своей предшественницы. 
Ядро этой операционной системы впервые было выпущено в составе Windows NT.

При разработке нового ядра ОС было решено запускать каждый экземпляр приложения в отдельном 
процессе. Процессор называется набор ресурсов, используемый отдельным экземпляром приложения.
Каждому процессу выделяется виртуальное адресное пространство; это гарантирует, что код и 
данные одного процесса будут недоступны для другого. Это делает приложения отказоустойчивыми, 
поскольку при таком подходе один процесс не может повредить код или данные другого. Код 
и данные ядра также недоступны для процессов, а значит, код приложений не в состоянии 
повредить код или данные ОС. Это упрощает работу пользователей. Система также  более 
безопасной, потому что код произвольного приложения не имеет доступа к именам пользователей,
паролям, информации кредитной карты или иным конфиденциальным данным, а которыми 
работают другие приложения или сама операционная система.

А что с ЦП? Что если приложение войдет в бесконечный цикл? Если процессор всего один, приложение
будет выполнять этот бесконечный цикл и не сможет уделять внимание другим операциям. Несмотря
на очевидные преимущества (неповрежденные данные и более высокая степень безопасности),
система, как и ее предшесвенницы, не сможет реагировать на действия конечного пользователя. 
Для решения этой проблемы и были придуманы потоки. Именно поток стал той концепцией, которая
предназначена для виртуализации процессора в Windows. Каждому Windows-процессу выделяется
собственный поток исполнения (который работает как виртуальный процессор). Если код приложения
войдет в бесконечный цикл, то блокируется только связанный с этим кодом процесс, а остальные
процессы (исполняющиеся в собственных потоках) продолжают функционировать!

## Ресурсоемкость потоков

Потоки — замечательное изобретение; ведь именно благодаря им Windows реагирует 
на наши действия даже несмотря на то, что отдельные приложения могут быть заняты 
исполнением длительных заданий. Кроме того, с помощью одного приложения 
(например, диспетчера задач) можно принудительно прекратить работу другого приложения, 
если оно перестает отвечать на запросы. Однако как и любые механизмы 
виртуализации, потоки потребляют дополнительные ресурсы, требуя пространства 
(памяти) и времени (снижая производительность среды исполнения).

Рассмотрим эти проблемы более подробно. Каждый поток состоит из нескольких частей.

1. **Объект ядра потока.** Для каждого созданного в ней потока ОС выделяет и инициализирует 
одну из структур данных. Набор свойств этой структуры описывает поток. Структура содержит также
так называемый контекст потока, то есть блок памяти с набором регистров процессора. На машине
с процессором x86, x64 и ARM контекст занимает около 700, 1240 и 350 байт соответственно.

2. **Блок окружения потока (TEB).** Это место в памяти, выделенное и инициализированное в 
пользовательском режиме (адресное пространство, к которому имеет быстрый доступ код приложений).
Этот блок занимает одну страницу памяти (4Кб для процесоров x86, x64, ARM). Он содержит 
заголовок цепочки обработки исключений. Каждый блок try, в который входит поток, вставляет
свой узел в начало цепочки. Когда поток выходит из блока try, узел из цепочки удаляется. Также
TEB содержит локальное хранилище данных для потока и некоторые структуры данных, используемые
интерфейсом графических устройств (GDI) и графикой OpenGL.

3. ***Стек пользовательского режима.* Применяется для хранения передаваемых в методы локальных
переменных и аргументов. Также он содержит адрес, показывающий, откуда начнет исполнение
поток после того, как текущий метод возвратит управление. По умолчанию на каждый стек пользовательского
режима Windows выделяет 1Мб памяти (а точнее, резервирует 1Мб памяти и добавляет физическую
память по мере необходимости при росте стека)

4. **Стек режима ядра.** Используется, когда код приложения передает аргументы в функцию ОС,
находяющуюся в режиме ядра. Для безопасности Windows копирует все аргументы, передаваемые в 
ядро кодом в пользовательском режиме, из стека потока пользовательского режима в стек
режима ядра. После копирования ядро проверяет значения аргументов. Так как код приложения
не имеет доступа к стеку режима ядра, приложение не в состоянии изменить уже проверенные 
аргументы, и с ними начинает работать код ядра ОС. Кроме того, ядро вызывает собственные
методы и использует стек режима ядра для передачи локальных аргументов, а также для сохранения
локальных переменных функции и обратного адреса. В 32 разрядной вверсии Windows стек режима 
ядра занимает 12Кб, а в 64 разрядной - 24Кб.

5. **Уведомления о создании и завершении потоков.** Политика Windows такова, что если в 
процессе создается поток, то для всех загруженных в этот процесс DLL библиотек вызывается 
метод DllMain и в него передается флаг DLL_THREAD_ATTACH. Соответственно, при завершении
потока этому методу передается уже флаг DLL_THREAD_DETACH. Получая уведомления об этих 
событиях, некоторые DLL-библиотеки выполняются специальные операции инициализации или
очистки для каждого созданного/завершенного в процессе потока. К примеру, DLL библиотека
C-Runtime выделяет место под хранилище локальных состояний потока, необходимое для 
использования потоком функций из указанной библиотеки.

Теперь вы видите, каких затрат времени и памяти стоит создание потока, его 
поддержание в системе и завершение. Но на самом деле ситуация еще хуже из-за 
необходимости переключения контекста (context switching). Компьютер с одним 
процессором может одновременно выполнять только что-то одно. Следовательно, 
операционная система должна распределять физический процессор между всеми 
своими потоками (логическими процессорами).

В произвольный момент времени Windows передает процессору на исполнение 
один поток. Этот поток исполняется в течение некоторого временного интервала, 
иногда называемого тактом (quantum). После завершения этого интервала контекст Windows 
переключается на другой поток. При этом обязательно происходит 
следующее:

1. Значения регистров процессора исполняющегося в данный момент потока сохраняются в 
структуре контекста, которая, распологается в ядре потока.

2. Из набора имеющихся потоков выделяется тот, которому будет передано управление. Если 
выбранный поток принадлежит другому процессу, Windows переключает для процессора виртуальное
адресное пространство. Только после этого возможно выполнение какого-либо кода или 
доступ к каким-либо данным.

3. Значения из выбранной структуры контекста потока загружаются в регистры процессора.

После переключения контекста процессор исполняет выбранный поток, пока 
не истечет выделенное потоку время, после этого снова происходит переключение 
контекста. Windows делает это примерно каждые 30 мс. Никакого выигрыша в производительности 
или потреблении памяти переключение контекстов не дает. Оно 
требуется только для того, чтобы операционная система была надежной и быстро 
реагировала на действия конечных пользователей.

Если поток какого-то приложения зацикливается, Windows его периодически выгружает и передает 
процессору другой поток для исполнения. К примеру, это может быть поток диспетчера задач, 
позволяющий завершить процесс, в котором исполняется зависший поток. Процесс прекращает 
свою работу, теряя несохраненные данные, но остальные процессы в системе продолжают 
функционировать, как ни в чем ни бывало. Пользователю не приходится перезагружать компьютер.
Переключение контекстов приводит к повышению отказоустойчивости, хотя за это приходится платить
снижением производительности.

На самом деле издержки еще выше, чем можно предположить. При переключении контекста 
на другой поток производительность серьезно падает. Пока работа 
ведется с одним потоком, его код и данные находятся в кэше процессора, чтобы 
обращения процессора к оперативной памяти, замедляющие работу, происходили 
реже. Однако новый поток, скорее всего, исполняет совсем другой код и имеет 
доступ к другим данным, которых еще нет в кэше процессора. Значит, прежде чем 
вернуться к прежней скорости работы, процессор вынужден некоторое время обращаться 
к оперативной памяти, наполняя кэш. А примерно через 30 мс происходит 
очередное переключение контекста.

Время переключения контекста зависит от архитектуры процессора и его быстродействия. 
А время заполнения кэша зависит от запущенных в системе приложений, 
размера самого кэша и ряда других факторов. Поэтому оценить, с какими временными 
затратами связано каждое переключение контекста, невозможно. Достаточно просто запомнить, 
что при разработке высокопроизводительных приложений 
и компонентов переключения контекста нужно по возможности избегать.

### ВНИМАНИЕ

Если в конце временного промежутка Windows решает продолжить исполнение уже
исполняемого потока (а не переходить к другому), переключения контекста не происходит. 
Это значительно повышает производительность.

### ВНИМАНИЕ

Потко может самопроизвольно уступить управление до завершения такта, что происходит довольно 
часто, например, если поток ожидает ввода-вывода (клавиатура, мышь, файл, сеть...). Так,
потом приложения Notepad обычно ничего не делает, ожидая ввода данных. При нажатии пользователем
клавиши Windows пробуждает этот поток, чтобы тот обработал данное действие. Обработка занимает 
всего 5мс, после чего вызывается Win32-функция, сообращющая Windows о готовности к обработке
следующего события ввода. Если события ввода отсутствуют, поток переводится в состояние
ожидания (с отказом от оставшейся части такта). В результате поток не будет планироваться на 
исполнение процессором до следующего события ввода. Такой подход повышает производительность
системы, потому что потоки, находяющиеся в состоянии ожидания, не расходуют попусту процессорное
время.

Из всего вышеизложенного можно сделать вывод, что потоки это плохо, так как при переключении 
контекста и уборке мусора снижается производительности и время тратиться впустую. С другой стороны,
без потоков тоже не обойтись, так как именно они обеспечивают в Windows приемлемые показатели
надежности и времени реакции.

Не стоит забывать про многоядерность, которая улучшает масштабируемость системы (способность
выполнения большей работы за меньшее время). Каждому ядру процессора назначается свой поток,
и это ядро организует собственное переключение контекста. ОС следит за тем, чтобы один поток
не планировался одновременно на нескольких ядрах, так как это привело бы к хаосу. 
В настоящее время почти все компьютеры многопроцессорны, но раньше был всего один поток. Для 
этого и были введены потоки. В настоящее время потоки позволяют повысить производительности 
на машинах с несколькими ядрами.

В оставшихся главах этой книги рассматриваются механизмы Windows и CLR, позволяющие эффективно
ответить на вопрос, как при минимальном количестве потоков сохранить работоспособность кода
и каким образом масштабировать код для исполнения на машине с многоядерным процессором.

## Так дальше не пойдет!

Если думать только о производительности, оптимальное чисто потоков на машине должно быть равно
числу установленных на ней процессоров. Причины очевидны: если количество потоков превышает
количество процессоров, начинается переключение контекста. А при наличии одного потока на 
процессор контекстное переключение не требуется, и все потоки исполняются на полной скорости.

Тем не менее при разработке Windows специалисты отдали предпочтение надежности и быстроте
реакции на действия пользователя, а не скорости расчетов и производительности выполнения 
приложений. По мнению Рихтера это правильно, тк вряд ли бы была польза от того, что приложения
по-прежнему могли блокировать работу ОС и других приложений. Именно поэтому каждому процессу 
выделяется свой поток, что повышает надежность система и быстроту реакции.

Рихтер показал, что у него было создано 55 прцоессов, 864 потоков. Также показано было,
что загрузка процессора составляет всего 5%. Это значит, что 95% времени эти 854 потока ничего
не делают, просто занимают память, которая не используется, пока потоки не начинают
исполняться. 

Нужны ли приложениям все эти ничего не делающие потоки? Разумеется, нет!

Процессы создают потоки, которые даже не используют. Они просто ждут, когда же надо будет
начать работу. Знакомясь с Windows, разработчики узнают, что создание процессов в этой ОС -
доростоящая процедура. Создание процесса занимает несколько секунд, требует выделения 
изрядного объема памяти, эту память требуется инициализировать, нужно загрузить с диска
exe и dll файлы. По сравнению с этим создать поток достаточно просто. Поэтому разработчики
вместо процессов предпочитают создавать потоки, множество которых мы и видим перед собой.
Но в сравнениис большинством других системных ресурсов создание потока - не такая уж 
дешевая процедура. И применять их следует осмотрительно и только там, где они действительно
уместны.

Как видите, упомянутые приложения используют потоки не эффективно. Непонятно, зачем эти потоки
вообще существуют в системе. Одно дело - выделить ресурсы для приложения, и совсем другое - 
выделить их и не использовать. Ведь выделение памяти под стеки потоков означает, что ее останется
меньше для более важных данных, например документов пользователя.

А теперь представьте, что процесс запущен в сеансе удаленного рабочего стола одного пользователя,
но у машине на самом деле 100 пользователей. То есть запускается 100 экземпляров приложения
Outlook, каждый из которых создает 24 ничего не делающих потока. Мы получаем 2400 потоков,
каждый с собственным ядром, TEB, стеком режима пользователя, стеком режима ядра и т.п. 
Огромное количество впустую потраченных ресурсов. Эту практику пора прекращать, особенно 
если Microsoft Хочет, чтобы пользователи успешно работали с Windows на нетбуках, на большинстве
которых всего 1Гбит оперативы. Именно практике эффективного проектирования приложений с минимальным
количеством потоков и посвящены последние главы этой книги.

## Тенденции развития процессоров

