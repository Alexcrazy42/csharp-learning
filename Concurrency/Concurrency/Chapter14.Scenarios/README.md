# Глава 14. Сценарии.

В этой главе будут рассмотрены различные типы и методы типичных сценариев, встречающихся при написании 
параллельных программ. О таких сценариях можно было бы написать отдельную книгу, поэтому я выбрал лишь несколько
примеров, которые показалисб мне наиболее полезными.

# 14.1. Инициализация совместных ресурсов

## Задача

Имеется ресурс, совместно используемый несколькими частями кода. Требуется инициализировать этот ресурс при 
перввом обращении к нему.

## Решение

Lazy<T>. Экземпляр типа Lazy<T> конструируется фабричным 
делегатом, который используется для инициализации экземпляра. Затем экземпляр 
становится доступным через свойство Value. Следующий пример показывает использование типа Lazy<T>:

```
static int _simpleValue;
static readonly Lazy<int> MySharedInteger = new Lazy<int>(() => _simpleValue++);

void UseSharedInteger()
{
	int sharedValue = MySharedInteger.Value;
}

```

Сколько бы потоков ни вызывало UseSharedInteger одновременно, фабричный делегат выполняется 
только один раз, и все потоки ожидают 
одного экземпляра. После того как экземпляр будет создан, он кэшируется, 
и все будущие обращения к свойству Value возвращают тот же экземпляр 
(в приведенном примере MySharedInteger.Value всегда будет содержать 0).

Очень похожее решение может использоваться в том случае, если инициализация 
требует асинхронной работы; используйте Lazy<Task<T>>:

```
static int _simpleValue;

static readonly Lazy<Task<int>> MySharedAsyncInteger = new Lazy<Task<int>>(async () =>
{
	await Task.Delay(TimeSpan.FromSeconds(2)).ConfigureAwait(false);
	return _simpleValue++;
});

async Task GetSharedIntegerAsync()
{
 int sharedValue = await MySharedAsyncInteger.Value;
}
```

Во-первых, асинхронный делегат может 
быть выполнен в любом потоке, который вызывает Value, и делегат будет 
выполняться в этом контексте. Если существуют разные типы потоков, 
которые могут вызывать Value (например, UI-поток и поток из пула 
потоков или потоки двух разных запросов ASP.NET), возможно, будет 
лучше, если асинхронный делегат будет всегда выполняться в потоке из 
пула. Это легко сделать, заключив фабричного делегата в вызов Task.Run:

```
static int _simpleValue;
static readonly Lazy<Task<int>> MySharedAsyncInteger =
	new Lazy<Task<int>>(() => Task.Run(async () =>
	{
	await Task.Delay(TimeSpan.FromSeconds(2));
	return _simpleValue++;
	}));

async Task GetSharedIntegerAsync()
{
 int sharedValue = await MySharedAsyncInteger.Value;
}
```

Другой аспект заключается в том, что экземпляр Task<T> создается только 
один раз. Если асинхронный делегат выдаст исключение, то Lazy<Task<T>>
будет кэшировать эту задачу с ошибкой. Такая ситуация нежелательна; 
в большинстве случаев лучше снова выполнить делегата при следующем 
запросе отложенного значения вместо того, чтобы кэшировать исключение. 
Механизма «сброса» Lazy<T> не существует, но можно создать новый 
класс, который обеспечивает повторное создание экземпляра Lazy<T>:

## Пояснение

Последний пример кода представляет общий паттерн асинхронной отложенной инициализации. Выглядит он несколько
уклюже. Библиотека AsyncEx включает тип AsyncLazy<T>, который работает, так как тип Lazy<Task<T>>, выполняющий
своего фабричного делегата в пуле потоков с возможностью повторения попытки при неудаче. Возможно и прямое
ожидание await, так что код объявления и использования выглядит примерно так:

```
static int _simpleValue;

private static readonly AsyncLazy<int> MySharedAsyncInteger =
new AsyncLazy<int>(async () =>
{
	await Task.Delay(TimeSpan.FromSeconds(2));
	return _simpleValue++;
},
AsyncLazyFlags.RetryOnFailure);

public async Task UseSharedIntegerAsync()
{
	int sharedValue = await MySharedAsyncInteger;
}
```

# 14.2. Отложенное вычисление в System.Reactive

## Задача

## Решение

## Пояснение


# 14.3. Асинхронное связывание данных

## Задача

Данные загружаются асинхронно. Требуется осуществить связывание данных с результатами (например, в компоненте
модели представления (ViewModel) в архитектуре "модель-представление - модель представления")

## Решение

Если свойство используется в связывании данных, оно должно немедленно и синхронно вернуть некое подобие результата.
Если фактическое значение должно определяться асинхронно, вы можете вернуть результат по умолчанию и позднее
обновить свойство правильным значением.

Помните, что асинхронные операции могут завершаться не только успехом, но и неудачей. Так как вы пишете модель 
представления, связывание данных может использоваться для обновления пользовательского интерфейса и для ситуации
ошибки.

В библиотеке Nito.Mvvm.Async имеется тип NotifyTask, который может использоваться для этой цели:

```
class MyViewModel
{
	public MyViewModel()
	{
		MyValue = NotifyTask.Create(CalculateMyValueAsync());
	}
	
	public NotifyTask<int> MyValue { get; private set; }

	private async Task<int> CalculateMyValueAsync()
	{
		await Task.Delay(TimeSpan.FromSeconds(10));
		return 13;
	}
}
```

Как показывает следующий пример, связывание данных может применяться к различным свойствам по свойству
NotifyTask<T>:

```
<Grid>
	<Label Content="Loading..."
		Visibility="{Binding MyValue.IsNotCompleted,
			Converter={StaticResource BooleanToVisibilityConverter}}"/>
	
	<Label Content="{Binding MyValue.Result}"
		Visibility="{Binding MyValue.IsSuccessfullyCompleted,
			Converter={StaticResource BooleanToVisibilityConverter}}"/>
	
	<Label Content="An error occurred" Foreground="Red"
		Visibility="{Binding MyValue.IsFaulted,
			Converter={StaticResource BooleanToVisibilityConverter}}"/>
</Grid>
```

В библиотеке MvvmCross входит тип MvxNotifyTask, очень похожий на NotifyTask<T>.

## Пояснение

Можно написать собственную обертку связывания данных (вместо использования обертки из библиотек). Следующий
код дает примерное представление о том, как это делается:

```
class BindableTask<T> : INotifyPropertyChanged
{
	private readonly Task<T> _task;

	public BindableTask(Task<T> task)
	{
		_task = task;
		var _ = WatchTaskAsync();
	}

	private async Task WatchTaskAsync()
		{
		try
		{
			await _task;
		}
		catch
		{
		}
		OnPropertyChanged("IsNotCompleted");
		OnPropertyChanged("IsSuccessfullyCompleted");
		OnPropertyChanged("IsFaulted");
		OnPropertyChanged("Result");
	}

	public bool IsNotCompleted { get { return !_task.IsCompleted; } }

	public bool IsSuccessfullyCompleted
	{
		get { return _task.Status == TaskStatus.RanToCompletion; }
	}

	public bool IsFaulted { get { return _task.IsFaulted; } }
	
	public T Result
	{
		get { return IsSuccessfullyCompleted ? _task.Result : default; }
	}

	public event PropertyChangedEventHandler PropertyChanged;

	protected virtual void OnPropertyChanged(string propertyName)
	{
		PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
	}
}
```

Обратиье внимание: пустое условие catch использовано намеренно - мы хотим перехватывать все исключения и 
обрабатывать их через механизм связывания данных. Также в коде не должен использоваться вызов
ConfigureAwait(false), потому что событие PropertyChanged должно выдаваться в UI-потоке.

# 14.4. Неявное состояние

## Задача

Имеются переменные состояния, которые должны быть доступны в разных точках стека вызовов. Например,
идентификатор текущей операции должен использоваться для вывода информации в журнал, но вы не хотите добавлять 
его в виде параметра в каждый метод.

## Решение

Лучшее решение — добавить параметры к методам, сохранить данные 
в полях класса или воспользоваться внедрением зависимостей для предоставления 
данных разным частям вашего кода. Но в некоторых ситуациях 
это приведет к чрезмерному усложнению кода.

Тип AsyncLocal<T> позволяет связать с состоянием объект, в котором 
оно сможет существовать в логическом «контексте». Следующий код 
демонстрирует использование AsyncLocal<T> для назначения идентификатора 
операции, который позднее читается методом журнального выводах.

Во многих случаях бывает полезно создать более сложную структуру 
данных (например, стек) в одном экземпляре AsyncLocal<T>. Это возможно 
с одной оговоркой: в AsyncLocal<T> следует хранить только неизменяемые данные. 
Каждый раз, когда возникнет необходимость в обновлении 
данных, вы должны перезаписать существующее значение. Часто бывает 
полезно скрыть AsyncLocal<T> внутри вспомогательного типа, который гарантирует 
неизменяемость хранимых данных иих корректное обновление.

Тип-обертка гарантирует, что используемые данные неизменяемы и что 
новые значения будут заноситься в стек. Он также предоставляет удобный 
способ извлечения значений из стека через IDisposable

## Пояснение

В старом коде можно использовать атрибут ThreadStatic для контекстного 
состояния, используемого синхронным кодом. При преобразовании старого кода в 
асинхронный AsyncLocal<T> является основным кандидатом для 
замены ThreadStaticAttribute. AsyncLocal<T> работает как для синхронного, 
так и для асинхронного кода, и этот способ должен использоваться 
по умолчанию для неявного состояния в современных приложениях.

# 14.5. Идентичный синхронный и асинхронный код

## Задача

Имеется код, к которому нужно предоставить доступ через синхронный и асинхронный API без дублирования логики.
Такая ситуация часто встречается при преобразовании существующего код в асинхронный, если существующие
синхронные потребители изменять (пока) нельзя.

## Решение

Решение заключается в добавлении булева флага:

```
private async Task<int> DelayAndReturnCore(bool sync)
{
	int value = 100;
	// Выполнение некоторой работы.
	if (sync)
		Thread.Sleep(value); // Вызвать синхронный API.
	else
		await Task.Delay(value); // Вызвать асинхронный API.
	return value;
}

// Асинхронный API
public Task<int> DelayAndReturnAsync() =>
	DelayAndReturnCore(sync: false);

// Синхронный API
public int DelayAndReturn() =>
	DelayAndReturnCore(sync: true).GetAwaiter().GetResult();
```

Метод асинхронного API DelayAndReturnAsync вызывает DelayAndReturnCore
c логическим параметром sync, равным false; это означает, что метод 
DelayAndReturnCore может работать асинхронно и он использует await
в используемом методе API «асинхронной задержки» Task.Delay. Задача, 
возвращаемая DelayAndReturnCore, возвращается напрямую на сторону 
вызова DelayAndReturnAsync.

Метод синхронного API DelayAndReturn вызывает DelayAndReturnCore с логическим 
параметром sync, равным true; это означает, что DelayAndReturnCore
может работать синхронно и он использует метод API «синхронной 
задержки» Thread.Sleep. Задача, возвращаемая DelayAndReturnCore, уже 
должна быть завершена, что позволяет безопасно получить результат. 
DelayAndReturn использует GetAwaiter().GetResult() для получения результата от задачи; 
это позволяет обойтись без обертки AggregateException, которая могла 
бы потребоваться при использовании свойства Task<T>.Resul

## Пояснение

Такое решение не идеально, но оно может помочь в построении реальных приложений.
Впрочем, необходимо учитывать ряд нюансов. Катастрофические проблемы возникнут в 
том случае, если метод Core неправильно обрабатывает 
свой параметр sync. Если метод Core когда-либо вернет незавершенную 
задачу при условии, что sync содержит true, то синхронный API может 
легко создать взаимную блокировку; единственная причина, по которой 
синхронный API может блокироваться по этой задаче, — если он знает, 
что задача уже завершена. Аналогично, если метод Core блокирует поток 
при переменной sync, равной false, то приложение работает не настолько 
эффективно, насколько могло бы

Одним из возможных усовершенствований этого решения могло бы стать 
добавление в синхронном API проверки, которая убеждалась бы в том, 
что возвращенная задача действительно завершена. Если задача окажется 
незавершенной, то это указывает на серьезную ошибку программирования.

# 14.6. "Рельсовое" программирование с сетями потоков данных

## Задача

## Решение

## Пояснение


# 14.7. Регулировка обновлений о ходе выполнения операции

## Задача

Имеется продолжительная операция, которая выдает сообщения о прогрессе операции; 
обновления отображаются в пользовательском интерфейсе. Однако обновления поступают 
слишком быстро и тормозят работу пользовательского интерфейса.

## Решение

В следующем примере выдаются слишком частые уведомления о прогрессе операции:

```
private string Solve(IProgress<int> progress)
{
	// Вести максимально быстрый отсчет в течение 3 секунд.
	var endTime = DateTime.UtcNow.AddSeconds(3);
	int value = 0;
	while (DateTime.UtcNow < endTime)
	{
		value++;
		progress?.Report(value);
	}
	return value.ToString();
}
```

Чтобы выполнить этот код из GUI-приложения, упакуйте его в Task.Run
и передайте IProgress<T>. Следующий пример предназначен для WPF, 
но используемые концепции действуют независимо от платформы GUI 
(WPF, Xamarin или Windows Forms):

```
// Для простоты код обновляет надпись напрямую.
// В реальном MVVM-приложении эти присваивания
// осуществлялись бы обновлением свойства ViewModel,
// связанного с пользовательским интерфейсом.
private async void StartButton_Click(object sender, RoutedEventArgs e)
{
	MyLabel.Content = "Starting...";
	var progress = new Progress<int>(value => MyLabel.Content = value);
	var result = await Task.Run(() => Solve(progress));
	MyLabel.Content = $"Done! Result: {result}";
}
```

Здесь фоновый код  отправляет отчеты о прогрессе UI-потоку слишком быстро — настолько 
быстро, что после выполнения в течение всего 3 секунд UI-потоку требуется еще 17 
секунд или около того для обработки всех этих уведомлений, 
а текст надписи обновляется снова и снова. Затем UI-поток обновляет 
надпись в последний раз со значением "Done! Result:" и наконец получает 
возможность перерисовать экран с выводом обновленного текста надписи.

Прежде всего следует понять, что сообщения о прогрессе необходимо регулировать. 
Только так можно гарантировать, что у пользовательского интерфейса будет достаточно 
времени для перерисовки между обновлениями. Затем необходимо осознать, что регулировка должна осуществляться по 
времени, а не по количеству отчетов. Идея регулировки, основанной на 
отправке одного сообщения из сотни или около того, выглядит заманчиво, 
но она не идеальна по причинам, изложенным в разделе «Пояснение».

Тот факт, что мы должны иметь дело со временем, наводит на мысль, что 
нам стоит рассмотреть возможность использования System.Reactive. 
Собственно, в System.Reactive имеются операторы, предназначенные 
специально для регулировки по времени. Похоже, System.Reactive сможет 
сыграть положительную роль в этом решении

Для начала можно определить реализацию IProgress<T>, которая выдает 
событие для каждого отчета о прогрессе, а затем создать наблюдаемый 
объект, получающий эти отчеты:

```
public static class ObservableProgress
{
	private sealed class EventProgress<T> : IProgress<T>
	{
		void IProgress<T>.Report(T value) => OnReport?.Invoke(value);

		public event Action<T> OnReport;
	}

	public static (IObservable<T>, IProgress<T>) Create<T>()
	{
		var progress = new EventProgress<T>();
		var observable = Observable.FromEvent<T>(
			handler => progress.OnReport += handler,
			handler => progress.OnReport -= handler);
		return (observable, progress);
	}
}
```

Метод ObservableProgress.Create<T> создает пару объектов IObservable<T>
и IProgress<T>, при этом все отчеты о прогрессе, отправленные IProgress<T>, 
будут отправляться подписчикам IObservable<T>. Теперь мы имеем наблюдаемый 
поток для отчетов о прогрессе; следующим шагом должна 
стать его регулировка

Пользовательский интерфейс должен обновляться медленно, чтобы 
реагировать на происходящее, и при этом достаточно быстро, чтобы 
пользователи видели обновления. Человек воспринимает информацию 
намного медленнее, чем происходит перерисовка экрана, поэтому существует 
широкий диапазон допустимых значений частоты обновления. 
Если вы хотите добиться истинного удобства восприятия информации, 
регулировки до одного обновления в секунду или около того может быть 
достаточно. Если вы предпочитаете обратную связь, приближенную к реальному 
времени, используйте одно обновление каждые 100 или 200миллисекунд (мс). 
Оно будет достаточно быстрым, чтобы пользователь 
понимал суть происходящего и имел общее представление о прогрессе, 
но при этом достаточно медленным, чтобы пользовательский интерфейс 
успевал реагировать на происходящее.

Следует помнить и о том, что отчеты о прогрессе могут выдаваться из 
других потоков — в данном случае они выдаются из фонового потока. 
Регулировка должна происходить как можно ближе к источнику, поэтому 
желательно вынести ее в фоновый поток. Однако код, обновляющий 
пользовательский интерфейс, должен выполняться в UI-потоке. С учетом 
этого факта можно определить метод CreateForUi, который обеспечивает 
как регулировку, так и переход в UI-поток:


```
public static class ObservableProgress
{
	// Примечание: должен вызываться из UI-потока.
	public static (IObservable<T>, IProgress<T>) CreateForUi<T>(
		TimeSpan? sampleInterval = null)
	{
		var (observable, progress) = Create<T>();
		observable = observable
			.Sample(sampleInterval ?? TimeSpan.FromMilliseconds(100))
			.ObserveOn(SynchronizationContext.Current);
		return (observable, progress);
	}
}
```

Теперь у вас имеется вспомогательный метод, который будет регулировать 
обновления прогресса до того, как они доберутся до пользовательского 
интерфейса. В приведенном примере вспомогательный метод может использоваться 
в обработчике щелчка на кнопке:

```
// Для простоты код обновляет надпись напрямую.
// В реальном MVVM-приложении эти присваивания
// осуществлялись бы обновлением свойства ViewModel,
// связанного с пользовательским интерфейсом.
private async void StartButton_Click(object sender, RoutedEventArgs e)
{
	MyLabel.Content = "Starting...";
	var (observable, progress) = ObservableProgress.CreateForUi<int>();
	string result;
	using (observable.Subscribe(value => MyLabel.Content = value))
		result = await Task.Run(() => Solve(progress));
	MyLabel.Content = $"Done! Result: {result}";
}

```

Новый код вызывает наш вспомогательный метод ObservableProgress.
CreateForUi, который создает пару IObservable<T> и IProgress<T>. Код 
подписывается на обновления о прогрессе и продолжает выполнение до тех 
пор, пока Solve не завершится. Наконец, IProgress<T> передается методу 
Solve с длительным выполнением. Когда Solve вызывает IProgress<T>.
Report, сначала производится выборка этих отчетов в 100-миллисекундном 
окне; одно обновление за каждые 100 миллисекунд передается UI-потоку 
и используется для обновления текста надписи. Теперь пользовательский 
интерфейс сохраняет высокую скорость отклика!

## Пояснение

У задачи есть и другое альтернативное решение, которое часто встречается 
на практике, — «решение с делением». Суть в том, что метод Solve сам 
регулирует свои обновления прогресса; например, если код хочет обрабатывать 
только одно обновление на каждые 100 фактических обновлений, 
то в коде можно использовать проверку с вычислением остатка вида

```if (value % 100 == 0) progress?.Report(value);```

У этого решения есть пара недостатков. Во-первых, «правильного» делителя не существует; 
обычно разработчик перебирает разные значения, 
пока не найдет то, которое хорошо работает на его машине. Однако тот же 
код может не лучшим образом работать на гигантском сервере клиента 
или на недостаточно мощной виртуальной машине. Кроме того, в разных 
платформах и средах по-разному организуется кэширование, в результате 
чего код может работать намного быстрее (или медленнее), чем ожидалось. И конечно, мощь 
«новейшего» компьютерного оборудования тоже 
изменяется со временем. Таким образом, значение делителя выбирается 
в какой-то степени случайно; оно не будет правильным везде и всегда.

Другой недостаток этого решения заключается в том, что оно пытается 
исправить проблему в неправильной части кода. Эта проблема относится 
исключительно к пользовательскому интерфейсу, и ее решение должен 
предоставлять пользовательский интерфейс. В примере этого рецепта 
метод Solve представляет некоторую фоновую бизнес-логику обработки; 

он не должен беспокоиться о проблемах, присущих пользовательскому 
интерфейсу. Возможно, в консольном приложении будет использоваться 
совсем не такой делитель, как в приложении WPF

С другой стороны, решение с делением правильно в том, что обновления 
лучше регулировать перед отправкой обновлений UI-потоку. Решение 
в этом рецепте также действует по этому принципу: оно регулирует обновления 
немедленно и синхронно в фоновом потоке перед отправкой 
UI-потоку. Внедряя собственную реализацию IProgress<T>, пользовательский 
интерфейс может выполнить собственную регулировку, не требуя 
никаких изменений в самом методе Solve.

Lazy