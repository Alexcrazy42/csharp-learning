# Глава 10. Отмена

Отмена является разновидностью сигнала, в которой участвуют две стороны: источнник, инициируеющий отмену,
и получатель, реагирующий на отмену.

Отмена рассматривается, как специальная разновидность ошибки. По действующим правилам, отмененный 
код инициирует исключения типа OperationCanceledException (тли производного типа - например,
TaskCanceledException). В этом случае вызывающий код знает, что отмена была замечена.

# 10.1. Выдача запросов на отмену

## Задача

Из вашего кода вызывается другой код, которые может отменяться. Требуется отменить вызванный код.

## Решение

```
using var cts = new CancellationTokenSource();
 var task = CancelableMethodAsync(cts.Token);
 // В этой точке операция была запущена.
 // Выдать запрос на отмену.
 cts.Cancel()
```


Следующий пример очень похож на предыдущий, не считая того, что он 
использует с задачей ключевое слово await, с демонстрацией всех трех 
возможных результатов:

```
async Task IssueCancelRequestAsync()
{
	using var cts = new CancellationTokenSource();
	var task = CancelableMethodAsync(cts.Token);
	// В этой точке операция выполняется.
	// Выдать запрос на отмену.
	cts.Cancel();
	// (Асинхронно) ожидать завершения операции.

	try
	{
		await task;
		// Если управление окажется в этой точке, значит, операция
		// была успешно завершена перед тем, как вступил в силу
		// запрос на отмену.
	}
	catch (OperationCanceledException)
	{
		// Если управление окажется в этой точке, значит, операция
		// была отменена до ее завершения.
	}
	catch (Exception)
	{
		// Если управление окажется в этой точке, значит, операция
		// завершилась с ошибкой перед тем как вступил в силу
		// запрос на отмену.
		throw;
	}
}
```

## Пояснение

ASP.NET например представляет маркер отмены, представляющий тайм-аут запроса или отсоединение клиента.


# 10.2. Реагирование на запросы на отмену посредством периодического опроса

## Задача

В коде имеется цикл, которые должен поддерживать отмену.

## Решение

```
public int CancelableMethod(CancellationToken cancellationToken)
{
	for (int i = 0; i != 100; ++i)
	{
		Thread.Sleep(1000); // Некоторые вычисления.
		cancellationToken.ThrowIfCancellationRequested();
	}
	return 42;
}
```

Следующий пример похож на предыдущий, но выполняется больше итераций более быстрого цикла, поэтому я добавил 
ограничение на частоту проверки маркера:

```
public int CancelableMethod(CancellationToken cancellationToken)
{
	for (int i = 0; i != 100000; ++i)
	{
		Thread.Sleep(1); // Некоторые вычисления.
		if (i % 1000 == 0)
			cancellationToken.ThrowIfCancellationRequested();
	}
	return 42;
}
```

Предельное значение зависит исключительно от того, какой объем работы выполняется и насколько быстрой должна
быть реакция на отмену.

## Пояснение

Такой пример нужно использовать лишь в случае, если у вас имеется вычислительный цикл, который должен поддерживать
отмену.

Рекомендуется всегда возвращать исключение OperationCanceledException, для чего вызывается метод метод 
ThrowIfCancellationRequested. Это хорошо накладывается на паттерн отмены.

# 10.3. Отмена по тайм-ауту

## Задача

Имеется код, который должен остановить выполнение после тайм-аута.

## Решение

```
async Task IssueTimeoutAsync()
{
	using var cts = new CancellationTokenSource
	(TimeSpan.FromSeconds(5));
	
	CancellationToken token = cts.Token;
	await Task.Delay(TimeSpan.FromSeconds(10), token);
}
```

Если у вас уже имеется экземпляр CancellationTokenSource, можно запустить тайм-аут для этого экземпляра:

```
async Task IssueTimeoutAsync()
{
	using var cts = new CancellationTokenSource();
	
	CancellationToken token = cts.Token;
	cts.CancelAfter(TimeSpan.FromSeconds(5));
	await Task.Delay(TimeSpan.FromSeconds(10), token);
}
```

## Пояснение

Чтобы выполнить код с тайм-аутом, используйте CancellationTokenSource и CancelAfter (Или конструктор).
Той же цели можно добиться другими способсами, но использование существующей системы отмены - самый простой
и эффективный вариант.

Помните, что отменяемый код должен отслеживать состояние маркера отмены. Вам не удасться легко отменить код, для
которого отмена не предусмотрена.

# 10.4. Отмена async-кода

## Задача

Вы используете async-код, для которого нужно обеспечить возможность отмены.

## Решение

Следующий пример выполняет асинхронную задержку, после чего возвращает значение; для поддержки отмены маркер
передается Task.Delay:

```
public async Task<int> CancelableMethodAsync(CancellationToken cancellationToken)
{
	await Task.Delay(TimeSpan.FromSeconds(2), cancellationToken);
	return 42;
}
```

Многие асинхронные API поддерживают CancellationToken, поэтому обеспечение отмены обычно сводится к простой 
передаче маркера. Как правило, если ваш метод вызывает функции API, получающие CancellationToken, то ваш метод
также должен получать CancellationToken И передавать его всем функциями API, которые его поддерживают.

## Пояснение

Если ваш код вызывает код, не поддерживающий отмену и вы не хотите упаковывать этот код в отдельный 
исполняемый модуль, всегда можно имитировать отмену, просто игнорируя результат.

Высокоуровневые методы зависят от правильно реализованной отмены на нижнем уровне. 
Таким образом, когда вы пишете собственные Async-методы, постарайтесь, как можно тщательнее обеспечить 
поддержку отмены. Никогда неизвестно заранее, какие высокоуровые методы будут вызывать ваш код, и им тоже
может понадобиться отмена.

# 10.5. Отмена параллельного кода

## Задача

Вы используете параллельный код, для которого нужно обеспечить возможность отмены.

## Решение

Параллельные метод поддерживают отмену посредством получения экземпляра ParallelOptions. Установка CancellationToken
для экземпляра ParallelOptions выполняется так:

```
void RotateMatrices(IEnumerable<Matrix> matrices, float degrees,
 CancellationToken token)
{
	Parallel.ForEach(matrices, 
		new ParallelOptions { CancellationToken = token }, 
		matrix => matrix.Rotate(degrees));
}
```

Также можно отслеживать CancellationToken непосредственно в теле цикла:

```
void RotateMatrices2(IEnumerable<Matrix> matrices, float degrees, CancellationToken token)
{
 // Предупреждение: так поступать не рекомендуется; см. ниже.
 Parallel.ForEach(matrices, matrix =>
	{
		matrix.Rotate(degrees);
		token.ThrowIfCancellationRequested();
	});
}
```

Альтернативное решение требует большего объема работы и не так хорошо интегрируются, потому что параллельный цикл 
упаковывает OperationCanceledException в AggregateException. Кроме того, если CancellationToken передается
в составе экземпляра ParallelOptions, класс Parallel сможет принять более разумные решения относительно частоты
проверки маркера. По этим причинам маркер лучше передавать в параметре. В этом случае маркер также можно
передать в тело цикла, но не следует только передавать маркер в тело цикла.

В PLINQ также предусмотрена встроенная поддержка отмены с оператором WithCancellation:

```
IEnumerable<int> MultiplyBy2(IEnumerable<int> values,
 CancellationToken cancellationToken)
{
	return values.AsParallel()
		.WithCancellation(cancellationToken)
		.Select(item => item * 2);
}
```

## Пояснение

Поддержка отмены для параллельной работы - важный критерий хорошего пользовательского интерфейса. Если ваше 
приложение выполняет параллельную работу, оно создает серьезную нагрузку на процессор в течении хотя бы короткого
времени. Высокий уровень использования процессора обычно заметен для пользователей, даже если не мешает работе
других приложений на той же машине. Таким образом, я рекомендую поддерживать отмену при любых параллельных 
вычислениях (или любой другой работе, связанной с интенсивной нагрузкой на процессор), даже если общее время 
высокого нагрузки на процессор относительно невелико.

# 10.6. Отмена кода System.Reactive

## Задача



## Решение

## Пояснение

# 10.7. Отмена сетей потоков данных

## Задача

## Решение

## Пояснение


# 10.8. Внедрение запросов на отмену

## Задача

В коде присутствует уровень, который должен реагировать на запросы на отмену, а также выдавать собственные
запросы на отмену на следующий уровень

## Решение

Следующий пример выполняет асинхронный запрос HTTP. Маркер, переданный методу 
GetWithTimeoutAsync, представляет отмену, запрошенную 
конечным пользователем, а метод GetWithTimeoutAsync также применяет 
тайм-аут к запросу:

```
async Task<HttpResponseMessage> GetWithTimeoutAsync(HttpClient client,
 string url, CancellationToken cancellationToken)
{
	using CancellationTokenSource cts = CancellationTokenSource
		.CreateLinkedTokenSource(cancellationToken);
	cts.CancelAfter(TimeSpan.FromSeconds(2));
	
	CancellationToken combinedToken = cts.Token;
	return await client.GetAsync(url, combinedToken);
}
```

Полученный маркер combinedToken отменяется либо когда пользователь 
отменяет существующий маркер cancellationToken, либо при отмене 
связанного источника вызовом CancelAfter.

## Пояснение

Например, ASP.NET предоставляет маркер отмены, 
представляющий отключение пользователя (HttpContext.RequestAborted); 
код обработчика может создать связанный маркер, который реагирует 
либо на отключение пользователя, либо на свои причины отмены (например, тайм-аут).

Также обратите внимание на то, что в примере используется команда using, которая гарантирует, что источник 
связанного маркера отмены будет освобожден, когда операция будет 
завершена (а комбинированный маркер перестанет использоваться).

# 10.9. Взаимодействие с другими системами отмены

## Задача

Имеется внешний или унаследованный код с собственными концепциями отмены. Требуется управлять им с использованием
стандартного объекта CancellationToken.

## Решение

У типа CancellationToken существует два основных способа реакции на 
запрос на отмену: периодический опрос (рассматривается в рецепте 10.2) 
и обратные вызовы (тема этого рецепта). Регистрация обратного вызова для маркера 
осуществляется методом CancellationToken.Register.

Допустим, вы пишете обертку для System.Net.NetworkInformation.Pingtype
и хотите предусмотреть возможность отмены тестового опроса. Класс 
Ping уже имеет API на базе Task, но не поддерживает CancellationToken. 
Вместо этого тип Ping содержит собственный метод SendAsyncCancel, 
который может использоваться для отмены. Для этого зарегистрируйте 
обратный вызов, который активизирует этот метод:

```
async Task<PingReply> PingAsync(string hostNameOrAddress,
 CancellationToken cancellationToken)
{
	using var ping = new Ping();

	Task<PingReply> task = ping.SendPingAsync(hostNameOrAddress);

	using CancellationTokenRegistration _ = cancellationToken
		.Register(() => ping.SendAsyncCancel());
	return await task;
}
```

Теперь при запросе на отмену CancellationToken вызовет метод SendAsyncCancel за вас, 
отменяя метод SendPingAsync.


## Пояснение

Метод CancellationToken.Register может использоваться для взаимодействия с любой альтернативной 
системой отмены. Но следует помнить, что 
если метод получает CancellationToken, запрос отмены должен отменять 
только эту одну операцию. Некоторые альтернативные системы отмены 
реализуют отмену закрытием некоторого ресурса, что может привести 
к отмене нескольких операций; эта разновидность системы отмены плохо 
соответствует CancellationToken. Если вы решите инкапсулировать такую 
разновидность отмены в CancellationToken, следует документировать ее 
необычную семантику отмены.

Помните о сроке существования регистрации обратных вызовов. Метод 
Register возвращает отменяемый объект, который должен быть освобожден, 
когда обратный вызов перестанет быть нужным. Предыдущий пример 
использует команду using для выполнения завершающих действий при 
завершении асинхронной операции. Если в коде отсутствует команда 
using, то при каждом вызове кода с тем же (долгосрочным) маркером 
CancellationToken он будет добавлять новый обратный вызов (который, 
в свою очередь, будет поддерживать существование объекта Ping). Чтобы 
избежать утечки памяти и ресурсов, отмените регистрацию обратного 
вызова, когда он перестанет быть нужным.