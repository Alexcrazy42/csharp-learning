# Глава 2. Основы async

Если имеется операция которую вы бы хотели рассматривать как асинхронную (например, чтобы она не 
блокировала UI-поток), обращайтесь к главе 4. Кроме того, в этой главе рассматриваются только операции,
которые один раз начинаются и один раз завершаются; если нужно обрабатывать потоки событий,
обращайтесь к главам 3 и 6.

## 2.1. Приостановка на заданный период

### Задача

Требуется (асинхронно) приостановить выполнение программый на некоторый период времени. Такая ситуация
часто встречается в модульном тестировании или реализации задержки для повторного использования.
Она также возникает при программировании простых тайм-аутов.

### Решение

Тип Task содержит статический метод Delay, который возвращает задачу, 
завершающуюся после истечения заданного времени. При имитации асинхронной операции важно проверить
синхронный успех и асинхронный успех, а также асинхронную неудачу. Следующий пример возвращает 
задачу используемую для случая асинхронного успеха:

```
async Task<T> DelayResult<T>(T result, TimeSpan delay)
{
	await Task.Delay(delay);
	return result;
}
```

*Экспоненциальная задержка* - стратегия увеличения задержек между повторными попытками. Используйте ее при
работе с веб службами, чтобы не перегруждать сервер повторным попытками.

**Ниже приведен пример простой реализации экспоненциальной задержки:**

```
async Task<string> DownloadStringWithRetries(HttpClient client, string uri)
{
	// Повторить попытку через 1 секунду, потом через 2 и через 4 секунды.
	TimeSpan nextDelay = TimeSpan.FromSeconds(1);
	for (int i = 0; i != 3; ++i)
	{
		try
		{
			return await client.GetStringAsync(uri);
		}
		catch
		{
		}

		await Task.Delay(nextDelay);
		nextDelay = nextDelay + nextDelay;
	}

	// Попробовать в последний раз и разрешить распространение ошибки.
	return await client.GetStringAsync(uri);
}
```

**Пример возвращает null, если служба не вернет ответ в течении 3 секунд:**

```
async Task<string> DownloadStringWithTimeout(HttpClient client, string uri)
{
	using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(3));
	Task<string> downloadTask = client.GetStringAsync(uri);
	Task timeoutTask = Task.Delay(Timeout.InfiniteTimeSpan, cts.Token);

	Task completedTask = await Task.WhenAny(downloadTask, timeoutTask);
	if (completedTask == timeoutTask)
		return null;

	return await downloadTask;
}
```

### Пояснение

Task.Delay  неплохо подходит для модульного тестирования асинхронного 
кода или реализации логики повторных попыток. Но если нужно реализовать тайм-аут, 
лучшим кандидатом будет CancellationToken.

## 2.2. Возвращение завершенных задач

### Задача 

Требуется реализовать синхронный метод с асинхронной сигнатурой. Например, такая ситуация может возникнуть,
если вы наследуетесь от асинхронного интерфейса или базового класса, но хотите реализовать его
синхронно. Этот прием особенно полезен при модульном тестировании асинхронного кода, когда нужна
простая загрушка или имитированная реализация для асинхронного интерфейса.

### Решение

```
interface IMyAsyncInterface
{
	// возвращение значения
	Task<int> GetValueAsync(CancellationToken cancellationToken);

	// нет возвращения
	Task DoSomethingAsync();
}

class MySynchronousImplementation : IMyAsyncInterface
{
	public Task<int> GetValueAsync(CancellationToken cancellationToken)
	{
		// простой возврат
		return Task.FromResult(13);

		// отмененные задачи из заданного маркера CancellationToken
		if(cancellationToken.IsCancellationRequested)
		{
			return Task.FromCanceled<int>(cancellationToken);
		}
		return Task.FromResult(13);
	}

	public Task DoSomethingAsync()
	{
		// простой возврат
		return Task.CompletedTask;

		// если нужна ошибка
		return Task.FromException(new NotImplementedException());

		// если в синхронной реализации может произойти отказ,
		// перехватывайте исключения и используйте Task.FromException для их возвращения
		try
		{
			DoSomethingSynchronously();
			return Task.CompletedTask;
		}
		catch(Exception ex)
		{
			return Task.FromException(ex);
		}
	}
}
```

### Пояснение

Если вы реализуете асинхронный интерфейс синхронным кодом, избегайте любых форм блокировки. Избегайте
блокирования с последующим возвращением завершенной задачи а асинхронном методе, если метод может
быть реализован асинхронно. 

Если асинхронный метод блокируется, он не позволяет вызывающему потоку запускать другие задачи, что 
противоречит идее конкурентности и может привести к взаимоблокировке.

На логическом уровне Task.FromResult, Task.FromException и Task.FromCanceled 
являются вспомогательными методами и сокращенными формами 
обобщенного типа TaskCompletionSource<T>. TaskCompletionSource<T>
представляет собой низкоуровневый тип, полезный для взаимодействия 
с другими формами асинхронного кода. В общем случае следует применять 
сокращенную форму Task.FromResult и родственные формы, если хотите 
вернуть уже завершенную задачу. Используйте TaskCompletionSource<T>
для возвращения задачи, которая завершается в некоторый момент будущего

## 2.3. Передача информации о ходе выполнения операции

### Задача

Требуется отреагировать на прогресс выполнения операции

### Решение

Используйте типы IProgress<T> и Progres<T>. Ваш async метод должен получать аргумент IProgress<T>, здесь
T - типа прогресса, о котором вы хотите сообщать.

```
async Task MyMethodAsync(IProgress<double> progress = null)
{
	bool done = false;
	double percentComplete = 0;
	while (!done)
	{
		...
		progress?.Report(percentComplete);
	}
}

```

**Пример использование в вызывающем коде:**

```
async Task CallMyMethodAsync()
{
	var progress = new Progress<double>();
	
	progress.ProgressChanged += (sender, args) =>
	{
		...
	};
	
	await MyMethodAsync(progress);
}
```

### Пояснение

1. По действующим соглашениям параметр IProgress<T> может быть равен 
null, если вызывающей стороне не нужны уведомления о прогрессе.

2. Помните, что метод IProgress<T>.Report обычно является синхронным. 
Это означает, что лучше запустить асинхронную задачу прежде чем сделать 
Report о статусе.

3. Когда вы используете изменяемый ссылочный тип с IProgress<T>, вам нужно 
быть осторожным с изменениями состояния объекта. Например, если вы 
используете объект класса, представляющий прогресс, и этот объект 
изменяется внутри разных потоков, может возникнуть путаница или проблемы с синхронизацией.
По этой причине лучше определить T как неизменяемый тип (или по 
крайней мере тип-значение). Если T является изменяемым ссылочным 
типом, то вам придется самостоятельно создавать отдельную копию при 
каждом вызове IProgress<T>.Report.

4. Progress<T> сохраняет текущий контекст при создании и активизирует 
свой обратный вызов в этом контексте. Это означает, что если Progress<T>
конструируется в UI-потоке, то вы сможете обновить пользовательский 
интерфейс из его обратного вызова, даже если асинхронный метод вызывает Report из фонового потока.

Если метод поддерживает уведомления о прогрессе, он также должен 
приложить максимальные усилия для поддержки отмены.

IProgress<T> не ограничивается одним асинхронным кодом; как прогресс, 
так и отмена также могут (и должны) использоваться в долгосрочном 
синхронном коде.


## 2.4. Ожидание завершения группы задач

### Задача

У вас есть несколько задач, и нужно подождать, пока они все закончатся.

### Решение

Task.WhenAll

```
Task<int> task1 = Task.FromResult(3);
Task<int> task2 = Task.FromResult(5);
Task<int> task3 = Task.FromResult(7);

int[] results = await Task.WhenAll(task1, task2, task3);
// "results" содержит { 3, 5, 7 }
```

Есть перегружденная версия Task.WhenAll, которая получает IEnumerable с задачами; тем не менее автор не 
рекомендует использовать ее. Лучше использовать асинхронный код вместе с LINQ, ему кажется, что код становится
более понятным

**Вот пример:**

```
async Task<string> DownloadAllAsync(HttpClient client, IEnumerable<string> urls)
{
	// Определить действие, выполняемое для каждого URL.
	var downloads = urls.Select(url => client.GetStringAsync(url));

	// Обратите внимание: задачи еще не запущены,
	// потому что последовательность не была обработана.

	// Запустить загрузку для всех URL одновременно.
	Task<string>[] downloadTasks = downloads.ToArray();

	// Все задачи запущены.
	// Асинхронно ожидать завершения всех загрузок.
	string[] htmlPages = await Task.WhenAll(downloadTasks);
	return string.Concat(htmlPages);
}
```

### Пояснение

Если какие-либо задачи выдают исключения, то Task.WhenAll сообщает об отказе своей возвращенной
задачи с этим исключением. Если сразу несколько задач выдают исключение, то все эти исключения 
помещаются в задачу Task, возвращаемую Task.WhenAll. Тем не менее при ожижании этой задачи
будет выдано только одно из них. Если нужно каждое конкретное исключение, проверьте свойство Exception
задачи Task, возвращаемой Task.WhenAll:

```
AggregateException allExceptions = allTasks.Exception;
```

## 2.5. Ожидание завершения любой задачи

## Задача

Есть несколько задач и требуется отреагировать на завершения любой задачи из группы. Задача
чаще всего встречается при выполнении нескольких независимых попыток выполнения операций 
в структуре "первому дается все". Например, можно запросить биржевые котировки у нескольких
веб-служб одновременно, но интересует вас только первый ответ.

## Решение

50