# Посмотреть позже:

1. Глава 6 про System.Reactive

2. Глава 7: рецепты начиная с 4

3. Глава 8: рецепты начиная с 5, + подразобраться с репептами 1-3

4. Глава 10: 10.6, 10.7

5. Глава 11: 11.4., 11.5, 11.6

6. Глава 13: 13.2, 13.4, 13,3

7. Глава 14: 14.2, 14.6

# Структура книги

1. В главе 1 содержится введение в различные виды конкурентности, 
описанные в книге: параллелизм, асинхронное и реактивное программирование, потоки данных.

2. В главах 2–6 представлено более подробное введение в разновидности 
конкурентности.

3. В каждой из оставшихся глав рассматривается конкретный аспект конкурентности; они также могут 
рассматриваться как сборник решений типичных проблем

# Главные моменты

1. Каждый поток имеет собственный независимый 
стек, но он совместно использует память со всеми остальными потоками 
процесса


2. Пул потоков содержит набор рабочих потоков, готовых к выполнению любой работы, которая им 
будет назначена. Пул потоков отвечает за определение количества потоков, 
находящихся в пуле потоков в любой момент времени.

3. Поток - низкоуровневая концепция. Работа с пулом потоков напрямую - чуть выше.
Параллельная обрабботка и потоки данных - еще выше. На нем мы и находимся.

4. Терминальный оператор и асинхронный делегат

5. Неизменяемые коллекции: (9 глава)

    Экземпляр никогда не изменяется
    Так как экземпляр никогда не изменяется, он потокобезопасен по своей природе
    При вызове изменяющего метода для неизменяемой коллекции возвращается новая измененная версия
    Неизменяемые коллекции являются потокобезопасными, но ссылки на них потокобезопасными не являются


6. (171 страница)
Одно важное примечание по поводу отсортированных множеств: индексирование 
для них выполняется за время O(log N), а не O(1), как у 
ImmutableList<T> (см. рецепт 9.2). Это означает, что в данной ситуации 
действует та же рекомендация: используйте foreach вместо for там, где 
это возможно, с ImmutableSortedSet<T>.

7. При использовании блокировок следуюет руководствоваться четырьмя важными рекомендациями:

1. Ограничье видимость блокировки

2. Документируйте, что именно защищает блокировка

3. Сократите до минимума объем кода, защищенного блокировкой

4. Никогда не выполняйте произвольный код при удержании блокировки

# Вопросы

1. В чем прикол потокобезопасных коллекций, если автор пишет, что надо чтобы операции были
достаточно редки

# Рассмотреть позже

1. Рецепт 5.4. BufferBlock, 9.9