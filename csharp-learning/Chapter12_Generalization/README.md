# Глава 12. Обобщения

1) Начало:
	1.1) Обобщения (generics) - еще один механизм, поддерживаемый общеязыковой исполняющей средой (CLR) и языками программирования
	1.2) Разработчик описывает алгоритм, не указывая тип данных, поэтому алгоритм может обобщенно применяться к объектам разных типов: Int32, String, например
	1.3) Поддерживаются обобщенные ссылочные и значимые типы, но обобщенные перечислимые типе нет. Также CLR поддерживает создание обобщенных методов, определенных в 
		ссылочном типе, в значимом типе или интерфейсе.
	1.4) Например, в FCL определен обобщенный алгоритм управления списками.
	1.5) При определении обобщенного типа или метода переменные, указывающие на типе (например, T), называются параметрами
		типа (type parameters), T - имя переменной, которое применяется в исходном тексте во всех местах, где используется соответствующий типа данных
	1.6) Рекомендации проектирование Microsoft утверждает, что переменные параметров должны называться T или по крайней мере, начинаеться с T: TKey, TValue
	1.7) В случае обобщенного типа или метода указанные типе данных называются аргументами типа (type arguments)
	1.8) Главные преимущества обобщений для разработчиков:
		1.8.1) Защита исходного кода. Разработчику, использующему обобщенный алгоритм, не нужен доступ к исходному тексту 
			алгоритма (при обработке с шаблонами C++ или обобщениями Java разработчику требуется исходный текст алгоритма)
		1.8.2) Безопасность типов. Компилятор и CLR обеспечивают, чтобы в алгоритма использовались лишь объекты совместимые с нужным типом данных.
		1.8.3) Более простой и понятный код. Нужно меньше операций приведения типов, такой код проще читать и поддерживать. 
		1.8.4) Повышение производительности. До появление дженериков, обобщенные алгоритмы писались с использованием Object. Чтобы такие алгоритмы работали 
			с экземплярами значимого типа, перед вызовом членом алгоритма среда CLR должна была упаковать этот экземпляр, что требует выделения памяти в heap, 
			что накладно по времени, ресурсам, и чаще страртует GC, что снижает производительность. Поскольку обобщения работают с конкретным значимым типом,
			экземпляры значимого типа могут передаваться по значению и CLR не надо выполнять упаковку. Операции приведения типов также не нужны, и CLR не надо 
			контролировать безопасность типов при их преобразовании.
	
			На тестовом примере видно следующее:
			1. с типом Int32 (value type) обобщенный алгоритм List работает гораздно быстрее, чем с необобщенным
			Разница в 20 раз в работе. Кроме того, использование значимого типа с алгоритмом ArratList требует
			множества операций упаковки, и как результат, 33 процедуры сборки мусора, а в алгоритме List не 
			требуется операций упаковки и сборки мусора (у меня правда почему-то 3 раза прошел GC)
			2. для ссылочных типов разницы нет разницы в производительности.
	1.9) CLR генерирует машинный код для любого метода при первом его вызове в применении к конкретному типу данных. 
		Это увеличивает размер рабочего набора приложения и снижает производительность. 


2) Обобщения в библиотеке FCL
	2.1) System.Collections.Generic и System.Collections.ObjectModel. Обобщения применяется с классами
		коллекций, и в FCL определено несколько таких обобщенных классов, их можно найти в этих namespaces.
		Также есть безопасные относительно потоков классы коллекций из System.Collections.Concurrent
	2.2) Microsoft рекомендует отказаться от необобщенных классов коллекций в пользу обобщенных аналогов 
		по 2 причинам. 1 мы уже затрагивали: это производительность, понятность кода
		2 причина заключается в том, что объектная модель у обобщенных классов лучше. У них меньше виртуальных 
		методов, что повышает производительности, а новые члены, добавленные в обобщенные коллекции, предоставляют
		массу новых возможностей
	2.3) Новые обобщенные интерфейсы не заменяют необобщенные: во многих ситуациях приходится задействовать
		оба вида интерфейсов. Причина - необходимость поддержания обратной совместимости. Например, 
		если бы класс List<T> реализовал только IList<T>, в коде нельзя было бы расматривать объект
		List<DateTime> как IList
		Также, например, класс System.Array, базовый для всех типов массиво, поддерживает множество 
		статических обобщенных методов, в том числе AsReadOnlyBinarySearch, Exists, Find и т.д.
		Вот так выглядят некоторые из них:
		```
		public abstract class Array : ICloneable, IList, ICollection, IEnumerable
		{
			public static void Sort<T>(T[] array);

			public static void Sort<T>(T[] array, IComparer<T> comparer);
			public static Int32 BinarySearch<T>(T[] array, T value);
		}
		```

3) Библиотека Power Collections производства Wintellect
	3.1) По заказу Microsoft компания Wintellect разработала библиотеку Роwег 
		Collections, основное назначение которой - сделать некоторые классы коллекций из SТL-библиотеки 
		С++ доступными для CLR. Классы библиотеки Power Collections распространяются бесплатно (детали на http://Wintellect.com).
		Эти классы коллекций сами по себе являются обобщенными и в них широко используются обобщения
	![](images/power_collections_wintellect.png)

4) Инфраструктруа обобщений
	4.1) Обобщения были добавлены в версию 2.0 CLR, над реализацией обобщений долго работало множество специалистов
		Для поддержания работы обобщений Microsoft нужно было сделать следующее:
		4.1.1) Создать новые IL-команды, работающие с аргументами типа.
		4.1.2) Изменить формат существующих таблиц метаданных для выражения имен типов и методов 
			с обобщенными параметрами
		4.1.3) Обновить япы, чтобы обеспечить поддержку нового синтаксиса обобщений
		4.1.4) Изменить компиляторы для генерации новых IL-команд и измененного формата метаданных
		4.1.5) Изменить JIT-компилятор, чтобы он обрабатывал новые IL-команды, работающие с аргументами типа, 
			и создавал корректный машинный код
		4.1.6) Создать новые члены отображения, для того, чтобы разработчиик с помощью запроса могли проверять
			наличие обобщенных параметров у типов и членов
		4.1.7) Определить новые предоставляющие информацию отражения члены, что позволило разработчикам создавать 
			обобщенные определения типов и методов во время исполнения
		4.1.8) Изменить отладчик, чтобы он поддержал обобщенные типы, члены, поля и локальные переменные
		4.1.9) Изменить механизм IntelliSense в VS для вызова конкретных прототипов членов при использовании
			обобщенного типа или метода с указанием типа данных

А теперь нужно рассмотреть, как работают с обобщениями внутренние механизмы CLR. Эта информация может 
пригодиться как при проектировании и создании обобщенных алгоритмов, так и при выборе готовых обобщенных
алгоритмов.
5) Открктые и закрытые типы
	5.1) CLR создает внутренню структуру данных для каждого типа, приняемого в приложении. Эти структуры
		данных называют объектами типа (type objects). Тип с обобщенными параметрами типа также считается 
		типом, причем для такого типа CLR создает внутренний объект типа. Это справедливо для ссылочных типов
		(классов), значимых типов (структур), интерфейсов и делегатов. Тем не менее тип с обобщенными параметрами
		типа называют открытым типом (open type), а в CLR запрещено конструирование экземпляров открытых типов
		(как и экземпляров интерфейсных типов)
	5.2) При ссылке на обобщенный тип в коде можно определить набор обобщенных аргументов типа. Если всем аргументам
		определенного типа переданы действительные типы данных, то он становится закрытым типом (closed type).
		CLR разрешает создание экземпляров закрытых типов. 