# Глава 26. Потоки исполнения

В этой главе мы познакомимся с потоками исполнения, или просто потоками. Будет идти речь о том,
почему в Windows появилась концепция потоков, о тенденциях развития процессоров, о 
взаимоотношениях потоков CLR и Windows-потоков, о дополнительных затратах ресурсов при 
использовании потоков, о планировании исполнения потоков в Windows, о классах .NET, предоставляющих
доступ к свойствам потоков и многом другом.

В главах 5 части книги объясняется, каким образом Windows взаимодействует с CLR для 
формирования архитектуры потоков. 

## Для чего Windows поддерживает потоки?

На заре компьютерной эры ОС не поддерживали концепцию потоков. Существовал всего один поток,
обслуживающий как код ОС, так и код приложений. В результате этот поток могла блокировать 
большая задача, препятствующая выполнению других. Например, во времена 16 разрядной системы
Windows обычной была ситуация, когда распечатывающее документ приложение приостанавливало 
работу всей машины. ОС и остальные приложения зависали. А если вдруг в приложении возникала 
ошибка, которая приводила к бесконечному циклу, она вообще порождала массу проблем.

Пользователю оставалось только перезагрузить компьютер, нажав кнопку Resrt или выключатель 
питания. Разумеется, пользователи ненавитеди такие ситуации, потому что запущенные 
приложения при этом аварийно завершались, а обрабатываемые данные стирались из памяти. Поэтому
в Microsoft решили, что нужно создать новую ОС, которая должна была быть устойчивой, надежной, 
расширяемой, безопасной и избавленной от большинства недостатков своей предшественницы. 
Ядро этой операционной системы впервые было выпущено в составе Windows NT.

При разработке нового ядра ОС было решено запускать каждый экземпляр приложения в отдельном 
процессе. Процессор называется набор ресурсов, используемый отдельным экземпляром приложения.
Каждому процессу выделяется виртуальное адресное пространство; это гарантирует, что код и 
данные одного процесса будут недоступны для другого. Это делает приложения отказоустойчивыми, 
поскольку при таком подходе один процесс не может повредить код или данные другого. Код 
и данные ядра также недоступны для процессов, а значит, код приложений не в состоянии 
повредить код или данные ОС. Это упрощает работу пользователей. Система также  более 
безопасной, потому что код произвольного приложения не имеет доступа к именам пользователей,
паролям, информации кредитной карты или иным конфиденциальным данным, а которыми 
работают другие приложения или сама операционная система.

А что с ЦП? Что если приложение войдет в бесконечный цикл? Если процессор всего один, приложение
будет выполнять этот бесконечный цикл и не сможет уделять внимание другим операциям. Несмотря
на очевидные преимущества (неповрежденные данные и более высокая степень безопасности),
система, как и ее предшесвенницы, не сможет реагировать на действия конечного пользователя. 
Для решения этой проблемы и были придуманы потоки. Именно поток стал той концепцией, которая
предназначена для виртуализации процессора в Windows. Каждому Windows-процессу выделяется
собственный поток исполнения (который работает как виртуальный процессор). Если код приложения
войдет в бесконечный цикл, то блокируется только связанный с этим кодом процесс, а остальные
процессы (исполняющиеся в собственных потоках) продолжают функционировать!

## Ресурсоемкость потоков

Потоки — замечательное изобретение; ведь именно благодаря им Windows реагирует 
на наши действия даже несмотря на то, что отдельные приложения могут быть заняты 
исполнением длительных заданий. Кроме того, с помощью одного приложения 
(например, диспетчера задач) можно принудительно прекратить работу другого приложения, 
если оно перестает отвечать на запросы. Однако как и любые механизмы 
виртуализации, потоки потребляют дополнительные ресурсы, требуя пространства 
(памяти) и времени (снижая производительность среды исполнения).

Рассмотрим эти проблемы более подробно. Каждый поток состоит из нескольких частей.

1. **Объект ядра потока.** Для каждого созданного в ней потока ОС выделяет и инициализирует 
одну из структур данных. Набор свойств этой структуры описывает поток. Структура содержит также
так называемый контекст потока, то есть блок памяти с набором регистров процессора. На машине
с процессором x86, x64 и ARM контекст занимает около 700, 1240 и 350 байт соответственно.

2. **Блок окружения потока (TEB).** Это место в памяти, выделенное и инициализированное в 
пользовательском режиме (адресное пространство, к которому имеет быстрый доступ код приложений).
Этот блок занимает одну страницу памяти (4Кб для процесоров x86, x64, ARM). Он содержит 
заголовок цепочки обработки исключений. Каждый блок try, в который входит поток, вставляет
свой узел в начало цепочки. Когда поток выходит из блока try, узел из цепочки удаляется. Также
TEB содержит локальное хранилище данных для потока и некоторые структуры данных, используемые
интерфейсом графических устройств (GDI) и графикой OpenGL.

3. ***Стек пользовательского режима.* Применяется для хранения передаваемых в методы локальных
переменных и аргументов. Также он содержит адрес, показывающий, откуда начнет исполнение
поток после того, как текущий метод возвратит управление. По умолчанию на каждый стек пользовательского
режима Windows выделяет 1Мб памяти (а точнее, резервирует 1Мб памяти и добавляет физическую
память по мере необходимости при росте стека)

4. **Стек режима ядра.** Используется, когда код приложения передает аргументы в функцию ОС,
находяющуюся в режиме ядра. Для безопасности Windows копирует все аргументы, передаваемые в 
ядро кодом в пользовательском режиме, из стека потока пользовательского режима в стек
режима ядра. После копирования ядро проверяет значения аргументов. Так как код приложения
не имеет доступа к стеку режима ядра, приложение не в состоянии изменить уже проверенные 
аргументы, и с ними начинает работать код ядра ОС. Кроме того, ядро вызывает собственные
методы и использует стек режима ядра для передачи локальных аргументов, а также для сохранения
локальных переменных функции и обратного адреса. В 32 разрядной вверсии Windows стек режима 
ядра занимает 12Кб, а в 64 разрядной - 24Кб.

5. **Уведомления о создании и завершении потоков.** Политика Windows такова, что если в 
процессе создается поток, то для всех загруженных в этот процесс DLL библиотек вызывается 
метод DllMain и в него передается флаг DLL_THREAD_ATTACH. Соответственно, при завершении
потока этому методу передается уже флаг DLL_THREAD_DETACH. Получая уведомления об этих 
событиях, некоторые DLL-библиотеки выполняются специальные операции инициализации или
очистки для каждого созданного/завершенного в процессе потока. К примеру, DLL библиотека
C-Runtime выделяет место под хранилище локальных состояний потока, необходимое для 
использования потоком функций из указанной библиотеки.

Теперь вы видите, каких затрат времени и памяти стоит создание потока, его 
поддержание в системе и завершение. Но на самом деле ситуация еще хуже из-за 
необходимости переключения контекста (context switching). Компьютер с одним 
процессором может одновременно выполнять только что-то одно. Следовательно, 
операционная система должна распределять физический процессор между всеми 
своими потоками (логическими процессорами).

В произвольный момент времени Windows передает процессору на исполнение 
один поток. Этот поток исполняется в течение некоторого временного интервала, 
иногда называемого тактом (quantum). После завершения этого интервала контекст Windows 
переключается на другой поток. При этом обязательно происходит 
следующее:

1. Значения регистров процессора исполняющегося в данный момент потока сохраняются в 
структуре контекста, которая, распологается в ядре потока.

2. Из набора имеющихся потоков выделяется тот, которому будет передано управление. Если 
выбранный поток принадлежит другому процессу, Windows переключает для процессора виртуальное
адресное пространство. Только после этого возможно выполнение какого-либо кода или 
доступ к каким-либо данным.

3. Значения из выбранной структуры контекста потока загружаются в регистры процессора.

После переключения контекста процессор исполняет выбранный поток, пока 
не истечет выделенное потоку время, после этого снова происходит переключение 
контекста. Windows делает это примерно каждые 30 мс. Никакого выигрыша в производительности 
или потреблении памяти переключение контекстов не дает. Оно 
требуется только для того, чтобы операционная система была надежной и быстро 
реагировала на действия конечных пользователей.

Если поток какого-то приложения зацикливается, Windows его периодически выгружает и передает 
процессору другой поток для исполнения. К примеру, это может быть поток диспетчера задач, 
позволяющий завершить процесс, в котором исполняется зависший поток. Процесс прекращает 
свою работу, теряя несохраненные данные, но остальные процессы в системе продолжают 
функционировать, как ни в чем ни бывало. Пользователю не приходится перезагружать компьютер.
Переключение контекстов приводит к повышению отказоустойчивости, хотя за это приходится платить
снижением производительности.

На самом деле издержки еще выше, чем можно предположить. При переключении контекста 
на другой поток производительность серьезно падает. Пока работа 
ведется с одним потоком, его код и данные находятся в кэше процессора, чтобы 
обращения процессора к оперативной памяти, замедляющие работу, происходили 
реже. Однако новый поток, скорее всего, исполняет совсем другой код и имеет 
доступ к другим данным, которых еще нет в кэше процессора. Значит, прежде чем 
вернуться к прежней скорости работы, процессор вынужден некоторое время обращаться 
к оперативной памяти, наполняя кэш. А примерно через 30 мс происходит 
очередное переключение контекста.

Время переключения контекста зависит от архитектуры процессора и его быстродействия. 
А время заполнения кэша зависит от запущенных в системе приложений, 
размера самого кэша и ряда других факторов. Поэтому оценить, с какими временными 
затратами связано каждое переключение контекста, невозможно. Достаточно просто запомнить, 
что при разработке высокопроизводительных приложений 
и компонентов переключения контекста нужно по возможности избегать.

### ВНИМАНИЕ

Если в конце временного промежутка Windows решает продолжить исполнение уже
исполняемого потока (а не переходить к другому), переключения контекста не происходит. 
Это значительно повышает производительность.

### ВНИМАНИЕ

Потко может самопроизвольно уступить управление до завершения такта, что происходит довольно 
часто, например, если поток ожидает ввода-вывода (клавиатура, мышь, файл, сеть...). Так,
потом приложения Notepad обычно ничего не делает, ожидая ввода данных. При нажатии пользователем
клавиши Windows пробуждает этот поток, чтобы тот обработал данное действие. Обработка занимает 
всего 5мс, после чего вызывается Win32-функция, сообращющая Windows о готовности к обработке
следующего события ввода. Если события ввода отсутствуют, поток переводится в состояние
ожидания (с отказом от оставшейся части такта). В результате поток не будет планироваться на 
исполнение процессором до следующего события ввода. Такой подход повышает производительность
системы, потому что потоки, находяющиеся в состоянии ожидания, не расходуют попусту процессорное
время.

Из всего вышеизложенного можно сделать вывод, что потоки это плохо, так как при переключении 
контекста и уборке мусора снижается производительности и время тратиться впустую. С другой стороны,
без потоков тоже не обойтись, так как именно они обеспечивают в Windows приемлемые показатели
надежности и времени реакции.

Не стоит забывать про многоядерность, которая улучшает масштабируемость системы (способность
выполнения большей работы за меньшее время). Каждому ядру процессора назначается свой поток,
и это ядро организует собственное переключение контекста. ОС следит за тем, чтобы один поток
не планировался одновременно на нескольких ядрах, так как это привело бы к хаосу. 
В настоящее время почти все компьютеры многопроцессорны, но раньше был всего один поток. Для 
этого и были введены потоки. В настоящее время потоки позволяют повысить производительности 
на машинах с несколькими ядрами.

В оставшихся главах этой книги рассматриваются механизмы Windows и CLR, позволяющие эффективно
ответить на вопрос, как при минимальном количестве потоков сохранить работоспособность кода
и каким образом масштабировать код для исполнения на машине с многоядерным процессором.

## Так дальше не пойдет!

Если думать только о производительности, оптимальное чисто потоков на машине должно быть равно
числу установленных на ней процессоров. Причины очевидны: если количество потоков превышает
количество процессоров, начинается переключение контекста. А при наличии одного потока на 
процессор контекстное переключение не требуется, и все потоки исполняются на полной скорости.

Тем не менее при разработке Windows специалисты отдали предпочтение надежности и быстроте
реакции на действия пользователя, а не скорости расчетов и производительности выполнения 
приложений. По мнению Рихтера это правильно, тк вряд ли бы была польза от того, что приложения
по-прежнему могли блокировать работу ОС и других приложений. Именно поэтому каждому процессу 
выделяется свой поток, что повышает надежность система и быстроту реакции.

Рихтер показал, что у него было создано 55 прцоессов, 864 потоков. Также показано было,
что загрузка процессора составляет всего 5%. Это значит, что 95% времени эти 854 потока ничего
не делают, просто занимают память, которая не используется, пока потоки не начинают
исполняться. 

Нужны ли приложениям все эти ничего не делающие потоки? Разумеется, нет!

Процессы создают потоки, которые даже не используют. Они просто ждут, когда же надо будет
начать работу. Знакомясь с Windows, разработчики узнают, что создание процессов в этой ОС -
доростоящая процедура. Создание процесса занимает несколько секунд, требует выделения 
изрядного объема памяти, эту память требуется инициализировать, нужно загрузить с диска
exe и dll файлы. По сравнению с этим создать поток достаточно просто. Поэтому разработчики
вместо процессов предпочитают создавать потоки, множество которых мы и видим перед собой.
Но в сравнениис большинством других системных ресурсов создание потока - не такая уж 
дешевая процедура. И применять их следует осмотрительно и только там, где они действительно
уместны.

Как видите, упомянутые приложения используют потоки не эффективно. Непонятно, зачем эти потоки
вообще существуют в системе. Одно дело - выделить ресурсы для приложения, и совсем другое - 
выделить их и не использовать. Ведь выделение памяти под стеки потоков означает, что ее останется
меньше для более важных данных, например документов пользователя.

А теперь представьте, что процесс запущен в сеансе удаленного рабочего стола одного пользователя,
но у машине на самом деле 100 пользователей. То есть запускается 100 экземпляров приложения
Outlook, каждый из которых создает 24 ничего не делающих потока. Мы получаем 2400 потоков,
каждый с собственным ядром, TEB, стеком режима пользователя, стеком режима ядра и т.п. 
Огромное количество впустую потраченных ресурсов. Эту практику пора прекращать, особенно 
если Microsoft Хочет, чтобы пользователи успешно работали с Windows на нетбуках, на большинстве
которых всего 1Гбит оперативы. Именно практике эффективного проектирования приложений с минимальным
количеством потоков и посвящены последние главы этой книги.

## Тенденции развития процессоров

С проблемами, связанные с наращиванием мощностей приложений, приходится сталкиваться всем 
производителям программного обеспечения. Из-за отсутствия возможности бесконечно наращивать 
скорость процессоров, они пытаются уменьшить транзисторы, чтобы на одной микросхеме
можно было разместить их больше. Уже существуют кремниевые микросхемы, содержающие 2 и более
процессорных ядра. А значит скорость функционирование ПО повысится только при условии, что оно
умеет работать с несколькими ядрами. Как этого добиться? Разумно использовать потоки.
В настоящее время существуют три вида многопроцессорных технологий:

1. **Многопроцессорные решения.** Некоторые компьютеры просто оснащают несколькими процессорами.
Другими словами, на материнской плате находятся несколько гнезд, в каждом из которых располагается 
процессор. Это приводит к увеличению размеров материнской платы. а значит и корпуса. В некоторых
случаях приходится ставить также дополнительные источники питания из-за потребления энергии.
Такие компьютеры использовались в течении нескольких десятилетий, но постепенно их популярность
сходит на нет из-за большого размера и высокой стоимости.

2. **Гиперпотоковые микросхемы.** Эта технология от Intel позволяет одной микросхеме функционировать
как две. Микросхема содержит два набора архитектурных состояний, такие как регистры процессора,
при этом имеется всего один набор механизмов исполнения.
Для Windows это выглядит как наличие 
в машине двух процессоров, и операционная система одновременно планирует 
поведение двух потоков, однако исполняется только один из них. Как только он 
прерывается из-за недостатка размера кэша, ошибочного прогнозирования ветви 
или зависимости по данным, микросхема переключается на другой поток. Все 
это происходит на аппаратном уровне, и Windows об этом не «знает». С точки 
зрения операционной системы оба потока выполняются одновременно. При наличии на одной 
машине нескольких гиперпотоковых процессоров операционная 
система сначала назначит по одному потоку на каждый процессор, в результате 
чего они действительно будут выполняться одновременно. Все же остальные 
потоки будут распределяться по уже занятым процессорам. По утверждениям 
Intel, такой подход повышает производительность на 10–30 %

3. **Многоядерные микросхемы.** Несколько лет назад появились микросхемы, содержащие 
более одного процессорного ядра. На момент написания этой книги 
были доступны микросхемы с двумя, тремя и четырьмя ядрами.

## CLR и Windows потоки

В настоящее время CLR использует способность Windows работать с потоками, 
поэтому часть V данной книги посвящена рассмотрению возможностей, которые 
открываются перед разработчиками, создающими код с помощью CLR. 

На первых порах существования .NET Framework проектировщики CLR 
решили, что среда CLR должна поддерживать логические потоки, которые не 
обязаны однозначно соответствовать потокам Windows. В 2005 году группа CLR 
отказалась от этой идеи, так что в настоящее время CLR-потоки аналогичны 
Windows-потокам, однако в .NET Framework встречаются отдельные пережитки 
прежних попыток. Например, класс System.Environment предоставляет свойство 
CurrentManagedThreadId, которое возвращает CLR-идентификатор потока, тогда 
как класс System.Diagnostics.ProcessThread предоставляет свойство Id для получения 
Windows-идентификатора того же потока. Методы BeginThreadAffinity
и EndThreadAffinity класса System.Thread также были введены в предположении 
о том, что CLR-поток может не совпадать с Windows-потоком

### Потоки для асинхронных вычислительных операций

В этой части покажут, как создать поток и заставить его исполнить асинхронную вычислительную 
операцию. Однако, так лучше не делать, из-за того, что для приложений Windows Store невозможно
использовать класс Thread. По возможности для этой цели лучше прибегать к доступному 
в CLR пулу потоков.

Возможны ситуации, когда требуется явно создать поток для выполнения конкретной 
вычислительной операции. Обычно такая необходимость возникает при 
выполнении кода, приводящего поток в состояние, отличное от обычного состояния 
потока из пула. К примеру:

1. Поток требуется запустить с нестандартным приоритетом (все потоки пула 
выполняются с обычным приоритетом). Хотя изменить приоритет можно, но 
делать это не рекомендуется, кроме того, изменение приоритета не сохраняется 
между операциями с пулом потоков

2. Чтобы приложение не закрылось до завершения потоком задания, требуется, 
чтобы поток исполнялся в фоновом режиме. Эта тема подробно рассмотрена 
в разделе «Фоновые и активные потоки» далее в этой главе. Потоки из пула 
всегда являются фоновыми, и существует риск, что они не успеют выполнить 
задание из-за того, что CLR решит завершить процесс

3. Задания, связанные с вычислениями, обычно выполняются крайне долго; для 
подобных заданий я не стал бы отдавать решение о необходимости создания 
нового потока на откуп логике пула потоков

4. Возможно возникнет необходимость преждевременно завершить исполняющийся поток методом 
Abort класса Thread

Для создание выделенного потока потребуется создать экземпляр класса 
System.Threading.Thread, для получения которого следует передать конструктору имя метода.
Вот прототип такого конструктора:

```
public sealed class Thread : CriticalFinalizerObject, ... {
	public Thread(ParameterizedThreadStart start);
	// Здесь не показаны редко используемые конструкторы
}
```

Параметр start задает метод, который будет выполняться в выделенном потоке. Сигнатура этого
метода должна совпадать с сигнатурой делегата ParameterizedThreadStart:

### ПРИМЕЧАНИЕ

Класс Thread также предлагает конструктор, принимающий делегат ThreadStart, который
не имеет аргументов и не возвращает значений. Но лично я не рекомендую их использовать 
из-за многочисленных ограничений. Если метод вашего потока принимает класс Object и 
возвращает значение типа void, вызовите его при помощи выделенного потока или пула 
потока, как показано в главе 27

```
delegate void ParameterizedThreadStart(Object obj);
```

Создание объекта Thread является достаточно простой операцией, так как при этом физический 
поток в ОС не появляется. Для создания физического потока, призванного исполнить метод
обратного вызова, следует воспользоваться методом Start класса Thread, передав в него объекта
(состояние), который вы хотите сделать аргументом метода обратного вызова.

В приведенном примере показана процедура создания выделенного потока, который затем асинхронно
вызывает метод.

Поскольку мы не можем контролировать очередность исполнения потоков в Windows, возможен другой 
вариант очередности потоков.

Метод Join заставляет вызывающий поток остановить выполнение любого кода до момента, пока поток, 
определенный при помощи dedicatedThread, не завершиться сам или не будет завершен.

## Причины использования потоков

Потоки используются по двум оновным причинам:

1. **Улучшение времени отклика (обычно для клиентских приложений с графическим интерфейсом).**
Windows выделяет каждому приложению отдельный поток, чтобы зацикливание одного приложения
не мешало работе остальных. Аналогичным образом в клиентских приложениях с UI можно 
выделить часть работы в отдельный поток, чтобы интерфейс продолжал реагировать на действия
пользователя. Вероятно, в этом случае количество потоков превысит количество ядер, что
обернется лишними затратами системных ресурсов и снижением производительности. С другой стороны,
пользовательский интерфейс быстрее реагирует на действия пользователя, улучшая его впечатления
от работы с приложением.

2. **Производительность (для клиентских и серверных приложений).** Так как система Windows 
может планировать по одному потоку на процессор, а процессоры могут исполнять потоки одновременно,
паралелльное выполнение нескольких операций улучшит производительности приложения. Конечно,
улучшение достигается только в том случае, если приложение выполняется на машине с несколькми
процессорами. 

###Теория Рихтера
Он считает, что процессоры в машине должны использоваться на все 100%. Впрочем тут надо внести
две оговорки. Во первых, при питании от аккумулятора 100 процентное использование процессора
сократит время работы с машиной. Во вторых, в некоторых центрах обработки данных предпочитают
иметь десять компьютеров с процессорами, работающими на половинной мощности, вместо пяти,
процессоры которых загружены на 100. Дело в том, что полностью нагруженный процессор выделяет
тепло, а значит требуется охлаждение системы. ОДнако питание такой системы может оказаться более
затратным делом, чем питание большего количества компьютеров, работающих на меньшей мощности.
Впрочем, наличие большего количества компьютеров тоже значительно повышает издержки, ведь 
каждый из них требует периодического обновления аппаратного и программного обеспечения.

В прошлом как разработчики, так и конечные пользователи считали, что мощности 
компьютеров недостаточна. Поэтому код не выполнялся, пока конечный пользователь не давал 
на это разрешения при помощи таких элементов UI, как пункты меню, кнопки, флажки, тем самым 
явно показывая, что согласен предоставить приложению необходимые ресурсы процессора.

Сейчас все изменилось. Современные ПК достаточно мощны и в ближайшем будущем могут стать еще
более мощными. Как уже упоминалось, процессор занят 5% времени. Если бы ядер было не два, а 4,
такая ситуация возникала бы еще чаще. Когда появится 80 ядерный процессор, вообще получится, что 
практически все время компьютер ничего не делает. С точки зрения потребителя получается, что 
за большие деньги машина выполняет меньше работы.

Именно поэтому производители аппаратного обеспечения с трудом продают пользователям 
многоядерные процессоры. ПО не может полноценно использовать предоставляемые ресурсы, а значит,
пользователь не получает выгоды от покупки машины с доп ядрами. То есть, в настоящее время
мы имеем избыток компьютерных мощностей, поэтому разработчики могут себе позволить их 
активное потребление. Раньше даже помыслить нельзя было, чтобы приложение занималось 
дополнительным вычислениями, если не было полной уверенности, что конечному пользоватлю 
понадобится результат этих вычислений. Но теперь, это стало возможным.

Например, по завершении набора текста в редакторе Visual Studio это приложение 
автоматически вызывает компилятор и обрабатывает введенный код. Такой 
подход повышает продуктивность труда разработчиков, так как они сразу видят 
ошибки вводимого кода и немедленно могут их исправить. Фактически в настоящее 
время из последовательности редактирование-построение-отладка пропал центральный член, 
так как построение (компиляция) кода осуществляется непрерывно. 
Конечные пользователи этого даже не замечают благодаря мощному процессору. 
Ведь частый запуск компилятора никак не отражается на решении других задач. 
Я думаю, что в будущих версиях Visual Studio из меню исчезнет пункт Build, так 
как компиляция станет полностью автоматической. Не только упрощается пользовательский 
интерфейс, но и само приложение дает «ответы» на нужды конечного 
пользователя, повышая продуктивность его работы.

С исключением отдельных пунктов меню пользоваться приложением становится 
проще. Остается меньше вариантов и меньше концепций, которые следует прочитать 
и запомнить. Именно многоядерная конфигурация позволяет упростить пользование 
компьютером настолько, что в один прекрасный день с ним сможет работать 
даже моя бабушка. Для разработчиков удаление элементов пользовательского интерфейса 
означает меньший объем тестирования и упрощение основы кода. Кроме 
того, ослабляется острота проблемы локализации интерфейса и сопроводительной 
документации. Все это дает возможность экономить время и деньги.

Вот еще несколько примеров активного потребления ресурсов процессора: 
проверка орфографии и грамматики в документах, пересчет электронных таблиц, 
индексирование файлов на диске для ускорения процедуры поиска и дефрагментация 
жесткого диска для повышения производительности ввода-вывода.

Мне нравится мир, в котором пользовательские интерфейсы минимизируются 
и упрощаются, оставляя больше места для визуализации данных, а приложения 
сами предлагают информацию, помогающую быстро решать насущные задачи. 
Пришло время творчески использовать программное обеспечение

## Планирование и приоритеты потоков

Операционные системы с вытесняющей многозадачностью должны использовать некий алгоритм, 
определяющий порядок и продолжительность исполнения 
потоков. В этом разделе рассмотрен алгоритм, применяемый в Windows.
Уже упоминалось о наличии в каждом ядре потока контекстной структуруры, отражающей состояние
регистров процессора потока во время его исполнения. После каждого такта Windows 
просматривает все существующие ядра потоков в поиске потоков, которые не находятся 
в режиме ожидания, выбирает один из них и переключает на него контекст. При этом фиксируется,
сколько раз каждый из потоков потребовал переключения контекста.

Эту информацию можно увидеть в окне приложения Microsoft Spy++, в котором выводятся
свойства всех потоков. 

Каждый поток, исполняет код и манипулирует данным в адресном пространстве процесса. Через 
такт Windows переключает контекст. Переключения контекста продолжаются с момента загрузки ОС
и до завершения ее работы.

Windows называют многопоточной ОС с вытесняющей многозадачностью, потому что каждый поток
может быть остановлене в произвольный момент времени и вместо него выбран для исполнения другой.
Как вы увидите этим процессом в какой-то степени можно управлять, но нельзя гарантировать, что
поток будет исполняться постоянно без прерывания другими потоками.

### ПРИМЕЧАНИЕ

Разработчики часто задают вопрос: каким образом можно гарантированно запустить
поток через определенное время после какого-то события? Например, как запустить
определенный поток через 1 мс после прохождения данных через последовательный
порт? Я отвечаю просто: это невозможно.
Такие вещи возможны в операционных системах реального времени, но Windows
к ним не относится. Операционные системы реального времени требуют досконального знания 
оборудования, на базе которого они работают. То есть вам должны
быть известны задержки контроллеров жесткого диска, клавиатуры и других компонентов. 
Платформа Windows создавалась в Microsoft для работы с самым разным
аппаратным обеспечением: различными процессорами, драйверами, сетями и т. п. 
Именно поэтому она не является операционной системой реального времени. 
Следует добавить, что из-за CLR управляемый код еще хуже приспособлен для работы в 
реальном времени. Причин этому много, в том числе динамическая загрузка
библиотек, JIT-компиляция кода и уборка мусора, начало выполнения которой невозможно 
спрогнозировать.

Каждому потоку назначается уровень приоритета с нулевого до 31. При выборе потока, который 
будет передан процессору, сначала рассматриваются потоки с самым высоким приоритетом 
и ставятся в очередь в цикле. При обнаружения потока с приоритетом 31 он передается процессору.
После завершения такта ищется следующий поток с аналогичным приоритетом, чтобы преключить на 
него контекст.

При наличии в очереди потоков с приоритетом 31 система никогда не передаст 
процессору поток с меньшим приоритетом. Это условие называется голоданием
(starvation), а возникает оно в случае, когда потоки с высоким приоритетом потребляют 
практически все время процессора и не дают исполняться потокам более 
низкого приоритета. Голодание намного реже возникает на машинах с многопроцессорной конфигурацией,
на которых потоки с приоритетом 30 и 31 могут исполняться одновременно. Система всегда старается
загрузить процессор, поэтому он простаивает только при отсутствии готовых к исполнению потоков.

Потоки с высоким приоритетом всегда исполняются перед потоками с низким 
приоритетом вне зависимости от того, какие задания выполняют последние. Если 
в системе работает поток с приоритетом 5 и система определяет, что поток с более 
высоким приоритетом готов к работе, исполнение немедленно приостанавливается 
(даже если поток находится в середине такта) и процессору передается 
новый поток.

В процессе загрузки система создает поток обнуления страниц (zero page thread), 
которому назначается нулевой приоритет. Это единственный поток в системе с таким 
приоритетом. Его задача состоит в обнулении свободных страниц и исполняется 
он только при отсутствии других потоков.

Ясное дело, что с точки зрения разработчика сложно придумать рациональное 
объяснение назначению потокам приоритетов. Почему одному потоку присвоен 
приоритет 10, а другому — 23? Для решения этого вопроса Windows вводит абстрактную 
«прослойку» над уровнем приоритетов.

При разработке приложения следует решить, должно ли оно реагировать быстрее 
или медленнее, чем другие запущенные на этой же машине приложения. В соответствии с 
этим решением выбирается класс приоритета для процесса. В Windows 
поддерживаются шесть классов приоритетов: Idle (холостого хода), Below Normal
(ниже обычного), Normal (обычный), Above Normal (выше обычного), High (высокий) и 
Realtime (реального времени). По умолчанию выбирается приоритет Normal, 
он же является самым распространенным.

Приоритет холостого хода подходит для приложений, которые запускаются 
в системе, где больше ничего не происходит (это такие приложения, как хранители 
экрана). Даже не используемый в интерактивном режиме компьютер может быть 
занят (к примеру, функционируя как файловый сервер) и не должен конкурировать 
за процессорное время с хранителем экрана. Приложения для сбора статистики, 
периодически обновляющие некоторое состояние, обычно тоже не должны становиться 
препятствием для более важных заданий.

Высокий приоритет следует использовать только там, где это действительно необходимо. 
А приоритета реального времени вообще лучше по возможности избегать. 
Его выбор может помешать выполнению таких системных заданий, как дисковый 
ввод-вывод или передача данных по сети. Поток с приоритетом реального времени 
может помешать обработке данных, вводимых с клавиатуры или при помощи мыши, 
создавая у пользователя впечатление, что система перестала работать. По большому 
счету для выбора такого приоритета нужно иметь веские основания, например необходимость 
с минимальной задержкой отвечать на события аппаратного уровня 
или выполнять какие-то кратковременные задания.

Выбрав класс приоритета, не нужно думать о том, как ваше приложение соотносится со 
всеми остальными приложениями, достаточно сосредоточиться на потоках 
своего приложения. В Windows поддерживаются семь относительных приоритетов 
потоков: Idle (холостого хода), Lowest (самый низкий), Below Normal (ниже обычного), 
Normal (обычный), Above Normal (выше обычного), Highest (самый высокий) 
и Time-Critical (требующий немедленной обработки). Эти приоритеты соотносятся с 
классами приоритетов процесса. По умолчанию для потоков используется 
обычный приоритет, соответственно, он применяется чаще всего.

Подводя итог, скажем, что процесс является членом класса приоритета и внутри 
него потокам назначаются связанные друг с другом приоритеты. Если вы заметили,
я ничего не говорил об уровнях приоритета с нулевого по 31. Разработчики приложений 
никогда не имеют с ними дела напрямую. За них это делает система. 
Соотношение между классом приоритета процесса, относительным приоритетом 
потока и итоговым уровнем приоритета иллюстрирует таблица:

![](images/process_priority_table.png)

Обратите внимание: в таблице нет комбинации, при которой поток получает 
нулевой уровень приоритета. Как уже упоминалось, этот приоритет зарезервирован 
для потока обнуления страниц, поэтому система не позволяет присвоить его какому-то другому 
потоку. Недоступны также следующие уровни приоритета: 17, 18, 19, 
20, 21, 27, 28, 29 и 30. Они зарезервированы под драйверы устройств, работающие 
в режиме ядра, а потому не присваиваются пользовательским приложениям. Обратите внимание, 
что поток в классе приоритета Realtime не может иметь уровень 
приоритета ниже 16. В то же время потоки в остальных классах приоритета не могут 
получить уровень выше 15.

### ПРИМЕЧАНИЕ

Концепция классов приоритета процесса может навести на мысль, что Windows
каким-то образом управляет очередностью процессов. Но очередность операционная система 
определяет только для потоков. Класс приоритета процесса является
абстрактным понятием, помогающим логически сопоставить относительную важность
одного запущенного приложения с остальными; никаких других функций у него нет.

### ВНИМАНИЕ

Лучше снизить приоритет одного потока, чем повысить приоритет другого. Обычно
понижение приоритета требуется, если поток выполняет длительные вычисления,
например компилирует код, проверяет орфографию, пересчитывает электронные
таблицы и т. п. Повышать приоритет имеет смысл, если поток должен быстро отреагировать 
на какое-то событие, запуститься на короткий промежуток времени и вернуться в состояние 
ожидания. Потоки с высоким приоритетом большую часть своего
существования находятся в режиме ожидания, не влияя на быстродействие всей
системы. В качестве примера потока с высоким приоритетом можно упомянуть поток
Проводника Windows (Windows Explorer), отслеживающий нажатие клавиши Windows
пользователем. Проводник приостанавливает потоки с более низким приоритетом
и немедленно выводит на экран меню. В процессе навигации поток Проводника
Windows быстро отвечает на нажатия клавиш, обновляет меню и приостанавливается
до следующего нажатия клавиши пользователем.

Приложение может менять относительный приоритет своих 
потоков при помощи свойства Priority класса Thread, которому присваивается 
одно из пяти значений (Lowest, BelowNormal, Normal, AboveNormal или Highest), 
определенных в перечислении ThreadPriority. При этом точно так же, как 
Windows резервирует для себя нулевой уровень и уровень реального времени, CLR 
резервирует уровни приоритета Idle и Time-Critical. В настоящее время в CLR 
отсутствуют потоки с уровнем приоритета Idle, но в будущем ситуация может поменяться. 
При этом поток финализации, о котором шла речь в главе 21, исполняется 
на уровне приоритета Time-Critical. Соответственно, разработчикам управляемых 
приложений остаются пять приоритетов потока: в таблице это строки со второй 
(Highest) по шестую (Lowest).

Упомянем о наличии в пространстве имен System.Diagnostics классов Process
и ProcessThread (впрочем, это относится только к настольным приложениям, но не 
к приложениям Windows Store). Они содержат информацию о состоянии процесса 
и потока с точки зрения Windows. Эти классы предназначены для разработчиков, 
желающих написать сервисное приложение на управляемом коде или пытающихся 
оснастить свой код инструментами, помогающими в отладке. Поэтому данные классы 
попали в пространство имен System.Diagnostics. Для доступа к данным классам 
приложениям необходимы специальные права системы безопасности. Вы не сможете 
применить эти классы, к примеру, в приложениях Silverlight или ASP.NET.

С другой стороны, приложения могут воспользоваться классами AppDomain
и Thread, обеспечивающими просмотр средой CLR доменов и потоков. Для работы 
с этими классами по большей части не требуется специальных прав системы безопасности, 
хотя некоторые операции доступны только при наличии определенных 
привилегий.

## Фоновые и активные потоки

В CLR все потоки делятся на активные (foreground) и фоновые (background). При 
завершении активных потоков в процессе CLR принудительно завершает также 
все запущенные на этот момент фоновые потоки. При этом завершение фоновых 
потоков происходит немедленно и без появления исключений.

Следовательно, активные потоки имеет смысл использовать для исполнения 
заданий, которые обязательно требуется завершить — например, для перемещения 
на диск данных из буфера в памяти. Фоновые же потоки можно оставить для таких 
некритичных задач, как пересчет ячеек электронных таблиц или индексирование 
записей. Ведь эта работа может быть продолжена и после перезагрузки приложения, 
а значит, нет необходимости насильно оставлять приложение работать, когда 
пользователь пытается его закрыть.

Концепция активных и фоновых потоков в CLR была введена для лучшей поддержки доменов 
приложений. Как вы знаете, в каждом домене может быть запущено 
отдельное приложение, при этом каждое такое приложение может иметь собственный 
фоновый поток. Даже если одно из приложений завершается, заставляя завершиться 
свой фоновый поток, среда CLR все равно должна функционировать, поддерживая 
остальные приложения. И только после того как все приложения со всеми своими 
фоновыми процессами будут завершены, можно будет уничтожить весь процесс.

Поток можно превращать из активного в фоновый и обратно. Основной поток 
приложения и все потоки, в явном виде созданные путем конструирования объекта 
Thread, по умолчанию являются активными. А вот потоки из пула по умолчанию 
являются фоновыми. Также потоки, создаваемые машинным кодом и попадающие 
в управляемую среду исполнения, помечаются как фоновые

### ВНИМАНИЕ

По возможности старайтесь избегать активных потоков. Однажды меня попросили
определить, почему приложение никак не может завершить свою работу. Провозившись 
несколько часов, я понял, что причиной был компонент пользовательского
интерфейса, в явном виде создающий активный поток. После того как компонент
заставили использовать поток из пула, проблема была решена, а заодно повысилась
и общая эффективность работы приложения.

## Что дальше?

В этой главе мы рассмотрели основы работы с потоками. Надеюсь, вы усвоили, что 
поток исполнения является довольно дорогим ресурсом и использовать его следует 
крайне аккуратно. Лучше всего задействовать пул потоков среды CLR, который 
создает и уничтожает потоки автоматически. Пул предлагает набор потоков для 
решения различных задач, и некоторые из этих потоков вполне справятся с решением задач 
вашего приложения.

В главе 27 мы поговорим о том, каким образом пул потоков позволяет выполнять 
вычислительные операции. Глава 28 посвящена обсуждению того, как с помощью 
комбинации пула потоков и асинхронной модели программирования CLR выполнять операции 
ввода-вывода. Во многих ситуациях асинхронные вычислительные 
операции и операции ввода-вывода можно выполнять таким образом, что синхронизация 
потоков вам вообще не потребуется. Тем не менее остаются ситуации, 
в которых без синхронизации не обойтись. Конструкции, применяемые для синхронизации, 
и разница между ними рассматриваются в главах 29 и 30.